<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="C++ c++参考手册">
<meta property="og:type" content="article">
<meta property="og:title" content="C++">
<meta property="og:url" content="http://yoursite.com/2021/07/06/C++/C++/index.html">
<meta property="og:site_name" content="Chuckie&#39;s Blog">
<meta property="og:description" content="C++ c++参考手册">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/2021/07/06/C++/C++/image-20210816181241344.png">
<meta property="og:image" content="http://yoursite.com/2021/07/06/C++/C++/image-20210907142129928.png">
<meta property="og:image" content="http://yoursite.com/2021/07/06/C++/C++/image-20221118142430669.png">
<meta property="og:image" content="http://yoursite.com/2021/07/06/C++/C++/image-20210907143322981.png">
<meta property="og:image" content="http://yoursite.com/2021/07/06/C++/C++/image-20210907143514046.png">
<meta property="og:image" content="http://yoursite.com/2021/07/06/C++/C++/image-20210907143604498.png">
<meta property="og:image" content="http://yoursite.com/2021/07/06/C++/C++/image-20210907143709667.png">
<meta property="og:image" content="http://yoursite.com/2021/07/06/C++/C++/image-20210907143823901.png">
<meta property="og:image" content="http://yoursite.com/2021/07/06/C++/C++/image-20210907143933016.png">
<meta property="og:image" content="http://yoursite.com/2021/07/06/C++/C++/image-20210907144051673.png">
<meta property="og:image" content="http://yoursite.com/2021/07/06/C++/C++/image-20210907144120057.png">
<meta property="og:image" content="http://yoursite.com/2021/07/06/C++/C++/image-20210907144140147.png">
<meta property="og:image" content="http://yoursite.com/2021/07/06/C++/C++/image-20210907144220778.png">
<meta property="article:published_time" content="2021-07-06T02:43:17.000Z">
<meta property="article:modified_time" content="2024-09-18T15:06:07.114Z">
<meta property="article:author" content="Chuckie">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2021/07/06/C++/C++/image-20210816181241344.png">

<link rel="canonical" href="http://yoursite.com/2021/07/06/C++/C++/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>C++ | Chuckie's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Chuckie's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/07/06/C++/C++/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Chuckie">
      <meta itemprop="description" content="Bright future">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chuckie's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-06 10:43:17" itemprop="dateCreated datePublished" datetime="2021-07-06T10:43:17+08:00">2021-07-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-09-18 23:06:07" itemprop="dateModified" datetime="2024-09-18T23:06:07+08:00">2024-09-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>47k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>42 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><blockquote>
<p><a href="https://qingcms.gitee.io/cppreference/20210212/zh/" target="_blank" rel="noopener">c++参考手册</a></p>
</blockquote>
<h2 id="基础知识点"><a href="#基础知识点" class="headerlink" title="基础知识点"></a>基础知识点</h2><h4 id="编译、链接的过程"><a href="#编译、链接的过程" class="headerlink" title="编译、链接的过程"></a>编译、链接的过程</h4><p><img src="/2021/07/06/C++/C++/image-20210816181241344.png" alt="image-20210816181241344"></p>
<h5 id="pragma-once"><a href="#pragma-once" class="headerlink" title="#pragma once"></a>#pragma once</h5><p>#pragma once是一个比较常用的C/C++杂注，只要在头文件的最开始加入这条杂注，就能够保证头文件只被编译一次。</p>
<p>#pragma once是<a href="https://baike.baidu.com/item/编译器" target="_blank" rel="noopener">编译器</a>相关的，有的编译器支持，有的编译器不支持，具体情况请查看编译器API文档，不过现在大部分编译器都有这个杂注了。</p>
<p>#ifndef，#define，#endif是C/C++语言中的宏定义，通过宏定义避免文件多次编译。所以在所有支持C++语言的编译器上都是有效的，如果写的程序要跨平台，最好使用这种方式。</p>
<p>具体写法：</p>
<p>方式一：</p>
<p>#ifndef <em>SOMEFILE_H</em></p>
<p>#define <em>SOMEFILE_H</em></p>
<p>………. // 一些声明语句</p>
<p>#endif</p>
<p>方式二：</p>
<p>#pragma once</p>
<p>… … // 一些声明语句</p>
<h5 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h5><blockquote>
<p><a href="https://blog.csdn.net/u010977122/article/details/89416520" target="_blank" rel="noopener">C/C++ 宏定义的常见使用</a></p>
</blockquote>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><blockquote>
<p>菜鸟教程c++数据类型：<a href="https://www.runoob.com/cplusplus/cpp-data-types.html" target="_blank" rel="noopener">https://www.runoob.com/cplusplus/cpp-data-types.html</a></p>
<p>数据类型最大可以表示范围：<a href="https://www.acwing.com/blog/content/475/" target="_blank" rel="noopener">https://www.acwing.com/blog/content/475/</a></p>
</blockquote>
<ul>
<li>1byte = 8bits</li>
<li>short类型  2byte    存储范围[-2^15, 2^15-1]  [ -32768 , 32767]</li>
<li>int 类型      4byte</li>
</ul>
<p><img src="/2021/07/06/C++/C++/image-20210907142129928.png" alt="image-20210907142129928"></p>
<p><img src="/2021/07/06/C++/C++/image-20221118142430669.png" alt="image-20221118142430669"></p>
<ul>
<li>单位换算</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1Byte＝8bit</span><br><span class="line">位：位(bit，缩写为b）是存储器的最小单位，可以表示一位二进制数．</span><br><span class="line">字节：1字节（Byte，缩写为B）由8个位组成，即1Byte＝8bit，是存储器的基本单位，通常被作为一个存储单元．</span><br><span class="line">　另外，还使用千字节（KB）、兆字节（MB）、吉字节（GB）甚至太字节（TB），他们之间的换算关系为：</span><br><span class="line">1KB＝1024B</span><br><span class="line">1MB＝1024KB</span><br><span class="line">1GB＝1024MB</span><br><span class="line">1TB＝1024GB</span><br><span class="line">有些人为了方便，就取第一个英文字。比如MB取M，KB取K，GB取G其实不太正确，你在电脑上就不会见到有M、K、G的只有MB、KB、GB</span><br></pre></td></tr></table></figure>



<h4 id="安装IDE"><a href="#安装IDE" class="headerlink" title="安装IDE"></a>安装IDE</h4><blockquote>
<p>一下以vs2015为例</p>
</blockquote>
<ul>
<li>启动</li>
</ul>
<p><img src="/2021/07/06/C++/C++/image-20210907143322981.png" alt="image-20210907143322981"></p>
<ul>
<li>创建项目</li>
</ul>
<p><img src="/2021/07/06/C++/C++/image-20210907143514046.png" alt="image-20210907143514046"></p>
<ul>
<li>编辑选项</li>
</ul>
<p><img src="/2021/07/06/C++/C++/image-20210907143604498.png" alt="image-20210907143604498"></p>
<ul>
<li>生成选项</li>
</ul>
<p><img src="/2021/07/06/C++/C++/image-20210907143709667.png" alt="image-20210907143709667"></p>
<ul>
<li>项目配置选项</li>
</ul>
<p><img src="/2021/07/06/C++/C++/image-20210907143823901.png" alt="image-20210907143823901"></p>
<ul>
<li>调试选项</li>
</ul>
<p><img src="/2021/07/06/C++/C++/image-20210907143933016.png" alt="image-20210907143933016"></p>
<ul>
<li>如何注册</li>
</ul>
<p><img src="/2021/07/06/C++/C++/image-20210907144051673.png" alt="image-20210907144051673"></p>
<p><img src="/2021/07/06/C++/C++/image-20210907144120057.png" alt="image-20210907144120057"></p>
<p><img src="/2021/07/06/C++/C++/image-20210907144140147.png" alt="image-20210907144140147"></p>
<p><img src="/2021/07/06/C++/C++/image-20210907144220778.png" alt="image-20210907144220778"></p>
<h4 id="vs2019快捷键"><a href="#vs2019快捷键" class="headerlink" title="vs2019快捷键"></a>vs2019快捷键</h4><p><a href="https://blog.csdn.net/qq_41979507/article/details/106188486" target="_blank" rel="noopener">vs2019快捷键</a></p>
<ul>
<li><p>光标选中函数名，点<code>F1</code>可以在网页中打开函数的使用方式</p>
</li>
<li><p>代码整体往右移动：</p>
<p>选中需要移动的代码：按tab键</p>
</li>
<li><p>代码整体往左移动：</p>
<p>选中需要移动的代码：按 shift + tab键 </p>
</li>
</ul>
<h4 id="gcc与g-区别"><a href="#gcc与g-区别" class="headerlink" title="gcc与g++区别"></a>gcc与g++区别</h4><blockquote>
<p><a href="https://blog.csdn.net/wuzheyan2008/article/details/119715526" target="_blank" rel="noopener">gcc与g++的区别</a></p>
</blockquote>
<h4 id="void"><a href="#void" class="headerlink" title="void*"></a>void*</h4><blockquote>
<p><a href="https://blog.csdn.net/qingzhuyuxian/article/details/81562713" target="_blank" rel="noopener">void*的意义</a></p>
</blockquote>
<h2 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h2><h3 id="std"><a href="#std" class="headerlink" title="std"></a>std</h3><h4 id="swap"><a href="#swap" class="headerlink" title="swap"></a><a href="https://qingcms.gitee.io/cppreference/20210212/zh/cpp/algorithm/swap.html" target="_blank" rel="noopener">swap</a></h4><ul>
<li>可交换数组中的元素： <code>swap(arr[i],arr[j])</code></li>
</ul>
<h4 id="copy"><a href="#copy" class="headerlink" title="copy"></a><a href>copy</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拷贝一个int型的数组</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span>* <span class="title">copyIntArray</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>* arr = <span class="keyword">new</span> <span class="keyword">int</span>[n]; <span class="comment">//在堆区开辟新的数组存储空间</span></span><br><span class="line">		copy(a, a + n, arr);<span class="comment">//（拷贝起始指针，拷贝结束指针，拷贝到的起始指针）</span></span><br><span class="line">		<span class="keyword">return</span> arr;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="srand-rand"><a href="#srand-rand" class="headerlink" title="srand()  rand()"></a>srand()  rand()</h4><ul>
<li>srand()  需要随机种子 srand(time(NULL))  需要<code>#include &lt;ctime&gt;</code></li>
<li>rand()  返回值: 返回0至RAND_MAX之间的随机整数值，RAND_MAX的范围最小在32767之间。若用unsigned int 双字节是65535，四字节是4294967295的整数范围。且0-RAND_MAX每个数字被选中的机率是相同的。</li>
</ul>
<h2 id="基础容器"><a href="#基础容器" class="headerlink" title="基础容器"></a>基础容器</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul>
<li>计算数组长度</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> len = <span class="keyword">sizeof</span>(a) / szieof(a[<span class="number">0</span>]);   <span class="comment">//sizeof是c++自带函数 sizeof计算的是字节（byte）数，int是4字节，所以sizeof(a)：16  szieof(a[0]：4</span></span><br><span class="line"><span class="comment">//数组名:a指向数组第一个元素，不可更改</span></span><br></pre></td></tr></table></figure>

<h4 id="动态数组vector"><a href="#动态数组vector" class="headerlink" title="动态数组vector"></a>动态数组vector</h4><blockquote>
<p>vector是面向对象方式的动态数组</p>
<p>可以实现动态扩容插入元素</p>
</blockquote>
<ul>
<li><code>vec.push_back()</code>：在尾部添加元素</li>
<li><code>vec.capacity()</code>: 获取数组可容纳的元素个数（不是剩余可容纳的元素，是数组一共可容纳的元素）， 会随着扩容发生变化</li>
<li><code>vec.size()</code>: 获取数组当前元素个数</li>
<li><code>vec.end()</code>: 获取数组结束位置的下标（即数组长度）</li>
<li><code>vec.insert(插入的位置, 插入的元素)</code>: 在中间位置插入元素</li>
<li><code>vec.pop_back()</code>: 删除最后一个元素</li>
<li><code>vec.erase(vec.end()-2)</code>: 删除倒数第二个元素</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; vec = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">    vec.push_back(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity:"</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; vec[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vec.insert(--vec.<span class="built_in">end</span>(), <span class="number">6</span>)<span class="comment">//在倒数第二个位置插入元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><blockquote>
<p><a href="https://blog.csdn.net/manonghouyiming/article/details/79827040" target="_blank" rel="noopener">c和c++字符串比较</a></p>
</blockquote>
<h4 id="c中的字符串"><a href="#c中的字符串" class="headerlink" title="c中的字符串"></a>c中的字符串</h4><ul>
<li>字符串本质是字符数组<ul>
<li><code>&#39;&#39;</code>单引号是字符</li>
<li><code>&quot;&quot;</code>双引号是字符串</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c1 = <span class="number">0</span>;   <span class="comment">//地址：Ox00</span></span><br><span class="line"><span class="keyword">char</span> c2 = <span class="string">'\0'</span>;<span class="comment">//地址：Ox00</span></span><br><span class="line"><span class="keyword">char</span> c3 = <span class="string">'0'</span>; <span class="comment">//地址：0x30</span></span><br><span class="line"><span class="keyword">char</span> item[] = &#123;<span class="string">"helloword"</span>&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://baike.baidu.com/item/ASCII/309296?fr=aladdin" target="_blank" rel="noopener">ASCII</a></li>
</ul>
<h5 id="字符串的指针"><a href="#字符串的指针" class="headerlink" title="字符串的指针"></a>字符串的指针</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">//这里的"hello"是变量</span></span><br><span class="line">    <span class="keyword">char</span> strHelloWorld1[<span class="number">11</span>] = &#123; <span class="string">"hello"</span> &#125;; </span><br><span class="line">    <span class="comment">//这里的"world"是常量</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* pStrHelloWrold = <span class="string">"world"</span>; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; strHelloWorld1 &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 打印结果： hello</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pStrHelloWrold &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 打印结果： world</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *strHelloWorld1 &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 打印结果:  h</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *pStrHelloWrold &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 打印结果:  w</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;strHelloWorld1 &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 打印结果是指针本身的地址</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;pStrHelloWrold &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 打印结果是指针本身的地址</span></span><br><span class="line">    <span class="comment">//strHelloWorld这个指针不可变</span></span><br><span class="line">    strHelloWorld1 = pStrHelloWrold<span class="comment">//报错 strHelloWorld1这个指针是常量，不可做左值</span></span><br><span class="line">    <span class="comment">//strHelloWorld[index]的值可变;</span></span><br><span class="line">    strHelloWorld1[<span class="number">1</span>] = <span class="string">'j'</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; strHelloWorld1 &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 打印结果： hjllo</span></span><br><span class="line">    <span class="comment">//pStrHelloWrold可变，</span></span><br><span class="line">    pStrHelloWrold = strHelloWorld1;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pStrHelloWrold &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 打印结果： hjllo</span></span><br><span class="line">    <span class="comment">// pStrHelloWrold[index]的值可变不可变取决于所指区间的存储区域是否可变;</span></span><br><span class="line">    pStrHelloWrold[<span class="number">1</span>] = <span class="string">'w'</span>;<span class="comment">//不可修改， 因为指针指向的位置存储的值是常量 ？？？？？？？？</span></span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="lt-string-h-gt-API"><a href="#lt-string-h-gt-API" class="headerlink" title="&lt;string.h&gt;API"></a>&lt;string.h&gt;API</h5><blockquote>
<p><a href="https://www.runoob.com/cprogramming/c-standard-library-string-h.html" target="_blank" rel="noopener">c标准库<code>&lt;string.h&gt;</code></a></p>
<ul>
<li><strong>以下函数都是有安全问题的，会出现缓存区溢出的问题</strong><ul>
<li>推荐使用安全函数：strcpy_s()…等</li>
</ul>
</li>
<li>stelen的效率可以提升，strlen是遍历判断’\0’的位置计算长度，但其实可以在创建字符串的时候就用一个变量存储字符串长度，用空间换时间</li>
</ul>
</blockquote>
<ul>
<li><code>strlen()</code>：返回字符有效长度，不包括’\0’</li>
<li><code>strcmp(s1,s2)</code>: 以ASCII比较字符串大小，例：<code>&quot;A&quot;&lt;&quot;B &quot;;&quot;A&quot;&lt;&quot;AB&quot;;&quot;Apple&quot; &lt;&quot;Banana&quot;</code><ul>
<li>如果s1和s2是相同的，则返回0</li>
<li>如果s1&lt;s2则返回值小于0;</li>
<li>如果s1&gt;s2则返回值大于0</li>
</ul>
</li>
<li><code>strcpy(s1,s2)</code>: 将s2复制到s1中</li>
<li>复制指定长度字符串:<code>strncpy(s1, s2,n)</code><ul>
<li>将字符串s2中前n个字符拷贝到s1的前n个位置中;</li>
</ul>
</li>
<li>字符串拼接:<code>strcat(s1, s2)</code><ul>
<li>将字符串s2接到s1后面;</li>
</ul>
</li>
<li>查找字符: <code>strchr(s1, ch)</code><ul>
<li>指向字符串s1中字符ch的第一次出现的位置;</li>
</ul>
</li>
<li>查找字符串: <code>strstr(s1, s2)</code><ul>
<li>指向字符串s1中字符串s2的第一次出现的位置;</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">    <span class="keyword">char</span> a[] = &#123; <span class="string">"heloworld"</span> &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(b):"</span> &lt;&lt; <span class="keyword">sizeof</span>(b) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 16</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"strlen:"</span> &lt;&lt; <span class="built_in">strlen</span>(a) &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">// 10 计算的是有效长度</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(a):"</span> &lt;&lt; <span class="keyword">sizeof</span>(a) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 11 有效长度加尾部的'\0'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_LEN = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[] = &#123; <span class="string">"hello"</span> &#125;;</span><br><span class="line">    <span class="keyword">char</span> b[] = &#123; <span class="string">"world"</span> &#125;;</span><br><span class="line">    <span class="keyword">char</span> c[MAX_LEN] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a:"</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//a:hello</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"b:"</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//b:world</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"c:"</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//c:</span></span><br><span class="line">    <span class="built_in">strcpy</span>(c, a);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"strcpy:c:"</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//strcpy:c:hello</span></span><br><span class="line">    <span class="built_in">strncpy</span>(c, b, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"strncpy:c:"</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//strncpy:c:wollo</span></span><br><span class="line">    <span class="built_in">strcat</span>(c, b);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"strcat:c:"</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//strcat:c:wolloworld</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>PS：</strong></p>
<ul>
<li>在使用上面的<code>&lt;string.h&gt;</code>中的函数时，需要在编译器（vs2019）中做设置</li>
<li>项目根目录右击-点击属性-选择c/c++-选择预处理-选择右侧预处理器定义-点击编辑-在编辑内容的最下面添加<code>_CRT_SECURE_NO_WARNINGS</code></li>
<li>以上配置可以避免警告提示</li>
</ul>
<p><strong>安全API</strong></p>
<blockquote>
<p>添加的了原字符串长度的信息： MIN_SIZE</p>
</blockquote>
<ul>
<li>strcpy_s(b,MIN_SIZE, a)</li>
<li>strncpy_s(b,MIN_SIZE, a)</li>
<li>strcat_s(b,MIN_SIZE, a)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_SIZE = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MIN_SIZE = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[] = &#123; <span class="string">"helloworld"</span> &#125;;</span><br><span class="line">    <span class="keyword">char</span> b[<span class="number">7</span>] = &#123; <span class="string">"world"</span> &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a:"</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"b:"</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    strcpy_s(b,MIN_SIZE, a);<span class="comment">//安全方式 MIN_SIZE是b的最大容纳长度</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a:"</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"b:"</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World!\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="c-中字符串"><a href="#c-中字符串" class="headerlink" title="c++中字符串"></a>c++中字符串</h4><blockquote>
<p><code>&lt;string&gt;</code>库</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;//c++</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//字符串定义</span></span><br><span class="line">    <span class="built_in">string</span> s;<span class="comment">//定义空字符串</span></span><br><span class="line">    <span class="built_in">string</span> s1 = <span class="string">"helloworld"</span>;<span class="comment">//定义并初始化</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(<span class="string">"hello"</span>)</span></span>;<span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">string</span> s3 = <span class="built_in">string</span>(<span class="string">"helloworld"</span>);</span><br><span class="line">    <span class="comment">//获取字符长度</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s1.length() &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//10 string字符串没有'\0'</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s1.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//10</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s1.capacity() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//字符串可容纳的元素个数</span></span><br><span class="line">    <span class="comment">//比较字符串</span></span><br><span class="line">    <span class="built_in">string</span> c;</span><br><span class="line">    <span class="built_in">string</span> c1 = <span class="string">"helloworld"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (s == c) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//1</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (s1 == c1) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//1</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (s1 == s2) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//0</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (s3 != s2) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//1</span></span><br><span class="line">    <span class="comment">//string字符串转换为c风格字符串</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* c_str1 = s1.c_str();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"c_str:"</span> &lt;&lt; c_str1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"c_str1[2]:"</span>&lt;&lt; c_str1[<span class="number">2</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//下标访问</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"s1[2]:"</span>&lt;&lt;s1[<span class="number">2</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//字符串拷贝</span></span><br><span class="line">    <span class="built_in">string</span> t1 = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="built_in">string</span> t2 = t1;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"t2:"</span> &lt;&lt; t2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//字符串链接</span></span><br><span class="line">    <span class="built_in">string</span> t3 = t1 + t2;</span><br><span class="line">    t2 += t1;<span class="comment">//t2 = t2 + t1</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"t3:"</span> &lt;&lt; t3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"t2:"</span> &lt;&lt; t2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="字符数组与数组"><a href="#字符数组与数组" class="headerlink" title="字符数组与数组"></a>字符数组与数组</h4><p><strong>数组</strong></p>
<ul>
<li>数组名本身是一个指向数组第一个元素的指针</li>
<li>不能通过数组名一次输出数组全部元素</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">int</span> c[<span class="number">4</span>] = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">int</span>* p;</span><br><span class="line">p = c;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//打印结果：数组c的第一个元素的地址即c[0]的地址</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *c &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//打印结果：0</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//打印结果：数组c的第一个元素的地址即c[0]的地址</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//打印结果：0</span></span><br></pre></td></tr></table></figure>

<p><strong>字符数组</strong></p>
<ul>
<li>可以通过字符数组名直接输出字符串</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里的"hello"是变量</span></span><br><span class="line"><span class="keyword">char</span> strHelloWorld1[<span class="number">11</span>] = &#123; <span class="string">"hello"</span> &#125;; </span><br><span class="line"><span class="comment">//这里的"world"是常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* pStrHelloWrold = <span class="string">"world"</span>; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; strHelloWorld1 &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 打印结果： hello</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pStrHelloWrold &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 打印结果： world</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *strHelloWorld1 &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 打印结果:  h</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *pStrHelloWrold &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 打印结果:  w</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; &amp;strHelloWorld1 &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 打印结果是指针本身的地址</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; &amp;pStrHelloWrold &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 打印结果是指针本身的地址</span></span><br></pre></td></tr></table></figure>



<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h3 id="嵌入式指针"><a href="#嵌入式指针" class="headerlink" title="嵌入式指针"></a>嵌入式指针</h3><blockquote>
<p>使用场景：内存分配，内存管理</p>
</blockquote>
<blockquote>
<p><a href="https://blog.csdn.net/qq_42604176/article/details/113871565" target="_blank" rel="noopener">https://blog.csdn.net/qq_42604176/article/details/113871565</a></p>
</blockquote>
<h3 id="常见指针"><a href="#常见指针" class="headerlink" title="常见指针"></a>常见指针</h3><h4 id="数组指针与指针数组"><a href="#数组指针与指针数组" class="headerlink" title="数组指针与指针数组"></a>数组指针与指针数组</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">	<span class="keyword">int</span> c[<span class="number">4</span>] = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span>* a[<span class="number">4</span>];  <span class="comment">//指针数组，a是一个数组，数组有4个元素，每个元素是一个int型的指针</span></span><br><span class="line">	<span class="keyword">int</span>(*b)[<span class="number">4</span>]; <span class="comment">//数组指针， b是一个指向数组的指针，这个数组有4个元素，每个元素是一个int型的值，</span></span><br><span class="line">	<span class="keyword">int</span>* p;</span><br><span class="line">	p = c;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//打印结果：数组c的第一个元素的地址即c[0]的地址</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *c &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//打印结果：0</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//打印结果：数组c的第一个元素的地址即c[0]的地址</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//打印结果：0</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; c[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//打印结果：0</span></span><br><span class="line">    </span><br><span class="line">	b = &amp;c;     <span class="comment">//此时b是一个指向指针的指针，b存储的是c的地址，c存储的是c[0]的地址</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (*b)[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//打印结果：0  相当于c[0]</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">//将数组c中元素复制到a中</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">		a[i] = &amp;(c[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *(a[<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//0  相当于c[0]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="cosnt与指针"><a href="#cosnt与指针" class="headerlink" title="cosnt与指针"></a>cosnt与指针</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_LEN = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> p[] = <span class="string">"chuckie"</span>;</span><br><span class="line">	<span class="comment">//p2存储的地址可变，p2指向的那一片地址的内容不可变，即指针的值可变，指针指向的内容的值不可变</span></span><br><span class="line">	<span class="keyword">char</span> <span class="keyword">const</span>* p2 = <span class="string">"world"</span>;<span class="comment">//等同于const char*   </span></span><br><span class="line">	<span class="comment">//p3存储的地址不可变, p3指向的那一片地址的内容可变</span></span><br><span class="line">	<span class="keyword">char</span>* <span class="keyword">const</span> p3 = p;</span><br><span class="line">	<span class="comment">//p4存储的地址不可变，p4指向的那一片地址的内容也不可变</span></span><br><span class="line">	<span class="keyword">char</span> <span class="keyword">const</span>* <span class="keyword">const</span> p4 = <span class="string">"maxthon"</span>; <span class="comment">//等同于 const char* const</span></span><br><span class="line">	p2 = p;</span><br><span class="line">	<span class="comment">//p3 = p; //p3不可变</span></span><br><span class="line">	<span class="comment">//p4 = p; //p4不可变</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> len = strnlen_s(p, MAX_LEN);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		<span class="comment">//p2[i] += 1; p2指向的内容不可变</span></span><br><span class="line">		p3[i] += <span class="number">1</span>;   <span class="comment">//p3指向的内容可变 其实此时p2,p3都指向p， 但p2指向的内容是不可变的？？？？</span></span><br><span class="line">		<span class="comment">//p4[i] += 1; p4指向的内容不可变</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">123</span>;</span><br><span class="line">	<span class="keyword">int</span>* b = &amp;a;</span><br><span class="line">	<span class="keyword">int</span>** d = &amp;b; <span class="comment">//指向指针的指针</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; &amp;a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; &amp;b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; d &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">//打印结果</span></span><br><span class="line">	<span class="comment">/*123</span></span><br><span class="line"><span class="comment">		00F3FDDC</span></span><br><span class="line"><span class="comment">		00F3FDDC</span></span><br><span class="line"><span class="comment">		00F3FDD0</span></span><br><span class="line"><span class="comment">		00F3FDD0*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="易错指针"><a href="#易错指针" class="headerlink" title="易错指针"></a>易错指针</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *a ;</span><br><span class="line">*a = <span class="number">12</span>; <span class="comment">// 出错</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>没有给a赋值，系统会随机分配</p>
<ul>
<li>运气好的话:定位到一个非法地址，程序会出错，从而终止。</li>
<li>最坏的情况:定位到一个可以访问的地址，无意修改了它,这样的错误难以捕捉，引发的错误<br>可能与原先用于操作的代码完全不相干!</li>
</ul>
</li>
<li><p>用指针进行间接访问之前，一定要非常小心，确保它已经初始化,并被恰当的赋值。</p>
</li>
</ul>
<p><strong>NULL指针</strong></p>
<ul>
<li>NULL指针不指向任何内容</li>
<li>当一个指针不确定要指向什么位置时就赋值为NULL</li>
<li>在使用指针前先判断指针是否为NULL</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">int</span>* pa = <span class="literal">NULL</span>;<span class="comment">//初始值不确定则设为NULL</span></span><br><span class="line">pa = &amp;a;</span><br><span class="line"><span class="keyword">if</span> (pa != <span class="literal">NULL</span>) &#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *pa &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//123</span></span><br><span class="line">&#125;</span><br><span class="line">pa = <span class="literal">NULL</span>;<span class="comment">// 不使用时也设置为NULL</span></span><br></pre></td></tr></table></figure>

<p><strong>野指针</strong></p>
<p>野指针即指向不确定的地址的指针</p>
<ul>
<li>1.指针变量没有初始化;</li>
<li>2.已经释放不用的指针没有置NULL，如delete和free之后的指针;</li>
<li>3.指针操作超越了变量的作用范围; （指向的内存空间有生命周期，到期后就收回了，但是指针还指向那里，此时就有可能出错）</li>
</ul>
<h3 id="指针的基本运算"><a href="#指针的基本运算" class="headerlink" title="指针的基本运算"></a>指针的基本运算</h3><h4 id="与–操作符"><a href="#与–操作符" class="headerlink" title="++与–操作符"></a>++与–操作符</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* cp1 = cp++; <span class="comment">//先将cp的值赋值给cp1   再计算cp自加1</span></span><br><span class="line"><span class="keyword">char</span>* cp2 = ++cp; <span class="comment">//先计算cp自加1， 再将计算的结果赋值给cp1</span></span><br><span class="line"></span><br><span class="line">*p2++ <span class="comment">//先指向p2的值，再计算p2自加，*优先级高于+</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">char</span> a[] = <span class="string">"chuckie"</span>;</span><br><span class="line">	<span class="keyword">char</span>* p = a;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//c</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;*p++ &lt;&lt;<span class="built_in">endl</span>; <span class="comment">//c</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//h</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; * p++ &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//uhu</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c;</span><br><span class="line"><span class="keyword">char</span> t[] = <span class="string">"chuckie"</span>;</span><br><span class="line">c = a++ + b;<span class="comment">//相当于(a++) + b</span></span><br><span class="line"><span class="comment">//d = a++++b;//相当于a++ ++b  error</span></span><br><span class="line"><span class="keyword">char</span>* cp = t;</span><br><span class="line"><span class="comment">//++(*(++cp)) cp自加1地址变到t[1]的位置，再取t[1]的值，对取到的值自加1</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;++*++cp&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//打印结果： i</span></span><br></pre></td></tr></table></figure>



<h3 id="存储区划分"><a href="#存储区划分" class="headerlink" title="存储区划分"></a>存储区划分</h3><ul>
<li>c++中用关键字<code>new</code>、<code>delete</code>、<code>delete[]</code>创建和释放堆区变量</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>; <span class="comment">//(GVAR)全局初始化区</span></span><br><span class="line"><span class="keyword">int</span>* p1;   <span class="comment">//(bss)全局未初始化区</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> <span class="comment">//(text)代码区</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//栈区变量（以栈的方式存储，即先定义的变量地址大，后定义的变量地址小）		</span></span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">1</span>;       <span class="comment">//(stack)栈区变量</span></span><br><span class="line">	<span class="keyword">char</span> s[] = <span class="string">"abc"</span>;<span class="comment">//(stack)栈区变量</span></span><br><span class="line">	<span class="keyword">int</span>* p2 = <span class="literal">NULL</span>;  <span class="comment">//(stack)栈区变量</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>* p3 = <span class="string">"123456"</span>;<span class="comment">// 123456\0在常量区, p3在(stack)栈区</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> c = <span class="number">0</span>;<span class="comment">//(GVAR)全局(静态)初始化区</span></span><br><span class="line">	<span class="comment">//new产生的变量都在堆区（以队列的方式存储，即先定义的先地址小，后定义的地址大） 配合delete使用</span></span><br><span class="line">	p1 = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>);<span class="comment">//10(heap)堆区变量  p1(bss)全局未初始化区</span></span><br><span class="line">	p2 = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">20</span>);<span class="comment">//20(heap)堆区变量  p4在栈区 </span></span><br><span class="line">	<span class="keyword">char</span>* p4 = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">7</span>];<span class="comment">//字符串在(heap)堆区变量  p4在栈区 </span></span><br><span class="line">	strcpy_s(p4, <span class="number">7</span>, <span class="string">"123456"</span>);<span class="comment">//(text)代码区</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (p1 != <span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">		<span class="keyword">delete</span> p1; <span class="comment">//释放的是p1指向的堆区变量</span></span><br><span class="line">		p1 = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (p2 != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span> p2;</span><br><span class="line">		p2 = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (p4 != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span>[] p4; <span class="comment">//释放指向数组的指针需要用关键字delete[]</span></span><br><span class="line">		p4 = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">// (text)代码区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><ul>
<li>智能指针的核心功能是可以自动释放内存，不用开发者手动释放</li>
</ul>
<h4 id="auto-ptr"><a href="#auto-ptr" class="headerlink" title="auto_ptr"></a>auto_ptr</h4><ul>
<li>由new 创建堆区内容，auto_ptr指向这个堆区内容，在auto_ptr指针销毁时，他所指向的堆区也会自动被delete 掉。</li>
<li>所有权转移:不小心把它传递给另外的智能指针，原来的指针就不再拥有这个对象了。在拷贝/赋值过程中，会直接剥夺指针对原对象对内存的控制权，<br>转交给新对象，然后再将原对象指针置为nullptr。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt; //智能指针库</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	&#123;<span class="comment">// 确定auto_ptr失效的范围，&#123;&#125;块内的代码执行完后，auto_ptr指向的内容就会释放</span></span><br><span class="line">		<span class="comment">// 对int使用</span></span><br><span class="line">		<span class="function"><span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">pI</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *pI &lt;&lt; <span class="built_in">endl</span>;                <span class="comment">// 10 </span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// auto_ptr	C++ 17中移除	拥有严格对象所有权语义的智能指针</span></span><br><span class="line">		<span class="comment">// auto_ptr原理：在拷贝 / 赋值过程中，直接剥夺原对象对内存的控制权，转交给新对象，</span></span><br><span class="line">		<span class="comment">// 然后再将原对象指针置为nullptr（早期：NULL）。这种做法也叫管理权转移。</span></span><br><span class="line">		<span class="comment">// 他的缺点不言而喻，当我们再次去访问原对象时，程序就会报错，所以auto_ptr可以说实现的不好，</span></span><br><span class="line">		<span class="comment">// 很多企业在其库内也是要求不准使用auto_ptr。</span></span><br><span class="line">		<span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt; languages[<span class="number">5</span>] = &#123;</span><br><span class="line">			<span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt;(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"C"</span>)),</span><br><span class="line">			<span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt;(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"Java"</span>)),</span><br><span class="line">			<span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt;(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"C++"</span>)),</span><br><span class="line">			<span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt;(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"Python"</span>)),</span><br><span class="line">			<span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt;(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"Rust"</span>))</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"There are some computer languages here first time: \n"</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; *languages[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt; pC;</span><br><span class="line">		pC = languages[<span class="number">2</span>]; <span class="comment">// languges[2] loses ownership. 将所有权从languges[2]转让给pC，</span></span><br><span class="line">		<span class="comment">//此时languges[2]不再引用该字符串,而是变成空指针</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"There are some computer languages here second time: \n"</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; *languages[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"The winner is "</span> &lt;&lt; *pC &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; "There are some computer languages here third time: \n";</span></span><br><span class="line">		<span class="comment">//for (int i = 0; i &lt; 5; ++i)</span></span><br><span class="line">		<span class="comment">//&#123;</span></span><br><span class="line">		<span class="comment">//	cout &lt;&lt; *languages[i] &lt;&lt; endl;  // 此处报错，因为*languages[2]时无法访问，此时所有权已经从languges[2]转让给pC了</span></span><br><span class="line">		<span class="comment">//&#125;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h4><ul>
<li>unique_ptr是专属所有权所以unique_ptr管理的内存，只能被一个对象持有，不支持复制和赋值。</li>
<li>移动语义: unique_ptr禁止了拷贝语义，但有时我们也需要能够转移所有权于是提供了移动语义，即可以使用std.move()进行控制所有权的转移。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; //智能指针库</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 在这个范围之外，unique_ptr被释放</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> i = <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt;(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>));</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// unique_ptr</span></span><br><span class="line">	<span class="keyword">auto</span> w = <span class="built_in">std</span>::make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *(w.<span class="built_in">get</span>()) &lt;&lt; <span class="built_in">endl</span>;                             <span class="comment">// 10</span></span><br><span class="line">	<span class="comment">//auto w2 = w; // 编译错误如果想要把 w 复制给 w2, 是不可以的。</span></span><br><span class="line">	<span class="comment">//  因为复制从语义上来说，两个对象将共享同一块内存。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// unique_ptr 只支持移动语义, 即如下</span></span><br><span class="line">	<span class="keyword">auto</span> w2 = <span class="built_in">std</span>::<span class="built_in">move</span>(w); <span class="comment">// w2 获得内存所有权，w 此时等于 nullptr</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ((w.<span class="built_in">get</span>() != <span class="literal">nullptr</span>) ? (*w.<span class="built_in">get</span>()) : <span class="number">-1</span>) &lt;&lt; <span class="built_in">endl</span>;       <span class="comment">// -1</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ((w2.<span class="built_in">get</span>() != <span class="literal">nullptr</span>) ? (*w2.<span class="built_in">get</span>()) : <span class="number">-1</span>) &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">// 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用已有指针创建<ul>
<li>原始指针赋值给unique_ptr后应该置空，不能让原始指针还能修改对象</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Cat* p1 = <span class="keyword">new</span> Cat(<span class="string">"ok"</span>);</span><br><span class="line"><span class="function"><span class="built_in">unique_ptr</span> <span class="title">up1</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line">p1-&gt;setCont(<span class="string">"okk"</span>);  <span class="comment">// 此时p1还能使用，且可以修改对象，修改后up1访问也会改变， 这明显是不符合独占的</span></span><br><span class="line">up1-&gt;<span class="built_in">print</span>(); <span class="comment">// okk</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值给up1后应该置空</span></span><br><span class="line">p1 = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>作为函数参数<ul>
<li>一般使用const &amp;</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Cat()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Cat()"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Cat(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name):name(name)&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Cat(const string&amp; name):name(name)"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  ~Cat()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"~Cat()"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="built_in">unique_ptr</span>&lt;Cat&gt; cat)</span></span>&#123;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;cat-&gt;getName()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">const</span> <span class="built_in">unique_ptr</span>&lt;Cat&gt;&amp; cat)</span></span>&#123;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;cat-&gt;getName()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">unique_ptr</span>&lt;Cat&gt; <span class="title">cat</span><span class="params">(<span class="keyword">new</span> Cat(<span class="string">"Tom"</span>))</span></span>;</span><br><span class="line">  <span class="comment">// func(move(cat));</span></span><br><span class="line">  <span class="comment">// cout&lt;&lt;cat-&gt;getName()&lt;&lt;endl; // 报错，因为所有权已经转给func了</span></span><br><span class="line">  func2(cat);</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;cat-&gt;getName()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 成功，因为func2是const引用，不会改变cat的所有权</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h4><ul>
<li>介绍<ul>
<li>shared_ptr通过一个<strong>引用计数</strong>共享一个对象。</li>
<li>shared ptr是为了[解决auto _ptr在对象所有权上的局限性，在使用引用计数的机制上提供了可以共享所有权的智能指针，当然这需要额外的开销。</li>
<li>当引用计数为0时，该对象没有被使用，可以进行析构。</li>
</ul>
</li>
<li>问题<ul>
<li>循环引用:引用计数会带来循环引用的问题</li>
<li>循环引用会导致堆里的内存无法正常回收，造成内存泄漏。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 在这个范围之外，unique_ptr被释放</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> i = <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt;(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>));</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// unique_ptr</span></span><br><span class="line">	<span class="keyword">auto</span> w = <span class="built_in">std</span>::make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *(w.<span class="built_in">get</span>()) &lt;&lt; <span class="built_in">endl</span>;                             <span class="comment">// 10</span></span><br><span class="line">	<span class="comment">//auto w2 = w; // 编译错误如果想要把 w 复制给 w2, 是不可以的。</span></span><br><span class="line">	<span class="comment">//  因为复制从语义上来说，两个对象将共享同一块内存。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// unique_ptr 只支持移动语义, 即如下</span></span><br><span class="line">	<span class="keyword">auto</span> w2 = <span class="built_in">std</span>::<span class="built_in">move</span>(w); <span class="comment">// w2 获得内存所有权，w 此时等于 nullptr</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ((w.<span class="built_in">get</span>() != <span class="literal">nullptr</span>) ? (*w.<span class="built_in">get</span>()) : <span class="number">-1</span>) &lt;&lt; <span class="built_in">endl</span>;       <span class="comment">// -1</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ((w2.<span class="built_in">get</span>() != <span class="literal">nullptr</span>) ? (*w2.<span class="built_in">get</span>()) : <span class="number">-1</span>) &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">// 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>原始指针构造<ul>
<li>原始指针构造完应该置nullptr， 避免原始指针对数据的修改</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Cat()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Cat()"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Cat(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name):name(name)&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Cat(const string&amp; name):name(name)"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  ~Cat()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"~Cat()"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Cat* p1 = <span class="keyword">new</span> Cat(<span class="string">"okk"</span>);</span><br><span class="line">  <span class="built_in">shared_ptr</span>&lt;Cat&gt; p2&#123;p1&#125;;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"p2.use_count()="</span>&lt;&lt;p2.use_count()&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">// 1</span></span><br><span class="line">  <span class="comment">// delete p1;</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;p1-&gt;getName()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;p2-&gt;getName()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  p1-&gt;setName(<span class="string">"okkkkk"</span>);</span><br><span class="line">  p1 = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"p2.use_count()="</span>&lt;&lt;p2.use_count()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;p2-&gt;getName()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印</span></span><br><span class="line">Cat(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name):name(name)</span><br><span class="line">p2.use_count()=<span class="number">1</span></span><br><span class="line">okk</span><br><span class="line">okk</span><br><span class="line">p2.use_count()=<span class="number">1</span></span><br><span class="line">okkkkk</span><br><span class="line">~Cat()</span><br></pre></td></tr></table></figure>



<h4 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h4><ul>
<li>weak ptr被设计为与shared ptr 共同工作，用一种观察者模式工作。</li>
<li>作用是协助shared_ptr工作，可获得资源的观测权，</li>
<li>像旁观者那样观测资源的使用情况。</li>
<li>观察者意味着weak ptr只对shared ptr进行引用，而不改变其引用计数,当被观察的shared_ptr失效后，相应的weak_ptr 也相应失效。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//// shared_ptr </span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	//shared_ptr 代表的是共享所有权，即多个 shared_ptr 可以共享同一块内存。</span></span><br><span class="line">	<span class="comment">//	auto wA = shared_ptr&lt;int&gt;(new int(20));</span></span><br><span class="line">	<span class="comment">//	&#123;</span></span><br><span class="line">	<span class="comment">//		auto wA2 = wA;</span></span><br><span class="line">	<span class="comment">//		cout &lt;&lt; ((wA2.get() != nullptr) ? (*wA2.get()) : -1) &lt;&lt; endl;       // 20</span></span><br><span class="line">	<span class="comment">//		cout &lt;&lt; ((wA.get() != nullptr) ? (*wA.get()) : -1) &lt;&lt; endl;           // 20</span></span><br><span class="line">	<span class="comment">//		cout &lt;&lt; wA2.use_count() &lt;&lt; endl;                                              // 2</span></span><br><span class="line">	<span class="comment">//		cout &lt;&lt; wA.use_count() &lt;&lt; endl;                                                // 2</span></span><br><span class="line">	<span class="comment">//	&#125;</span></span><br><span class="line">	<span class="comment">//	//cout &lt;&lt; wA2.use_count() &lt;&lt; endl;       //作用域外，已经销毁                                        </span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; wA.use_count() &lt;&lt; endl;                                                    // 1</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; ((wA.get() != nullptr) ? (*wA.get()) : -1) &lt;&lt; endl;               // 20</span></span><br><span class="line">	<span class="comment">//	//shared_ptr 内部是利用引用计数来实现内存的自动管理，每当复制一个 shared_ptr，</span></span><br><span class="line">	<span class="comment">//	//	引用计数会 + 1。当一个 shared_ptr 离开作用域时，引用计数会 - 1。</span></span><br><span class="line">	<span class="comment">//	//	当引用计数为 0 的时候，则 delete 内存。</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// move 语法</span></span><br><span class="line">	<span class="keyword">auto</span> wAA = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">30</span>);</span><br><span class="line">	<span class="keyword">auto</span> wAA2 = <span class="built_in">std</span>::<span class="built_in">move</span>(wAA); <span class="comment">// 此时 wAA 等于 nullptr，wAA2.use_count() 等于 1</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ((wAA.<span class="built_in">get</span>() != <span class="literal">nullptr</span>) ? (*wAA.<span class="built_in">get</span>()) : <span class="number">-1</span>) &lt;&lt; <span class="built_in">endl</span>;          <span class="comment">// -1</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ((wAA2.<span class="built_in">get</span>() != <span class="literal">nullptr</span>) ? (*wAA2.<span class="built_in">get</span>()) : <span class="number">-1</span>) &lt;&lt; <span class="built_in">endl</span>;      <span class="comment">// 30</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; wAA.use_count() &lt;&lt; <span class="built_in">endl</span>;                                                  <span class="comment">// 0</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; wAA2.use_count() &lt;&lt; <span class="built_in">endl</span>;                                                <span class="comment">// 1</span></span><br><span class="line">	<span class="comment">//将 wAA 对象 move 给 wAA2，意味着 wAA 放弃了对内存的所有权和管理，此时 wAA对象等于 nullptr。</span></span><br><span class="line">	<span class="comment">//而 wAA2 获得了对象所有权，但因为此时 wAA 已不再持有对象，因此 wAA2 的引用计数为 1。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>weak_ptr解决循环引用的问题</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo5-11.cpp : 定义控制台应用程序的入口点。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">	<span class="built_in">shared_ptr</span>&lt;B&gt; pb;</span><br><span class="line">	~A()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"~A()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span></span><br><span class="line">	<span class="built_in">shared_ptr</span>&lt;A&gt; pa;</span><br><span class="line">	~B()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"~B()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pa 和 pb 存在着循环引用，根据 shared_ptr 引用计数的原理，pa 和 pb 都无法被正常的释放。</span></span><br><span class="line"><span class="comment">// weak_ptr 是为了解决 shared_ptr 双向引用的问题。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BW</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AW</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="built_in">shared_ptr</span>&lt;BW&gt; pb;</span><br><span class="line">	~AW()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"~AW()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BW</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	weak_ptr&lt;AW&gt; pa;</span><br><span class="line">	~BW()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"~BW()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Test shared_ptr and shared_ptr:  "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="function"><span class="built_in">shared_ptr</span>&lt;A&gt; <span class="title">tA</span><span class="params">(<span class="keyword">new</span> A())</span></span>;                                              </span><br><span class="line">	<span class="function"><span class="built_in">shared_ptr</span>&lt;B&gt; <span class="title">tB</span><span class="params">(<span class="keyword">new</span> B())</span></span>;                                              </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; tA.use_count() &lt;&lt; <span class="built_in">endl</span>;										  <span class="comment">//1</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; tB.use_count() &lt;&lt; <span class="built_in">endl</span>;                                       <span class="comment">//1</span></span><br><span class="line">	tA-&gt;pb = tB;</span><br><span class="line">	tB-&gt;pa = tA;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; tA.use_count() &lt;&lt; <span class="built_in">endl</span>;                                        <span class="comment">// 2</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; tB.use_count() &lt;&lt; <span class="built_in">endl</span>;                                        <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Test weak_ptr and shared_ptr:  "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="function"><span class="built_in">shared_ptr</span>&lt;AW&gt; <span class="title">tA</span><span class="params">(<span class="keyword">new</span> AW())</span></span>;</span><br><span class="line">	<span class="function"><span class="built_in">shared_ptr</span>&lt;BW&gt; <span class="title">tB</span><span class="params">(<span class="keyword">new</span> BW())</span></span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; tA.use_count() &lt;&lt; <span class="built_in">endl</span>;                                        <span class="comment">// 1</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; tB.use_count() &lt;&lt; <span class="built_in">endl</span>;                                        <span class="comment">// 1</span></span><br><span class="line">	tA-&gt;pb = tB;</span><br><span class="line">	tB-&gt;pa = tA;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; tA.use_count() &lt;&lt; <span class="built_in">endl</span>;                                        <span class="comment">// 1</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; tB.use_count() &lt;&lt; <span class="built_in">endl</span>;                                        <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Test();   <span class="comment">//执行结束后不会打印 ~A() ~B()  因为循环引用，内存没有被释放</span></span><br><span class="line">	Test2();  <span class="comment">//执行结束后会打印 ~AW() ~BW()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><blockquote>
<p> 是一种特殊的指针，不允许修改的指针</p>
</blockquote>
<ul>
<li>使用指针有哪些坑:<ul>
<li>1.空指针;</li>
<li>⒉野指针;</li>
<li>3.不知不觉改变了指针的值，却继续使用;</li>
</ul>
</li>
<li>使用引用，则可以:<ul>
<li>1.不存在空引用;</li>
<li>⒉必须初始化;</li>
<li>3.一个引用永远指向它初始化的那个对象;</li>
</ul>
</li>
<li>有了指针为什么还需要引用?<ul>
<li>Bjarne Stroustrup的解释: 为了支持函数运算符重载;</li>
</ul>
</li>
<li>有了引用为什么还需要指针?<ul>
<li>Bjarne Stroustrup的解释: 为了兼容C语言;</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编写一个函数，输入两个int型变量a,b</span></span><br><span class="line"><span class="comment">// 实现在函数内部将a,b的值进行交换。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> tmp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap2</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span>* b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> tmp = *a;</span><br><span class="line">	*a = *b;</span><br><span class="line">	*b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//int x = 1, x2 = 3;</span></span><br><span class="line">	<span class="comment">//int&amp; rx = x;</span></span><br><span class="line">	<span class="comment">//rx = 2;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; rx &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//rx = x2;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; rx &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 交换变量的测试</span></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">3</span>, b = <span class="number">4</span>;</span><br><span class="line">	swap(a, b);</span><br><span class="line">	assert(a == <span class="number">4</span> &amp;&amp; b == <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	a = <span class="number">3</span>, b = <span class="number">4</span>;</span><br><span class="line">	swap2(&amp;a, &amp;b);</span><br><span class="line">	assert(a == <span class="number">4</span> &amp;&amp; b == <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><blockquote>
<p>C++使用struct、class来定义一个类</p>
<ul>
<li>struct的默认成员枚限是public,</li>
<li>class的默认成员权限是private,</li>
<li>除此之外，二者基本无差别;</li>
</ul>
</blockquote>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><blockquote>
<p><a href="https://blog.csdn.net/qq_38231713/category_10001159.html" target="_blank" rel="noopener">课程笔记</a></p>
<p>视频链接： <a href="https://www.bilibili.com/video/BV1Yb411L7ak?p=1&amp;vd_source=7230a052308bbb41976f248d2c778e3a" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Yb411L7ak?p=1&amp;vd_source=7230a052308bbb41976f248d2c778e3a</a></p>
</blockquote>
<p><strong>为什么要用多线程</strong></p>
<ul>
<li>任务分解<ul>
<li>耗时的操作，任务分解，实时响应</li>
</ul>
</li>
<li>数据分解<ul>
<li>充分利用多核CPU处理数据</li>
</ul>
</li>
<li>数据流分解<ul>
<li>读写分离，解耦合设计</li>
</ul>
</li>
</ul>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>并行： 多核</li>
<li>并发： 单核</li>
<li>可执行程序<ul>
<li>windows: 扩展名为.exe的文件</li>
<li>Linux: ls -la  后缀为rwx（x执行权限）</li>
</ul>
</li>
<li>进程： 运行起来的可执行程序  资源分配的基本单元</li>
<li>线程  程序执行的基本单元<ul>
<li>每个进程（执行起来的可执行程序），都有一个主线程，这个主线程是唯一的。<ul>
<li>当执行可执行程序，产生一个进程后，这个主线程就随着这个进程启动起来了。</li>
<li>ctrl+f5运行这个程序的时候，实际上是进程的主线程来执行（调用)这个main函数中的代码。</li>
</ul>
</li>
<li>线程:用来执行代码的;<ul>
<li>线程可以理解成一条代码的执行通路(道路）;</li>
<li>除了主线程之外，可以通过自己写代码来创建其他线程，其他线程走的是别的道路，甚至去不同的地方</li>
<li>每创建一个新线程，可以在同一个时刻，干多个不同的事(多走一条不同的代码执行路径）;</li>
<li>多线程(并发),线程并不是越多越好<ul>
<li>每个线程，都需要一个独立的堆栈空间（1M)，线程之间的切换要保存很多中间状态;</li>
<li>切换会耗费本该属于程序运行的时间;</li>
<li>建议不要超过200-300个</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>并发的实现方法</strong></p>
<ul>
<li>多个进程实现并发<ul>
<li>进程之间通信<ul>
<li>同一个电脑上:管道，文件，消息对列，共享内存) ; </li>
<li>不同电脑上:socket通信技术;</li>
</ul>
</li>
</ul>
</li>
<li>在单个进程中，创建多个线程实现并发<ul>
<li>线程像轻量级的进程。每个线程都有自己独立的运行路径，但是一个进程中的所有线程共享地址空间(共享内存)<ul>
<li>全局变量，指针，引用都可以在线程之间传递，</li>
<li>使用多线程开销远远小于多进程。</li>
<li>共享内存带来新问题，数据一致性问题。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><h4 id="c-11多线程API"><a href="#c-11多线程API" class="headerlink" title="c++11多线程API"></a>c++11多线程API</h4><ul>
<li>线程ID</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::this_thread::get_id();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"子线程id:"</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id()&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>thread</li>
<li>join</li>
<li>detach</li>
<li>joinable</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;//引入进程库</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一、用函数作为可调用对象创建线程</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myprint</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"我的线程开始执行了"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"我的线程执行完毕了1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"我的线程执行完毕了2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"我的线程执行完毕了3"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"我的线程执行完毕了4"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"我的线程执行完毕了5"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"我的线程执行完毕了6"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"我的线程执行完毕了7"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"我的线程执行完毕了8"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"我的线程执行完毕了9"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World!\n"</span>;</span><br><span class="line">    <span class="comment">// 1 thread: 创建子线程并执行子线程</span></span><br><span class="line">    <span class="function">thread <span class="title">myobj</span><span class="params">(myprint)</span></span>;</span><br><span class="line">    <span class="comment">// 2 joinable: 判断join和detach是否用过，用过则为false，没用则为true</span></span><br><span class="line">    <span class="keyword">if</span> (myobj.joinable())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"1joinable===true"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"1joinable===false"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3 join: 阻塞主线程，并等待子线程执行完成</span></span><br><span class="line">    myobj.join();</span><br><span class="line">    <span class="comment">// 4 detach: 主线程不等子线程，主线程和子线程分开执行，子线程驻留后台运行</span></span><br><span class="line">    <span class="comment">//此时子线程相当于被C++时库接管，当子线程执行完成后，由运行时库负责清理该线程相关资源</span></span><br><span class="line">    <span class="comment">//myobj.detach();</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (myobj.joinable())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"2joinable===true"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"2joinable===false"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"I love China"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"I love China1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"I love China2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"I love China3"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"I love China4"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"I love China5"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"I love China6"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"I love China7"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二、其它创建线程的手法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.1 用类对象创建线程</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span>&amp; m_i;</span><br><span class="line">	TA(<span class="keyword">int</span>&amp; i) :m_i(i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"TA()构造函数被执行"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	TA(<span class="keyword">const</span> TA&amp; ta) :m_i(ta.m_i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"TA()拷贝构造函数被执行"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	~TA()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"~TA()析构函数被执行"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"我的线程operator()开始执行"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"我的线程operator()执行结束"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> myi = <span class="number">6</span>;</span><br><span class="line">	<span class="function">TA <span class="title">ta</span><span class="params">(myi)</span></span>;</span><br><span class="line">	<span class="comment">//注意使用detach时，ta是复制到子线程中的，所以即使主线程销毁，</span></span><br><span class="line">	<span class="comment">//子线程中的ta也不会销毁，不会影响子线程的执行</span></span><br><span class="line">	<span class="function">thread <span class="title">myobj</span><span class="params">(ta)</span></span>;</span><br><span class="line">    <span class="comment">//thread myobj(std::ref(ta));//传入真引用时，下面就不能用detach()了</span></span><br><span class="line">	myobj.join();</span><br><span class="line">	<span class="comment">// 注意使用detach时，传入ta的参数不能是指向主线程中变量的引用或者指针，</span></span><br><span class="line">	<span class="comment">// 因为主线程先执行完时，引用和指针指向的变量就销毁了</span></span><br><span class="line">	<span class="comment">// 所以容易造成错误</span></span><br><span class="line">	<span class="comment">//myobj.detach();</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"I love China"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.2 用lambda表达式创建线程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> mylamthrad = [] &#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"我的线程mylamthrad()开始执行"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"我的线程mylamthrad()执行结束"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">thread <span class="title">myobj</span><span class="params">(mylamthrad)</span></span>;</span><br><span class="line">	<span class="comment">//myobj.join();</span></span><br><span class="line">	myobj.<span class="built_in">detach</span>();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"I love China"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="线程传参详解"><a href="#线程传参详解" class="headerlink" title="线程传参详解"></a>线程传参详解</h4><blockquote>
<p>参数传递容易出问题的主原因是：<strong>detach()函数</strong>。 因为detach()使得子线程有可能在主线程之后执行，而主线程销毁后，子线程中还有引用或指针指向主线程中的变量，此时就会出现问题</p>
</blockquote>
<h5 id="引用和指针做参数"><a href="#引用和指针做参数" class="headerlink" title="引用和指针做参数"></a>引用和指针做参数</h5><ul>
<li>引用： 虽然是引用，但是其实还是值传递（子线程会拷贝引用指向的内容），主线程的销毁不影响子线程（不推荐使用）</li>
<li>指针：指向主线程的地址，主线程的销毁影响子线程 （不能使用指针做线程参数）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myprint</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;i, <span class="keyword">char</span> *pmybuf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"子线程"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//此时的引用i并不是指向主线程的中的mvar，而是值传递过来的，即使主线程执行结束，也不影响子线程的执行</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pmybuf &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//此时指针pmybuf指向主线程中的mybuf, 主线程销毁则会影响子线程</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mvar = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>&amp; mvary = mvar;</span><br><span class="line">    <span class="keyword">char</span> mybuf[] = <span class="string">"this is a test!"</span>;</span><br><span class="line">    <span class="function">thread <span class="title">mytobj</span><span class="params">(myprint, mvar, mybuf)</span></span>;</span><br><span class="line">    <span class="comment">//mytobj.join();</span></span><br><span class="line">    mytobj.<span class="built_in">detach</span>();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"I love China!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="临时对象做参数"><a href="#临时对象做参数" class="headerlink" title="临时对象做参数"></a>临时对象做参数</h5><ul>
<li>值类型传参，直接用值传递，不用引用</li>
<li>对象作为参数传递，不要用指针，而是用对象传递，而且有隐式类型转换时，在传递时要<strong>先构造临时对象</strong><ul>
<li>如果直接传入对象，可能在主线程销毁前，对象还没有传入子线程完成构造</li>
<li>先构造临时对象再传入线程，则可以保证在主线程销毁前，对象已经传入子线程<ul>
<li>子线程通过引用接临时对象，如果不用引用则会多拷贝一次，浪费资源</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myprint</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i, <span class="keyword">const</span> <span class="built_in">string</span> &amp;pmybuf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"子线程"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//此时的引用i并不是指向主线程的中的mvar，而是值传递过来的，即使主线程执行结束，也不影响子线程的执行</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pmybuf &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//此时指针pmybuf指向主线程中的mybuf, 主线程销毁则会影响子线程</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mvar = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>&amp; mvary = mvar;</span><br><span class="line">    <span class="keyword">char</span> mybuf[] = <span class="string">"this is a test!"</span>;</span><br><span class="line">    <span class="comment">//string(mybuf): 在传递参数时构造临时对象, 这样可以确保，在主函数销毁前，就完成了临时对象的构造</span></span><br><span class="line">    <span class="function">thread <span class="title">mytobj</span><span class="params">(myprint, mvar, <span class="built_in">string</span>(mybuf))</span></span>;<span class="comment">//char转成string属于隐式类型转换</span></span><br><span class="line">    <span class="comment">//mytobj.join();</span></span><br><span class="line">    mytobj.<span class="built_in">detach</span>();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"I love China!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="对象做参数"><a href="#对象做参数" class="headerlink" title="对象做参数"></a>对象做参数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">int</span> m_i;<span class="comment">// const A &amp;pmybuf 因为引用是const的，所以在这里要设置为可修改</span></span><br><span class="line">    A(<span class="keyword">int</span> a) :m_i(a) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"[A::A(int a)构造函数执行]"</span> &lt;&lt;<span class="string">"thread id:"</span>&lt;&lt;<span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    A(<span class="keyword">const</span> A &amp;a) :m_i(a.m_i) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"[A::A(const A)拷贝构造函数执行]"</span> &lt;&lt; <span class="string">"thread id:"</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    ~A()&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"[A::~A()析构函数执行]"</span> &lt;&lt; <span class="string">"thread id:"</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myprint</span><span class="params">(<span class="keyword">const</span> A &amp;pmybuf)</span><span class="comment">//注意接受要是引用，避免多次拷贝</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">//虽然此处pmybuf是引用，但是它并不指向主线中的对象，而是从主线程拷贝到子线程中的对象</span></span><br><span class="line">    pmybuf.m_i = <span class="number">199</span>;<span class="comment">//所以此处的修改，并不会影响主线的数据，不会有联动的效果</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"子线程id:"</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">myobj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="comment">//传递对象作为线程参数</span></span><br><span class="line">    <span class="function">thread <span class="title">mytobj</span><span class="params">(myprint, myobj)</span></span>;</span><br><span class="line">    mytobj.join();</span><br><span class="line">    <span class="comment">//mytobj.detach();</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"I love China!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="std-ref"><a href="#std-ref" class="headerlink" title="std::ref()"></a>std::ref()</h6><ul>
<li>不用std::ref()时，对象作为参数传入线程时，虽然是用引用接受对象，但是这个引用并不是真正的引用，通过这个引用在子线程中修改数据后，主线程并不会随之修改，所以并没有真正体现引用的作用</li>
<li>使用std::ref()后，可以使得子线程中的引用是指向主线程中的对象，是真正的引用，在子线程或主线程修改数据后可以实现联动。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_i;<span class="comment">// 可以去掉mutable</span></span><br><span class="line">    A(<span class="keyword">int</span> a) :m_i(a) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"[A::A(int a)构造函数执行]"</span> &lt;&lt;<span class="string">"thread id:"</span>&lt;&lt;<span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    A(<span class="keyword">const</span> A &amp;a) :m_i(a.m_i) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"[A::A(const A)拷贝构造函数执行]"</span> &lt;&lt; <span class="string">"thread id:"</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    ~A()&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"[A::~A()析构函数执行]"</span> &lt;&lt; <span class="string">"thread id:"</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myprint</span><span class="params">( A &amp;pmybuf)</span><span class="comment">//可以去掉const</span></span></span><br><span class="line"><span class="function"></span>&#123;    pmybuf.m_i = <span class="number">199</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"子线程id:"</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">myobj</span><span class="params">(<span class="number">10</span>)</span></span>;<span class="comment">//子线程修改为199后，这里也会修改为199</span></span><br><span class="line">    <span class="function">thread <span class="title">mytobj</span><span class="params">(myprint, <span class="built_in">std</span>::ref(myobj))</span></span>;<span class="comment">//使用std::ref</span></span><br><span class="line">    mytobj.join();</span><br><span class="line">    <span class="comment">//mytobj.detach();</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"I love China!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="智能指针做参数"><a href="#智能指针做参数" class="headerlink" title="智能指针做参数"></a>智能指针做参数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myprint</span><span class="params">(<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; pzn)</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">//pzn和myp指向同一片地址</span></span><br><span class="line">    <span class="comment">//所以主线程销毁，pzn指向的地址就回收了，就会出问题</span></span><br><span class="line">    <span class="comment">//所以在使用智能指针作为线程参数时，不能使用detach()</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">myp</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">100</span>))</span></span>;<span class="comment">//创建整型独占是指针</span></span><br><span class="line">    <span class="function">thread <span class="title">mytobj</span><span class="params">(myprint, <span class="built_in">std</span>::<span class="built_in">move</span>(myp))</span></span>;</span><br><span class="line">    mytobj.join();</span><br><span class="line">    <span class="comment">//mytobj.detach();//不能用detach</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"I love China!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="成员函数做线程函数"><a href="#成员函数做线程函数" class="headerlink" title="成员函数做线程函数"></a>成员函数做线程函数</h5><ul>
<li>使用</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//thread mytobj(&amp;类名::成员函数名,实例对象, 成员函数参数);</span></span><br><span class="line"><span class="function">thread <span class="title">mytobj</span><span class="params">(&amp;A::thread_work,myobj, <span class="number">15</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>案例</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_i;<span class="comment">// 可以去掉mutable</span></span><br><span class="line">    A(<span class="keyword">int</span> a) :m_i(a) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"[A::A(int a)构造函数执行]"</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">" thread id:"</span>&lt;&lt;<span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    A(<span class="keyword">const</span> A &amp;a) :m_i(a.m_i) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"[A::A(const A)拷贝构造函数执行]"</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">" thread id:"</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    ~A()&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"[A::~A()析构函数执行]"</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">" thread id:"</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">thread_work</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"子线程thread_work执行"</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">" thread id:"</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="function">A <span class="title">myobj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="comment">//thread mytobj(&amp;类名::成员函数名,实例对象, 成员函数参数);</span></span><br><span class="line">    <span class="function">thread <span class="title">mytobj</span><span class="params">(&amp;A::thread_work,myobj, <span class="number">15</span>)</span></span>;</span><br><span class="line">    mytobj.join();</span><br><span class="line">    <span class="comment">//mytobj.detach();//此时传入的myobj会调用拷贝构造函数，即子线程会构造一个属于自己的对象，所以此时可以用detach</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"I love China!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不能用detach（）的情况<ul>
<li>使用了std::ref()，则子线程不会拷贝对象，而是使用主线程的对象，所以主线程销毁则不能正常访问了</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="function">A <span class="title">myobj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">mytobj</span><span class="params">(&amp;A::thread_work, &amp;myobj, <span class="number">15</span>)</span></span>;<span class="comment">//&amp;myobj 等价于 std::ref(myobj)</span></span><br><span class="line">    mytobj.join();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"I love China!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h3><h4 id="创建多个线程"><a href="#创建多个线程" class="headerlink" title="创建多个线程"></a>创建多个线程</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程入口函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myprint</span><span class="params">(<span class="keyword">int</span> inum)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"myprint线程开始执行了，线程编号="</span> &lt;&lt; inum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">//线程执行的具体任务</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"myprint线程执行结束了，线程编号="</span> &lt;&lt; inum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 1 创建并等待多个线程</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;thread&gt; ts;</span><br><span class="line">	<span class="comment">// 创建10个线程</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		ts.push_back(thread(myprint, i));<span class="comment">//创建10个线程，并开始执行</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 等待10个线程都执行完</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> it = ts.<span class="built_in">begin</span>(); it != ts.<span class="built_in">end</span>(); it++) &#123;  <span class="comment">//it是一个指向数组元素的指针</span></span><br><span class="line">		it-&gt;join();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"主线程结束"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数据共享问题"><a href="#数据共享问题" class="headerlink" title="数据共享问题"></a>数据共享问题</h4><h5 id="只读数据"><a href="#只读数据" class="headerlink" title="只读数据"></a>只读数据</h5><blockquote>
<p>安全稳定，直接读取即可</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g_v = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;<span class="comment">//全局共享数据  只读</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程入口函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myprint</span><span class="params">(<span class="keyword">int</span> inum)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; "myprint线程开始执行了，线程编号=" &lt;&lt; inum &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//线程执行的具体任务</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"线程id:"</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">"打印g_v的值："</span> &lt;&lt; g_v[<span class="number">0</span>] &lt;&lt; g_v[<span class="number">1</span>] &lt;&lt; g_v[<span class="number">2</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; "myprint线程执行结束了，线程编号=" &lt;&lt; inum &lt;&lt; endl;</span></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 1 创建并等待多个线程</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;thread&gt; ts;</span><br><span class="line">	<span class="comment">// 创建10个线程</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		ts.push_back(thread(myprint, i));<span class="comment">//创建10个线程，并开始执行</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 等待10个线程都执行完</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> it = ts.<span class="built_in">begin</span>(); it != ts.<span class="built_in">end</span>(); it++) &#123;  <span class="comment">//it是一个指向数组元素的指针</span></span><br><span class="line">		it-&gt;join();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"主线程结束"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="有读有写的数据"><a href="#有读有写的数据" class="headerlink" title="有读有写的数据"></a>有读有写的数据</h5><h4 id="共享代码的保护"><a href="#共享代码的保护" class="headerlink" title="共享代码的保护"></a>共享代码的保护</h4><blockquote>
<p>一下代码不能正常执行，因为涉及到同时读写队列q</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数做线程入口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//队列加入数据的线程</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">inQ</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"inQ执行，并在队列中加入一个元素："</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			q.push_back(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//取出数据的线程</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">outQ</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!q.empty()) &#123;</span><br><span class="line">				<span class="comment">//取元素</span></span><br><span class="line">				<span class="keyword">int</span> item = q.front();<span class="comment">//获取队列第一个元素</span></span><br><span class="line">				q.pop_front();<span class="comment">//移除队列第一个元素</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"outQ执行，队列为空"</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	A myA;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//myA.inQ();</span></span><br><span class="line">	myA.outQ();</span><br><span class="line">	<span class="comment">//创建向队列添加数据的线程</span></span><br><span class="line">	<span class="comment">//thread tIn(&amp;A::inQ, &amp;myA);</span></span><br><span class="line">	<span class="comment">//创建从队列读取数据的线程</span></span><br><span class="line">	<span class="comment">//thread tOut(&amp;A::outQ, &amp;myA);//创建线程并执行 </span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//tOut.join();</span></span><br><span class="line">	<span class="comment">//tIn.join();//等待子线程完成</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"主线程结束"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="互斥量、锁"><a href="#互斥量、锁" class="headerlink" title="互斥量、锁"></a>互斥量、锁</h4><h5 id="互斥量的使用"><a href="#互斥量的使用" class="headerlink" title="互斥量的使用"></a>互斥量的使用</h5><blockquote>
<p>#include <mutex> //互斥量的引入</mutex></p>
<p>mutex my_mutex;//创建一个互斥量</p>
<p>lock() //加锁</p>
<p>unlock()//解锁</p>
<p>std: : lock guard类模板 //取代lock()和unlock()， </p>
</blockquote>
<h6 id="lock-和unlock-使用"><a href="#lock-和unlock-使用" class="headerlink" title="lock() 和unlock()使用"></a>lock() 和unlock()使用</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt; //互斥量的引入</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数做线程入口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//队列加入数据的线程</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">inQ</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"inQ执行，并在队列中加入一个元素："</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			my_mutex.lock();</span><br><span class="line">			q.push_back(i);</span><br><span class="line">			my_mutex.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//取出数据线程的加锁代码</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(<span class="keyword">int</span>&amp; item)</span> </span>&#123;</span><br><span class="line">		my_mutex.lock();</span><br><span class="line">		<span class="keyword">if</span> (!q.empty()) &#123;</span><br><span class="line">			<span class="comment">//取元素</span></span><br><span class="line">			item = q.front();<span class="comment">//获取队列第一个元素</span></span><br><span class="line">			q.pop_front();<span class="comment">//移除队列第一个元素</span></span><br><span class="line">			my_mutex.unlock();</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		my_mutex.unlock();</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//取出数据的线程</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">outQ</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> item = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">bool</span> res = isEmpty(item);</span><br><span class="line">			<span class="keyword">if</span> (res == <span class="literal">true</span>) &#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"outQ执行，取出一个数据"</span> &lt;&lt; item &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"outQ执行，队列为空"</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">	mutex my_mutex;<span class="comment">//创建一个互斥量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	A myA;</span><br><span class="line">	<span class="comment">//创建向队列添加数据的线程</span></span><br><span class="line">	<span class="function">thread <span class="title">tIn</span><span class="params">(&amp;A::inQ, &amp;myA)</span></span>;</span><br><span class="line">	<span class="comment">//创建从队列读取数据的线程</span></span><br><span class="line">	<span class="function">thread <span class="title">tOut</span><span class="params">(&amp;A::outQ, &amp;myA)</span></span>;<span class="comment">//创建线程并执行 </span></span><br><span class="line"></span><br><span class="line">	tOut.join();</span><br><span class="line">	tIn.join();<span class="comment">//等待子线程完成</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"主线程结束"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="std-lock-guard类模板使用"><a href="#std-lock-guard类模板使用" class="headerlink" title="std: : lock guard类模板使用"></a>std: : lock guard类模板使用</h6><blockquote>
<p>lock_guard原理：</p>
<ul>
<li>lock_guard构造函数里执行了mutex::lock()</li>
<li>lock _guard析构函数里执行了mutext::unlock();</li>
</ul>
</blockquote>
<ul>
<li>用<code>{}</code>控制lock_guard的退出（执行析构函数）,以保证最小单元的上锁</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt; //互斥量的引入</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数做线程入口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//队列加入数据的线程</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">inQ</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"inQ执行，并在队列中加入一个元素："</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="function">lock_guard&lt;mutex&gt; <span class="title">sbguard</span><span class="params">(my_mutex)</span></span>; <span class="comment">//lock_guard类模板的使用</span></span><br><span class="line">				<span class="comment">//my_mutex.lock();</span></span><br><span class="line">				q.push_back(i);</span><br><span class="line">				<span class="comment">//my_mutex.unlock();</span></span><br><span class="line">			&#125;</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//取出数据线程的加锁代码</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(<span class="keyword">int</span>&amp; item)</span> </span>&#123;</span><br><span class="line">		<span class="function">lock_guard&lt;mutex&gt; <span class="title">sbguard</span><span class="params">(my_mutex)</span></span>; <span class="comment">//lock_guard类模板的使用</span></span><br><span class="line">		<span class="comment">//lock_guard构造函数里执行了mutex::lock()</span></span><br><span class="line">		<span class="comment">//lock _guard析构函数里执行了mutext::unlock();  本函数退出是则会调用</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//my_mutex.lock();</span></span><br><span class="line">		<span class="keyword">if</span> (!q.empty()) &#123;</span><br><span class="line">			<span class="comment">//取元素</span></span><br><span class="line">			item = q.front();<span class="comment">//获取队列第一个元素</span></span><br><span class="line">			q.pop_front();<span class="comment">//移除队列第一个元素</span></span><br><span class="line">			<span class="comment">//my_mutex.unlock();</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//my_mutex.unlock();</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//取出数据的线程</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">outQ</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> item = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">bool</span> res = isEmpty(item);</span><br><span class="line">			<span class="keyword">if</span> (res == <span class="literal">true</span>) &#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"outQ执行，取出一个数据"</span> &lt;&lt; item &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"outQ执行，队列为空"</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">	mutex my_mutex;<span class="comment">//创建一个互斥量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	A myA;</span><br><span class="line">	<span class="comment">//创建向队列添加数据的线程</span></span><br><span class="line">	<span class="function">thread <span class="title">tIn</span><span class="params">(&amp;A::inQ, &amp;myA)</span></span>;</span><br><span class="line">	<span class="comment">//创建从队列读取数据的线程</span></span><br><span class="line">	<span class="function">thread <span class="title">tOut</span><span class="params">(&amp;A::outQ, &amp;myA)</span></span>;<span class="comment">//创建线程并执行 </span></span><br><span class="line"></span><br><span class="line">	tOut.join();</span><br><span class="line">	tIn.join();<span class="comment">//等待子线程完成</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"主线程结束"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><h6 id="死锁-产生"><a href="#死锁-产生" class="headerlink" title="死锁 产生"></a>死锁 产生</h6><ul>
<li>两把锁在不同的线程中加锁的顺序相反则会触发死锁问题</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt; //互斥量的引入</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数做线程入口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//队列加入数据的线程</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">inQ</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"inQ执行，并在队列中加入一个元素："</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			&#123;</span><br><span class="line">				my_mutex1.lock();<span class="comment">//--------------------------------------加锁顺序正好与另一个线程顺序相反------------------------------</span></span><br><span class="line">				my_mutex2.lock();</span><br><span class="line"></span><br><span class="line">				q.push_back(i);</span><br><span class="line">				my_mutex1.unlock();</span><br><span class="line">				my_mutex2.unlock();</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//取出数据线程的加锁代码</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(<span class="keyword">int</span>&amp; item)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//lock_guard&lt;mutex&gt; sbguard(my_mutex); //lock_guard类模板的使用</span></span><br><span class="line">		<span class="comment">//lock_guard构造函数里执行了mutex::lock()</span></span><br><span class="line">		<span class="comment">//lock _guard析构函数里执行了mutext::unlock();  本函数退出是则会调用</span></span><br><span class="line"></span><br><span class="line">		my_mutex2.lock(); <span class="comment">//--------------------------------------加锁顺序正好与另一个线程顺序相反---------------------------------</span></span><br><span class="line">		my_mutex1.lock();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!q.empty()) &#123;</span><br><span class="line">			<span class="comment">//取元素</span></span><br><span class="line">			item = q.front();<span class="comment">//获取队列第一个元素</span></span><br><span class="line">			q.pop_front();<span class="comment">//移除队列第一个元素</span></span><br><span class="line">			my_mutex2.unlock();</span><br><span class="line">			my_mutex1.unlock();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		my_mutex1.unlock();</span><br><span class="line">		my_mutex2.unlock();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//取出数据的线程</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">outQ</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> item = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">bool</span> res = isEmpty(item);</span><br><span class="line">			<span class="keyword">if</span> (res == <span class="literal">true</span>) &#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"outQ执行，取出一个数据"</span> &lt;&lt; item &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"outQ执行，队列为空"</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">	mutex my_mutex1;<span class="comment">//创建一个互斥量 锁1</span></span><br><span class="line">	mutex my_mutex2;<span class="comment">//创建一个互斥量 锁2</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	A myA;</span><br><span class="line">	<span class="comment">//创建向队列添加数据的线程</span></span><br><span class="line">	<span class="function">thread <span class="title">tIn</span><span class="params">(&amp;A::inQ, &amp;myA)</span></span>;</span><br><span class="line">	<span class="comment">//创建从队列读取数据的线程</span></span><br><span class="line">	<span class="function">thread <span class="title">tOut</span><span class="params">(&amp;A::outQ, &amp;myA)</span></span>;<span class="comment">//创建线程并执行 </span></span><br><span class="line"></span><br><span class="line">	tOut.join();</span><br><span class="line">	tIn.join();<span class="comment">//等待子线程完成</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"主线程结束"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="死锁解决方案"><a href="#死锁解决方案" class="headerlink" title="死锁解决方案"></a>死锁解决方案</h6><ul>
<li>两把锁在不同的线程中加锁顺序相同，则可以避免死锁</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt; //互斥量的引入</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数做线程入口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//队列加入数据的线程</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">inQ</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"inQ执行，并在队列中加入一个元素："</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			&#123;</span><br><span class="line">				my_mutex1.lock();<span class="comment">//--------------------------------------加锁顺序正好与另一个线程顺序相同------------------------------</span></span><br><span class="line">				my_mutex2.lock();</span><br><span class="line"></span><br><span class="line">				q.push_back(i);</span><br><span class="line">				my_mutex1.unlock();</span><br><span class="line">				my_mutex2.unlock();</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//取出数据线程的加锁代码</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(<span class="keyword">int</span>&amp; item)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//lock_guard&lt;mutex&gt; sbguard(my_mutex); //lock_guard类模板的使用</span></span><br><span class="line">		<span class="comment">//lock_guard构造函数里执行了mutex::lock()</span></span><br><span class="line">		<span class="comment">//lock _guard析构函数里执行了mutext::unlock();  本函数退出是则会调用</span></span><br><span class="line"></span><br><span class="line">		my_mutex1.lock(); <span class="comment">//--------------------------------------加锁顺序正好与另一个线程顺序相同---------------------------------</span></span><br><span class="line">		my_mutex2.lock();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!q.empty()) &#123;</span><br><span class="line">			<span class="comment">//取元素</span></span><br><span class="line">			item = q.front();<span class="comment">//获取队列第一个元素</span></span><br><span class="line">			q.pop_front();<span class="comment">//移除队列第一个元素</span></span><br><span class="line">			my_mutex2.unlock();</span><br><span class="line">			my_mutex1.unlock();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		my_mutex1.unlock();</span><br><span class="line">		my_mutex2.unlock();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//取出数据的线程</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">outQ</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> item = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">bool</span> res = isEmpty(item);</span><br><span class="line">			<span class="keyword">if</span> (res == <span class="literal">true</span>) &#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"outQ执行，取出一个数据"</span> &lt;&lt; item &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"outQ执行，队列为空"</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">	mutex my_mutex1;<span class="comment">//创建一个互斥量 锁1</span></span><br><span class="line">	mutex my_mutex2;<span class="comment">//创建一个互斥量 锁2</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	A myA;</span><br><span class="line">	<span class="comment">//创建向队列添加数据的线程</span></span><br><span class="line">	<span class="function">thread <span class="title">tIn</span><span class="params">(&amp;A::inQ, &amp;myA)</span></span>;</span><br><span class="line">	<span class="comment">//创建从队列读取数据的线程</span></span><br><span class="line">	<span class="function">thread <span class="title">tOut</span><span class="params">(&amp;A::outQ, &amp;myA)</span></span>;<span class="comment">//创建线程并执行 </span></span><br><span class="line"></span><br><span class="line">	tOut.join();</span><br><span class="line">	tIn.join();<span class="comment">//等待子线程完成</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"主线程结束"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>lock_guard加多把锁的方式</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt; //互斥量的引入</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数做线程入口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//队列加入数据的线程</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">inQ</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"inQ执行，并在队列中加入一个元素："</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="function">lock_guard&lt;mutex&gt; <span class="title">sbguard1</span><span class="params">(my_mutex1)</span></span>; <span class="comment">//lock_guard加锁1</span></span><br><span class="line">				<span class="function">lock_guard&lt;mutex&gt; <span class="title">sbguard2</span><span class="params">(my_mutex2)</span></span>; <span class="comment">//lock_guard加锁2</span></span><br><span class="line">				<span class="comment">//my_mutex1.lock();//加锁顺序正好与另一个线程顺序相反</span></span><br><span class="line">				<span class="comment">//my_mutex2.lock();</span></span><br><span class="line"></span><br><span class="line">				q.push_back(i);</span><br><span class="line">				<span class="comment">//my_mutex1.unlock();</span></span><br><span class="line">				<span class="comment">//my_mutex2.unlock();</span></span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//取出数据线程的加锁代码</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(<span class="keyword">int</span>&amp; item)</span> </span>&#123;</span><br><span class="line">		<span class="function">lock_guard&lt;mutex&gt; <span class="title">sbguard1</span><span class="params">(my_mutex1)</span></span>; <span class="comment">//lock_guard加锁1</span></span><br><span class="line">		<span class="function">lock_guard&lt;mutex&gt; <span class="title">sbguard2</span><span class="params">(my_mutex2)</span></span>; <span class="comment">//lock_guard加锁2</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//lock_guard构造函数里执行了mutex::lock()</span></span><br><span class="line">		<span class="comment">//lock _guard析构函数里执行了mutext::unlock();  本函数退出是则会调用</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//my_mutex2.lock(); //加锁顺序正好与另一个线程顺序相反</span></span><br><span class="line">		<span class="comment">//my_mutex1.lock();</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!q.empty()) &#123;</span><br><span class="line">			<span class="comment">//取元素</span></span><br><span class="line">			item = q.front();<span class="comment">//获取队列第一个元素</span></span><br><span class="line">			q.pop_front();<span class="comment">//移除队列第一个元素</span></span><br><span class="line">			<span class="comment">//my_mutex2.unlock();</span></span><br><span class="line">			<span class="comment">//my_mutex1.unlock();</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//my_mutex1.unlock();</span></span><br><span class="line">		<span class="comment">//my_mutex2.unlock();</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//取出数据的线程</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">outQ</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> item = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">bool</span> res = isEmpty(item);</span><br><span class="line">			<span class="keyword">if</span> (res == <span class="literal">true</span>) &#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"outQ执行，取出一个数据"</span> &lt;&lt; item &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"outQ执行，队列为空"</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">	mutex my_mutex1;<span class="comment">//创建一个互斥量 锁1</span></span><br><span class="line">	mutex my_mutex2;<span class="comment">//创建一个互斥量 锁2</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	A myA;</span><br><span class="line">	<span class="comment">//创建向队列添加数据的线程</span></span><br><span class="line">	<span class="function">thread <span class="title">tIn</span><span class="params">(&amp;A::inQ, &amp;myA)</span></span>;</span><br><span class="line">	<span class="comment">//创建从队列读取数据的线程</span></span><br><span class="line">	<span class="function">thread <span class="title">tOut</span><span class="params">(&amp;A::outQ, &amp;myA)</span></span>;<span class="comment">//创建线程并执行 </span></span><br><span class="line"></span><br><span class="line">	tOut.join();</span><br><span class="line">	tIn.join();<span class="comment">//等待子线程完成</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"主线程结束"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="std-lock-模板"><a href="#std-lock-模板" class="headerlink" title="std::lock()模板"></a>std::lock()模板</h6><blockquote>
<p>能力:一次锁住两个或者两个以上的互斥量（至少两个）</p>
<p>如果互斥量中有一个没锁柱，它就在那里等着，等所有互斥量都锁住，它才能往下走（返回)</p>
<p>要么两个互斥量都锁住，要么两个互斥量都没锁住</p>
<p>如果有一个锁住了，但另一个没有锁住，则会先释放已经锁住的那个，再寻求一次性锁住两个，这样就可以避免死锁</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt; //互斥量的引入</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数做线程入口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//队列加入数据的线程</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">inQ</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"inQ执行，并在队列中加入一个元素："</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            lock(my_mutex1, my_mutex2);  <span class="comment">//-----------相当于给每一个互斥量都加了.lock()--------注意还是要配合.unlock()使用-----</span></span><br><span class="line">            q.push_back(i);</span><br><span class="line">            my_mutex1.unlock();</span><br><span class="line">            my_mutex2.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//取出数据线程的加锁代码</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(<span class="keyword">int</span>&amp; item)</span> </span>&#123;</span><br><span class="line">		lock(my_mutex1, my_mutex2);<span class="comment">//-----------相当于给每一个互斥量都加了.lock()--------注意还是要配合.unlock()使用-----</span></span><br><span class="line">		<span class="keyword">if</span> (!q.empty()) &#123;</span><br><span class="line">			<span class="comment">//取元素</span></span><br><span class="line">			item = q.front();<span class="comment">//获取队列第一个元素</span></span><br><span class="line">			q.pop_front();<span class="comment">//移除队列第一个元素</span></span><br><span class="line">			my_mutex2.unlock();</span><br><span class="line">			my_mutex1.unlock();</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		my_mutex1.unlock();</span><br><span class="line">		my_mutex2.unlock();</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//取出数据的线程</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">outQ</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> item = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">bool</span> res = isEmpty(item);</span><br><span class="line">			<span class="keyword">if</span> (res == <span class="literal">true</span>) &#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"outQ执行，取出一个数据"</span> &lt;&lt; item &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"outQ执行，队列为空"</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">	mutex my_mutex1;<span class="comment">//创建一个互斥量 锁1</span></span><br><span class="line">	mutex my_mutex2;<span class="comment">//创建一个互斥量 锁2</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	A myA;</span><br><span class="line">	<span class="comment">//创建向队列添加数据的线程</span></span><br><span class="line">	<span class="function">thread <span class="title">tIn</span><span class="params">(&amp;A::inQ, &amp;myA)</span></span>;</span><br><span class="line">	<span class="comment">//创建从队列读取数据的线程</span></span><br><span class="line">	<span class="function">thread <span class="title">tOut</span><span class="params">(&amp;A::outQ, &amp;myA)</span></span>;<span class="comment">//创建线程并执行 </span></span><br><span class="line"></span><br><span class="line">	tOut.join();</span><br><span class="line">	tIn.join();<span class="comment">//等待子线程完成</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"主线程结束"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="lock-和lock-guard配合使用"><a href="#lock-和lock-guard配合使用" class="headerlink" title="lock()和lock_guard配合使用"></a>lock()和lock_guard配合使用</h6><blockquote>
<p>std::lock()使用有一个缺点是：还是必须配合unlock()使用</p>
<p>如果配合lock_guard就可以不用考虑unlock()了</p>
<p>adopt_lock相当于一个标识，告诉lock_guard在构造函数里不要执行lock(), 因为std::lock()里已经执行了一次lock()了</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt; //互斥量的引入</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数做线程入口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//队列加入数据的线程</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">inQ</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"inQ执行，并在队列中加入一个元素："</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            lock(my_mutex1, my_mutex2);</span><br><span class="line">            <span class="function">lock_guard&lt;mutex&gt; <span class="title">sbguard1</span><span class="params">(my_mutex1, adopt_lock)</span></span>; <span class="comment">//lock_guard加锁1</span></span><br><span class="line">            <span class="function">lock_guard&lt;mutex&gt; <span class="title">sbguard2</span><span class="params">(my_mutex2, adopt_lock)</span></span>; <span class="comment">//lock_guard加锁2</span></span><br><span class="line">            q.push_back(i);</span><br><span class="line">            <span class="comment">//my_mutex1.unlock();</span></span><br><span class="line">            <span class="comment">//my_mutex2.unlock();</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//取出数据线程的加锁代码</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(<span class="keyword">int</span>&amp; item)</span> </span>&#123;</span><br><span class="line">		lock(my_mutex1, my_mutex2);</span><br><span class="line">		<span class="function">lock_guard&lt;mutex&gt; <span class="title">sbguard1</span><span class="params">(my_mutex1,adopt_lock)</span></span>; <span class="comment">//lock_guard加锁1</span></span><br><span class="line">		<span class="function">lock_guard&lt;mutex&gt; <span class="title">sbguard2</span><span class="params">(my_mutex2,adopt_lock)</span></span>; <span class="comment">//lock_guard加锁2</span></span><br><span class="line">		<span class="keyword">if</span> (!q.empty()) &#123;</span><br><span class="line">			<span class="comment">//取元素</span></span><br><span class="line">			item = q.front();<span class="comment">//获取队列第一个元素</span></span><br><span class="line">			q.pop_front();<span class="comment">//移除队列第一个元素</span></span><br><span class="line">			<span class="comment">//my_mutex2.unlock();</span></span><br><span class="line">			<span class="comment">//my_mutex1.unlock();</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//my_mutex1.unlock();</span></span><br><span class="line">		<span class="comment">//my_mutex2.unlock();</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//取出数据的线程</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">outQ</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> item = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">bool</span> res = isEmpty(item);</span><br><span class="line">			<span class="keyword">if</span> (res == <span class="literal">true</span>) &#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"outQ执行，取出一个数据"</span> &lt;&lt; item &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"outQ执行，队列为空"</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">	mutex my_mutex1;<span class="comment">//创建一个互斥量 锁1</span></span><br><span class="line">	mutex my_mutex2;<span class="comment">//创建一个互斥量 锁2</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	A myA;</span><br><span class="line">	<span class="comment">//创建向队列添加数据的线程</span></span><br><span class="line">	<span class="function">thread <span class="title">tIn</span><span class="params">(&amp;A::inQ, &amp;myA)</span></span>;</span><br><span class="line">	<span class="comment">//创建从队列读取数据的线程</span></span><br><span class="line">	<span class="function">thread <span class="title">tOut</span><span class="params">(&amp;A::outQ, &amp;myA)</span></span>;<span class="comment">//创建线程并执行 </span></span><br><span class="line"></span><br><span class="line">	tOut.join();</span><br><span class="line">	tIn.join();<span class="comment">//等待子线程完成</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"主线程结束"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="unique-lock"><a href="#unique-lock" class="headerlink" title="unique_lock()"></a>unique_lock()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>) unique_ock取代lock_guard</span><br><span class="line">(<span class="number">2</span>) unique_ock的第二个参数</span><br><span class="line">	(<span class="number">2.1</span>) <span class="built_in">std</span>::adopt_lock</span><br><span class="line">    (<span class="number">2.2</span>) <span class="built_in">std</span>::tyr_to_lock</span><br><span class="line">    (<span class="number">2.3</span>) <span class="built_in">std</span>::defer_lock</span><br><span class="line">(<span class="number">3</span>) unique_lock的成员函数</span><br><span class="line">	(<span class="number">3.1</span>) lock()</span><br><span class="line">	(<span class="number">3.2</span>) unlock()</span><br><span class="line">    (<span class="number">3.3</span>) try_lock)</span><br><span class="line">    (<span class="number">3.4</span>) <span class="built_in">release</span>()</span><br><span class="line">(<span class="number">4</span>) unique_lock所有权的传递</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一: unique_lock取代lock_guard</span></span><br><span class="line"><span class="comment">//unique_lock是个类模板，工作中，一般lock_guard(推荐使用)﹔ lock_guard取代了mutex的lock 和unlock ();</span></span><br><span class="line"><span class="comment">//unique_lock比lock_guard灵活很多;效率上差一点，内存占用多一点。</span></span><br><span class="line"><span class="comment">//二:unique_lock的第二个参数</span></span><br><span class="line"><span class="comment">//lock_guard可以带第二个参数:</span></span><br><span class="line"><span class="comment">//std::lock_guard&lt;std::mutex〉 sbguard1(my_mutex1, std::adopt_lock):</span></span><br><span class="line"><span class="comment">//adopt_lock标记作用;</span></span><br><span class="line"><span class="comment">//(2.1) std::adopt_lock:表示这个互斥量已经被lock了(你必须要把互斥量提前lock了,否则会报异常)</span></span><br><span class="line"><span class="comment">//std::adopt_lock标记的效果就是“假设调用防线程已经拥有了互斥的所有权(已经lock()成功了）;</span></span><br><span class="line"><span class="comment">//通知lock_guard不需要在构造函数中lock这个互斥量了;</span></span><br><span class="line"><span class="comment">//unique_lock也可以带std; .adopt_lock标记，含义相同, 就是不希望再unique_lock()的构造函数中lock</span></span><br><span class="line"><span class="comment">//用这个adopt_lock的前提是，你需要自己先把mutex先lock上3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//(2.2）std::try_to_lock</span></span><br><span class="line"><span class="comment">//我们会尝试用mutex的lock()去锁定这个mutex，但如果没有锁定成动，也会立即返回，并不会阻塞在那里;</span></span><br><span class="line"><span class="comment">//用这个try_to_lock的前提是自己不能先去lock。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//(2.3）std::defer_lock</span></span><br><span class="line"><span class="comment">//用这个defer_lock的前提是你不能自己先lock，否则会报异常。</span></span><br><span class="line"><span class="comment">//defer_lock的意思就是并没有给mutext加锁:初始化了一个没有加锁的mutexo</span></span><br><span class="line"><span class="comment">//我们借着defer_lock的话题，来介绍一些unique_lock的重要成员函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 三:unique_lock的成员函数</span></span><br><span class="line"><span class="comment">// 以下成员函数都是配合std::defer_lock使用</span></span><br><span class="line"><span class="comment">//(3.1) lock()，加锁</span></span><br><span class="line"><span class="comment">//(3.2) unlock()，解锁</span></span><br><span class="line"><span class="comment">//(3.3) try lock()，尝试给互斥量加锁，如果拿不到锁，则返回false, 如果拿到了锁，返回true，这个函数不阻塞的; </span></span><br><span class="line"><span class="comment">//(3.4） release()，返回它所管理的mutex对象指针，并释放所有权;unique_lock和mutext不再有关系。</span></span><br><span class="line"><span class="comment">// 严格区分unlock()和release()的区别，不要混淆。</span></span><br><span class="line"><span class="comment">// 如果原来mutex对象处于加锁状态，你有责任接管过来并负责解锁。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//四、所有权转移</span></span><br><span class="line"><span class="comment">//实现转移的方式</span></span><br><span class="line"><span class="comment">//1 返回临时对象，调用unique_lock 移动构造函数</span></span><br><span class="line"><span class="comment">//2 使用move函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt; //互斥量的引入</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数做线程入口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">unique_lock&lt;mutex&gt; <span class="title">rtn_unique_lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="function">unique_lock&lt;mutex&gt; <span class="title">tmpGuard</span><span class="params">(my_mutex1)</span></span>;</span><br><span class="line">		<span class="keyword">return</span> tmpGuard; <span class="comment">// 返回临时对象，调用unique_lock 移动构造函数</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//队列加入数据的线程</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">inQ</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"inQ执行，并在队列中加入一个元素："</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 1 unique_lock第二个参数使用adopt_lock</span></span><br><span class="line">			<span class="comment">//my_mutex1.lock();</span></span><br><span class="line">			<span class="comment">//unique_lock&lt;mutex&gt; sbguard1(my_mutex1,adopt_lock); </span></span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 2 unique_lock第二个参数使用try_to_lock</span></span><br><span class="line">			<span class="comment">//unique_lock&lt;mutex&gt; sbguard1(my_mutex1, try_to_lock);</span></span><br><span class="line">			<span class="comment">//if (sbguard1.owns_lock()) &#123;</span></span><br><span class="line">				<span class="comment">//拿到了锁</span></span><br><span class="line">			<span class="comment">//	q.push_back(i);</span></span><br><span class="line">			<span class="comment">//&#125;</span></span><br><span class="line">			<span class="comment">//else &#123;</span></span><br><span class="line">				<span class="comment">//没有拿到锁</span></span><br><span class="line">			<span class="comment">//	cout &lt;&lt; "outQ延时20秒，所以在inQ中没有拿到锁，但是使用了try_to_lock，所以inQ的线程不会卡在这里"&lt;&lt;endl;</span></span><br><span class="line">			<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">// 3 unique_lock第三个参数使用defer_lock</span></span><br><span class="line">			<span class="comment">//unique_lock&lt;mutex&gt; sbguard1(my_mutex1, defer_lock); //没有加锁的my_mutex1</span></span><br><span class="line">			<span class="comment">// 3.1 unique_lock成员函数lock()和unlock()配合defer_lock使用</span></span><br><span class="line">			<span class="comment">//sbguard1.lock(); //给my_mutex1加锁</span></span><br><span class="line">			<span class="comment">//处理共享代码</span></span><br><span class="line">			<span class="comment">//sbguard1.unlock(); //意义就是能够便捷的控制解锁，使共享代码和非共享代码可以便捷的交替执行</span></span><br><span class="line">			<span class="comment">//处理非共享代码</span></span><br><span class="line">			<span class="comment">//sbguard1.lock();</span></span><br><span class="line">			<span class="comment">//处理共享代码</span></span><br><span class="line">			<span class="comment">//3.2 unique_lock成员函数try_lock配合defer_lock使用</span></span><br><span class="line">			<span class="comment">//if (sbguard1.try_lock() == true) &#123; //try_lock尝试上锁</span></span><br><span class="line">			<span class="comment">//	q.push_back(i);</span></span><br><span class="line">			<span class="comment">//&#125;</span></span><br><span class="line">			<span class="comment">//else &#123;</span></span><br><span class="line">			<span class="comment">//	cout &lt;&lt; "outQ延时20秒，所以在inQ中没有拿到锁，但是使用了try_to_lock，所以inQ的线程不会卡在这里" &lt;&lt; endl;</span></span><br><span class="line">			<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//4 unique_lock成员函数release()的使用</span></span><br><span class="line">			<span class="comment">//unique_lock&lt;mutex&gt; sbguard1(my_mutex1); //my_mutex1已经加锁</span></span><br><span class="line">			<span class="comment">//mutex *ptx = sbguard1.release(); //指针指向my_mutex1， 此时unique_lock已经和my_mutex1没有关系</span></span><br><span class="line">			<span class="comment">//q.push_back(i);</span></span><br><span class="line">			<span class="comment">//ptx-&gt;unlock();//注意一定要在这里unlock 否则会报错 因为上面已经lock()了</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//5 所有权移动</span></span><br><span class="line">			 <span class="comment">// 移动语义 这个时候就直接把所有权转移到了sbGuard2了</span></span><br><span class="line">			<span class="comment">//方式1</span></span><br><span class="line">			<span class="comment">//unique_lock&lt;mutex&gt; sbguard1(my_mutex1);</span></span><br><span class="line">	        <span class="comment">//unique_lock&lt;mutex&gt; sbGuard2(move(sbguard1));</span></span><br><span class="line">			<span class="comment">//方式2</span></span><br><span class="line">			<span class="comment">//也可以通过返回</span></span><br><span class="line">			unique_lock&lt;mutex&gt; sbGuard2 = rtn_unique_lock();</span><br><span class="line">			q.push_back(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//取出数据线程的加锁代码</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(<span class="keyword">int</span>&amp; item)</span> </span>&#123;</span><br><span class="line">		<span class="function">unique_lock&lt;mutex&gt; <span class="title">sbguard1</span><span class="params">(my_mutex1)</span></span>; <span class="comment">//unique_lock的使用</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//使线程在这里延时20秒</span></span><br><span class="line">		<span class="comment">//std::chrono::milliseconds dura(20000);//1秒= 1000毫秒，所以20000毫秒=20秒</span></span><br><span class="line">		<span class="comment">//std::this_thread::sleep_for(dura) ; //休息一定的时长</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!q.empty()) &#123;</span><br><span class="line">			<span class="comment">//取元素</span></span><br><span class="line">			item = q.front();<span class="comment">//获取队列第一个元素</span></span><br><span class="line">			q.pop_front();<span class="comment">//移除队列第一个元素</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//取出数据的线程</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">outQ</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> item = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">bool</span> res = isEmpty(item);</span><br><span class="line">			<span class="keyword">if</span> (res == <span class="literal">true</span>) &#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"outQ执行，取出一个数据"</span> &lt;&lt; item &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"outQ执行，队列为空"</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">	mutex my_mutex1;<span class="comment">//创建一个互斥量 锁1</span></span><br><span class="line">	mutex my_mutex2;<span class="comment">//创建一个互斥量 锁2</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	A myA;</span><br><span class="line">	<span class="comment">//创建向队列添加数据的线程</span></span><br><span class="line">	<span class="function">thread <span class="title">tIn</span><span class="params">(&amp;A::inQ, &amp;myA)</span></span>;</span><br><span class="line">	<span class="comment">//创建从队列读取数据的线程</span></span><br><span class="line">	<span class="function">thread <span class="title">tOut</span><span class="params">(&amp;A::outQ, &amp;myA)</span></span>;<span class="comment">//创建线程并执行 </span></span><br><span class="line"></span><br><span class="line">	tOut.join();</span><br><span class="line">	tIn.join();<span class="comment">//等待子线程完成</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"主线程结束"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><h3 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h3><blockquote>
<p>c++11新特性  匿名函数</p>
<p><a href="https://www.bilibili.com/video/BV1CC4y187Km?from=search&seid=3858185157690700367&spm_id_from=333.337.0.0" target="_blank" rel="noopener">Lambda视频教程</a></p>
</blockquote>
<h3 id="calloc-与-malloc"><a href="#calloc-与-malloc" class="headerlink" title="calloc() 与 malloc()"></a>calloc() 与 <a href="http://c.biancheng.net/cpp/html/137.html" target="_blank" rel="noopener">malloc()</a></h3><blockquote>
<p><a href="http://c.biancheng.net/cpp/html/134.html" target="_blank" rel="noopener">http://c.biancheng.net/cpp/html/134.html</a></p>
</blockquote>
<h3 id="assert"><a href="#assert" class="headerlink" title="assert()"></a>assert()</h3><blockquote>
<p><a href="http://c.biancheng.net/ref/assert.html" target="_blank" rel="noopener">http://c.biancheng.net/ref/assert.html</a></p>
</blockquote>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/05/24/third-repositories/bootstrap/bootstrap/" rel="prev" title="bootstrap学习笔记">
      <i class="fa fa-chevron-left"></i> bootstrap学习笔记
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/07/21/Index/%E9%9D%A2%E8%AF%95%E5%86%85%E5%AE%B9%E6%A2%B3%E7%90%86/" rel="next" title="前端面试内容梳理">
      前端面试内容梳理 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#C"><span class="nav-text">C++</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基础知识点"><span class="nav-text">基础知识点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#编译、链接的过程"><span class="nav-text">编译、链接的过程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#pragma-once"><span class="nav-text">#pragma once</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#宏定义"><span class="nav-text">宏定义</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据类型"><span class="nav-text">数据类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#安装IDE"><span class="nav-text">安装IDE</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vs2019快捷键"><span class="nav-text">vs2019快捷键</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#gcc与g-区别"><span class="nav-text">gcc与g++区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#void"><span class="nav-text">void*</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#库函数"><span class="nav-text">库函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#std"><span class="nav-text">std</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#swap"><span class="nav-text">swap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#copy"><span class="nav-text">copy</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#srand-rand"><span class="nav-text">srand()  rand()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基础容器"><span class="nav-text">基础容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数组"><span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#动态数组vector"><span class="nav-text">动态数组vector</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串"><span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#c中的字符串"><span class="nav-text">c中的字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#字符串的指针"><span class="nav-text">字符串的指针</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#lt-string-h-gt-API"><span class="nav-text">&lt;string.h&gt;API</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#c-中字符串"><span class="nav-text">c++中字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符数组与数组"><span class="nav-text">字符数组与数组</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指针"><span class="nav-text">指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#嵌入式指针"><span class="nav-text">嵌入式指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常见指针"><span class="nav-text">常见指针</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数组指针与指针数组"><span class="nav-text">数组指针与指针数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cosnt与指针"><span class="nav-text">cosnt与指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#指向指针的指针"><span class="nav-text">指向指针的指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#易错指针"><span class="nav-text">易错指针</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指针的基本运算"><span class="nav-text">指针的基本运算</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#与–操作符"><span class="nav-text">++与–操作符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#存储区划分"><span class="nav-text">存储区划分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#智能指针"><span class="nav-text">智能指针</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#auto-ptr"><span class="nav-text">auto_ptr</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#unique-ptr"><span class="nav-text">unique_ptr</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#shared-ptr"><span class="nav-text">shared_ptr</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#weak-ptr"><span class="nav-text">weak_ptr</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#引用"><span class="nav-text">引用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面向对象"><span class="nav-text">面向对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多线程"><span class="nav-text">多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本概念"><span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本使用"><span class="nav-text">基本使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#c-11多线程API"><span class="nav-text">c++11多线程API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程传参详解"><span class="nav-text">线程传参详解</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#引用和指针做参数"><span class="nav-text">引用和指针做参数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#临时对象做参数"><span class="nav-text">临时对象做参数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#对象做参数"><span class="nav-text">对象做参数</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#std-ref"><span class="nav-text">std::ref()</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#智能指针做参数"><span class="nav-text">智能指针做参数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#成员函数做线程函数"><span class="nav-text">成员函数做线程函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实际使用"><span class="nav-text">实际使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#创建多个线程"><span class="nav-text">创建多个线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据共享问题"><span class="nav-text">数据共享问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#只读数据"><span class="nav-text">只读数据</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#有读有写的数据"><span class="nav-text">有读有写的数据</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#共享代码的保护"><span class="nav-text">共享代码的保护</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#互斥量、锁"><span class="nav-text">互斥量、锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#互斥量的使用"><span class="nav-text">互斥量的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#lock-和unlock-使用"><span class="nav-text">lock() 和unlock()使用</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#std-lock-guard类模板使用"><span class="nav-text">std: : lock guard类模板使用</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#死锁"><span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#死锁-产生"><span class="nav-text">死锁 产生</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#死锁解决方案"><span class="nav-text">死锁解决方案</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#std-lock-模板"><span class="nav-text">std::lock()模板</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#lock-和lock-guard配合使用"><span class="nav-text">lock()和lock_guard配合使用</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#unique-lock"><span class="nav-text">unique_lock()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#特性"><span class="nav-text">特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Lambda"><span class="nav-text">Lambda</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#calloc-与-malloc"><span class="nav-text">calloc() 与 malloc()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#assert"><span class="nav-text">assert()</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Chuckie"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Chuckie</p>
  <div class="site-description" itemprop="description">Bright future</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">116</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">57</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">100</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/ChuckieWill" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ChuckieWill" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/codewyj.163.com" title="E-Mail → codewyj.163.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.jianshu.com/u/de627226656c" title="https:&#x2F;&#x2F;www.jianshu.com&#x2F;u&#x2F;de627226656c" rel="noopener" target="_blank">简书</a>
        </li>
    </ul>
  </div>

      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="/images/me.png"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chuckie</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">1.1m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">17:04</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
