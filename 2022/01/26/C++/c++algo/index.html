<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="一排序算法">
<meta property="og:type" content="article">
<meta property="og:title" content="C++algorithm">
<meta property="og:url" content="http://yoursite.com/2022/01/26/C++/c++algo/index.html">
<meta property="og:site_name" content="Chuckie&#39;s Blog">
<meta property="og:description" content="一排序算法">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/c++algo/202202192210160.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/c++algo/202202192216456.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/c++algo/202202192253159.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/c++algo/202202192257525.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/c++algo/image-20220901160350831.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/c++algo/image-20220901160443789.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/c++algo/202202202158199.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/c++algo/202202202107515.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/c++algo/202202212148699.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/c++algo/202202202057660.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/c++algo/202202202052061.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/c++algo/202202222147102.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/c++algo/202202232316544.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/c++algo/202202241632360.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/c++algo/202202241635774.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/c++algo/202202241639380.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/c++algo/202202241954265.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/c++algo/202202242138929.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/c++algo/202202242201960.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/c++algo/202202251258467.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/c++algo/202202251302297.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/c++algo/202202282226104.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/c++algo/202202281916752.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/c++algo/202202282232078.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/c++algo/image-20220922202627813.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/c++algo/202203012026674.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/c++algo/202203012214278.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/c++algo/202203032049395.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/c++algo/202203072251192.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/c++algo/202203092259286.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/c++algo/202203102222665.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/c++algo/202203102336420.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/c++algo/image-20221205210745076.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/c++algo/image-20221206191856660.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/c++algo/image-20221206192355775.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/c++algo/image-20221206194104943.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/c++algo/image-20230211162531680.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/c++algo/image-20230213105233231.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/c++algo/image-20230213152207201.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/c++algo/image-20230213152430689.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/c++algo/image-20230216154315591.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/c++algo/image-20230216154435308.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/c++algo/image-20230216154634981.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/c++algo/image-20230216154841963.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/c++algo/image-20230217101205867.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/c++algo/image-20230217105825043.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/c++algo/image-20230217105301828.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/c++algo/image-20230217105756723.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/c++algo/image-20230217110214584.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/c++algo/image-20230217110303025.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/c++algo/image-20230217110533906.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/c++algo/image-20230221094940138.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/c++algo/image-20230221103736840.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/c++algo/image-20221121101324796.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/c++algo/image-20221121101506770.png">
<meta property="article:published_time" content="2022-01-26T06:43:17.000Z">
<meta property="article:modified_time" content="2024-11-28T14:37:09.115Z">
<meta property="article:author" content="Chuckie">
<meta property="article:tag" content="C++algorithm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2022/01/26/C++/c++algo/202202192210160.png">

<link rel="canonical" href="http://yoursite.com/2022/01/26/C++/c++algo/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>C++algorithm | Chuckie's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Chuckie's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/01/26/C++/c++algo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Chuckie">
      <meta itemprop="description" content="Bright future">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chuckie's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++algorithm
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-26 14:43:17" itemprop="dateCreated datePublished" datetime="2022-01-26T14:43:17+08:00">2022-01-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-28 22:37:09" itemprop="dateModified" datetime="2024-11-28T22:37:09+08:00">2024-11-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>106k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1:37</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="一"><a href="#一" class="headerlink" title="一"></a>一</h1><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="工具函数"><a href="#工具函数" class="headerlink" title="工具函数"></a>工具函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SortTestHelper &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//生成n个随机数，每个元素的范围：[l,r]</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span>* <span class="title">generateRandomArray</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">		assert(l &lt; r);<span class="comment">//满足条件才继续执行  要引入&lt;cassert&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span>* arr = <span class="keyword">new</span> <span class="keyword">int</span>[n];<span class="comment">//注意在堆区生成，需要delete[]</span></span><br><span class="line"></span><br><span class="line">		srand(time(<span class="literal">NULL</span>));<span class="comment">//生成随机数的种子， 需要引入&lt;ctime&gt;</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			arr[i] = rand() % (r - l + <span class="number">1</span>) + l;<span class="comment">//rand生成的是随机整数</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> arr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//打印数组的所有元素,n是数组长度</span></span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//检查排序是否正确</span></span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isSorted</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>])</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通用函数执行时间计算函数</span></span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;           <span class="comment">//sort是函数指针</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">testSort</span><span class="params">(<span class="built_in">string</span> sortName, <span class="keyword">void</span>(*sort)(T[], <span class="keyword">int</span>), T arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">clock_t</span> startTime = clock(); <span class="comment">//需要引入&lt;ctime&gt;</span></span><br><span class="line">		sort(arr, n);<span class="comment">//调用传入的函数</span></span><br><span class="line">		<span class="keyword">clock_t</span> endTime = clock();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">//判断函数执行排序是否正确</span></span><br><span class="line">		assert(isSorted(arr, n));</span><br><span class="line">		                            <span class="comment">//计算时钟周期个数            //宏定义 1秒有几个时钟周期</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; sortName &lt;&lt; <span class="string">" : "</span> &lt;&lt; <span class="keyword">double</span>(endTime - startTime) / CLOCKS_PER_SEC &lt;&lt; <span class="string">" s"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="桶排序、计数排序、基数排序"><a href="#桶排序、计数排序、基数排序" class="headerlink" title="桶排序、计数排序、基数排序"></a>桶排序、计数排序、基数排序</h3><blockquote>
<p><a href="https://blog.csdn.net/qq_55624813/article/details/121316256" target="_blank" rel="noopener">https://blog.csdn.net/qq_55624813/article/details/121316256</a></p>
</blockquote>
<ul>
<li><p>桶排序</p>
<ul>
<li>稳定排序</li>
<li>思路<ul>
<li>划分区间，填充到区间中，区间内快排</li>
</ul>
</li>
<li>时间复杂度<ul>
<li>O(m*n/mlogn/m)   = nlogn/m（划分m个桶）, m越接近n则越接近O(n)</li>
</ul>
</li>
<li>空间复杂度<ul>
<li>O(n)</li>
</ul>
</li>
<li>应用场景<ul>
<li>磁盘中大量数据排序</li>
</ul>
</li>
</ul>
</li>
<li><p>计数排序</p>
<ul>
<li>稳定排序</li>
<li>思想<ul>
<li>类似桶排序，不过区间大小为1</li>
<li>只适合范围比较小的数据，n个数据，最大值为k，需要k不能大于n太多，只能处理非负数</li>
</ul>
</li>
<li>时间复杂度<ul>
<li>O(n + k)  k是数据的最大值</li>
</ul>
</li>
<li>空间复杂度<ul>
<li>O(n + k) k是数据的最大值</li>
</ul>
</li>
<li>应用场景<ul>
<li>分数排序，分数范围一般在[0,100]，范围小</li>
</ul>
</li>
</ul>
</li>
<li><p>基数排序</p>
<ul>
<li>稳定排序</li>
<li>思想<ul>
<li>按位排序，先排低位，再排高位，每次排序用基数排序，</li>
<li>适合位数不是特别大的数据</li>
</ul>
</li>
<li>时间复杂度<ul>
<li>O(k*n)  k为位数，例如排序手机号，k = 11</li>
</ul>
</li>
<li>空间复杂度<ul>
<li>O(n)</li>
</ul>
</li>
<li>应用场景<ul>
<li>10万手机号排序</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><blockquote>
<p>时间复杂度：O(n*n)</p>
<p>需要额外空间： O(1)</p>
</blockquote>
<p>从数组第一个元素开始，在其后选择一个最小的元素与之交换，然后后移一格，再在其后选择一个最小的元素与之交换，以此类推</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SortTestHelper.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> minIndex = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">				minIndex = j;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		swap(arr[i], arr[minIndex]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">10</span>] = &#123; <span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span> &#125;;</span><br><span class="line">	selectSort(a, <span class="number">10</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; a[i] ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">string</span> c[<span class="number">3</span>] = &#123; <span class="string">"C"</span>,<span class="string">"B"</span>, <span class="string">"A"</span> &#125;;</span><br><span class="line">	selectSort(c, <span class="number">3</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; c[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	Student s[<span class="number">4</span>] = &#123; &#123;<span class="string">"D"</span>, <span class="number">100</span>&#125;,&#123;<span class="string">"C"</span>,<span class="number">95</span>&#125;,&#123;<span class="string">"B"</span>, <span class="number">95</span>&#125;,&#123;<span class="string">"A"</span>, <span class="number">91</span>&#125; &#125;;</span><br><span class="line">	selectSort(s, <span class="number">4</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; s[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> n = <span class="number">10000</span>;</span><br><span class="line">	<span class="keyword">int</span>* arr = SortTestHelper::generateRandomArray(n, <span class="number">0</span>, n);</span><br><span class="line">	selectSort(arr, n);</span><br><span class="line">	SortTestHelper::printArray(arr, n);</span><br><span class="line">	<span class="keyword">delete</span>[] arr; <span class="comment">//注意删除堆区的临时变量</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Student.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">	<span class="built_in">string</span> name;</span><br><span class="line">	<span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Student&amp; otherStudent) &#123;</span><br><span class="line">		<span class="keyword">return</span> score != otherStudent.score ? score &lt; otherStudent.score : name &lt; otherStudent.name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="keyword">const</span> Student&amp; student) &#123;</span><br><span class="line">		os &lt;&lt; <span class="string">"Student: "</span> &lt;&lt; student.name &lt;&lt; <span class="string">" "</span> &lt;&lt; student.score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> os;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><blockquote>
<ul>
<li>时间复杂度：O（n*n）</li>
<li>需要额外空间： O(1)</li>
<li>相对选择排序的优势： 内层循环可以提前终止</li>
<li>相对选择排序优势更明显的情况： 数组的有序性本身很高，这样内层循环就会更早提前终止</li>
<li>对于近乎有序的排序情况，插入排序比O(n*logn)的排序算法还要好</li>
<li>数组本身有序时，插入排序时间复杂度：O(N)</li>
</ul>
</blockquote>
<p>从第二个元素开始，依次往后移动，每次将当前元素插入到前面已经排序好的序列中正确的位置，即比自己大的就往后移动</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SortTestHelper.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//选择排序</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> minIndex = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">				minIndex = j;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		swap(arr[i], arr[minIndex]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入排序</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">		T temp = arr[i];</span><br><span class="line">		<span class="keyword">int</span> j;<span class="comment">//在循环之外还要使用</span></span><br><span class="line">		<span class="keyword">for</span> ( j = i; j &gt; <span class="number">0</span> &amp;&amp; arr[j<span class="number">-1</span>]&gt;temp ; j--) &#123;<span class="comment">//arr[j-1]&gt;temp确保提前终止</span></span><br><span class="line">			arr[j] = arr[j - <span class="number">1</span>]; <span class="comment">//这里用赋值，不用swap，因为一次swap相当于三次赋值，而且还有索引数组</span></span><br><span class="line">		&#125;</span><br><span class="line">		arr[j] = temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> n = <span class="number">10000</span>;</span><br><span class="line">	<span class="comment">/*int* arr = SortTestHelper::generateRandomArray(n, 0, n);</span></span><br><span class="line"><span class="comment">	int* arr2 = SortTestHelper::copyIntArray(arr, n);*/</span></span><br><span class="line">	<span class="keyword">int</span>* arr = SortTestHelper::generateNearlyOrderedArray(n, <span class="number">10</span>);<span class="comment">//生成近乎有序的数组</span></span><br><span class="line">	<span class="keyword">int</span>* arr2 = SortTestHelper::copyIntArray(arr, n);</span><br><span class="line">	<span class="comment">/*selectSort(arr, n);</span></span><br><span class="line"><span class="comment">	SortTestHelper::printArray(arr, n);*/</span></span><br><span class="line">	SortTestHelper::testSort(<span class="string">"selectSort"</span>, selectSort, arr, n);</span><br><span class="line">	SortTestHelper::testSort(<span class="string">"insertSort"</span>, insertSort, arr2, n);</span><br><span class="line">	<span class="keyword">delete</span>[] arr; <span class="comment">//注意删除堆区的临时变量</span></span><br><span class="line">	<span class="keyword">delete</span>[] arr2;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><blockquote>
<p><a href="https://blog.csdn.net/yuan2019035055/article/details/120246584" target="_blank" rel="noopener">https://blog.csdn.net/yuan2019035055/article/details/120246584</a></p>
<p><strong>希尔排序</strong>（Shell Sort）是<a href="https://so.csdn.net/so/search?q=插入排序&spm=1001.2101.3001.7020" target="_blank" rel="noopener">插入排序</a>的一种。也称缩小增量排序，是直接插入排序算法的一种更高效的改进版本。希尔排序是<strong>非稳定</strong>排序算法。</p>
<p>时间复杂度：O(n*1.3), 最坏：O(n^2)   比选择和插入排序快</p>
<p>需要额外空间： O(1)</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> <span class="built_in">step</span> = n/<span class="number">2</span>; <span class="built_in">step</span> &gt;<span class="number">0</span>; <span class="built_in">step</span> /= <span class="number">2</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">step</span>; i++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="built_in">step</span>; j &lt; n; j += <span class="built_in">step</span>)&#123;</span><br><span class="line">        T temp = arr[j];</span><br><span class="line">        <span class="keyword">int</span> m;</span><br><span class="line">        <span class="keyword">for</span>(m = j-<span class="built_in">step</span>; m &gt;= <span class="number">0</span> &amp;&amp; arr[m] &gt; temp; m -= <span class="built_in">step</span>)&#123;</span><br><span class="line">          arr[m+<span class="built_in">step</span>] = arr[m];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[m+<span class="built_in">step</span>] = temp;  <span class="comment">// 上面循环结束时m又-step了</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> vec[] = &#123;<span class="number">12</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">632</span>,<span class="number">5</span>,<span class="number">689</span>,<span class="number">34</span>,<span class="number">67</span>,<span class="number">89</span>&#125;;</span><br><span class="line">  shellSort(vec, <span class="number">9</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;vec[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><blockquote>
<ul>
<li>时间复杂度：O(n*logn)</li>
<li>需要额外空间: O(n)</li>
<li>自顶向下 </li>
<li>自底向上 适合链表的归并，因为对数组的索引操作比较少</li>
<li>优化：<ul>
<li>1： 拆分的最小单元用插入排序进行排序</li>
<li>2： 已经有序的数组则不需要进行合并操作</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将arr[l,mid]和arr[mid+1, r]两部分进行排序</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> __merge(T arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> mid, <span class="keyword">int</span> r) &#123;</span><br><span class="line">	T* aux = <span class="keyword">new</span> <span class="keyword">int</span>[r - l + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">		aux[i - l] = arr[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> i = l;</span><br><span class="line">	<span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = l; k &lt;= r; k++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i &gt; mid) &#123;  <span class="comment">// 如果左半部分元素已经全部处理完毕</span></span><br><span class="line">			arr[k] = aux[j - l]; j++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (j &gt; r) &#123;  <span class="comment">// 如果右半部分元素已经全部处理完毕</span></span><br><span class="line">			arr[k] = aux[i - l]; i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (aux[i - l] &lt; aux[j - l]) &#123;  <span class="comment">// 左半部分所指元素 &lt; 右半部分所指元素</span></span><br><span class="line">			arr[k] = aux[i - l]; i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;  <span class="comment">// 左半部分所指元素 &gt;= 右半部分所指元素</span></span><br><span class="line">			arr[k] = aux[j - l]; j++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span>[] aux;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//递归使用归并排序，对arr[l....r]范围进行排序</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> __mergeSort(T arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//递归结束条件</span></span><br><span class="line">	<span class="comment">/*if (l &gt;= r) &#123;</span></span><br><span class="line"><span class="comment">		return;</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 优化2: 对于小规模数组, 使用插入排序，因为小规模数组近乎有序</span></span><br><span class="line">	<span class="keyword">if</span> (r - l &lt;= <span class="number">15</span>) &#123;</span><br><span class="line">		insertSort(arr, l, r);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">	__mergeSort(arr, l, mid);</span><br><span class="line">	__mergeSort(arr, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 优化1: 对于arr[mid] &lt;= arr[mid+1]的情况,不进行merge</span></span><br><span class="line">	<span class="comment">// 对于近乎有序的数组非常有效,但是对于一般情况,有一定的性能损失(增加了条件判断)</span></span><br><span class="line">	<span class="keyword">if</span> (arr[mid] &gt; arr[mid + <span class="number">1</span>])</span><br><span class="line">		__merge(arr, l, mid, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//自顶向下</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	__mergeSort(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//自底向上</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSortBU</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//for (int sz = 1; sz &lt; n; sz += sz ) &#123;//sz: 1 2 4 8 16</span></span><br><span class="line">	<span class="comment">//	for (int i = 0; i+sz &lt; n; i += sz + sz) &#123; //i+sz &lt; n: 第二部分存在才需要合并</span></span><br><span class="line">	<span class="comment">//		__merge(arr, i, i + sz - 1, min(i+sz+sz-1,n-1));//注意越界问题</span></span><br><span class="line">	<span class="comment">//	&#125;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//对于小数组使用插入排序</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">16</span>) &#123;</span><br><span class="line">		insertSort(arr, i, <span class="built_in">min</span>(i + <span class="number">15</span>, n - <span class="number">1</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> sz = <span class="number">16</span>; sz &lt; n; sz += sz) &#123;<span class="comment">//sz: 1 2 4 8 16</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + sz &lt; n; i += sz + sz) &#123; <span class="comment">//i+sz &lt; n: 第二部分存在才需要合并</span></span><br><span class="line">			<span class="comment">// 对于arr[mid] &lt;= arr[mid+1]的情况,不进行merge</span></span><br><span class="line">			<span class="keyword">if</span>(arr[i+sz<span class="number">-1</span>]&gt;arr[i+sz])</span><br><span class="line">			  __merge(arr, i, i + sz - <span class="number">1</span>, <span class="built_in">min</span>(i + sz + sz - <span class="number">1</span>, n - <span class="number">1</span>));<span class="comment">//注意越界问题</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="归并求解逆序对"><a href="#归并求解逆序对" class="headerlink" title="归并求解逆序对"></a>归并求解逆序对</h4><blockquote>
<p><a href="https://blog.csdn.net/qq_41550842/article/details/81215935" target="_blank" rel="noopener">https://blog.csdn.net/qq_41550842/article/details/81215935</a></p>
<p>讲解更清晰：<a href="https://blog.csdn.net/Keep_Trying_Go/article/details/127175000" target="_blank" rel="noopener">https://blog.csdn.net/Keep_Trying_Go/article/details/127175000</a></p>
<p>逆序对：一个数组中，后面比前面大的数字对有多少个</p>
<p>只需要每次比较的时候记录后面放到前面去了，则逆序对加一</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 归并求解逆序对</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// [l, mid] [mid+1, r]</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> __merge(T arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> mid, <span class="keyword">int</span> r)&#123;</span><br><span class="line">  <span class="keyword">int</span>* temp = <span class="keyword">new</span> <span class="keyword">int</span>[r-l+<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r-l+<span class="number">1</span>; ++i)&#123;</span><br><span class="line">    temp[i] = arr[i+l];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> j = mid-l+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> k = l;</span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt;= mid -l || j &lt;= r-l)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; mid -l)&#123;</span><br><span class="line">      arr[k++] = temp[j++];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j &gt; r-l)&#123;</span><br><span class="line">      arr[k++] = temp[i++];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(temp[i] &lt;= temp[j])&#123;</span><br><span class="line">      arr[k++] = temp[i++];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">// cout&lt;&lt;temp[i]&lt;&lt;"----"&lt;&lt;temp[j]&lt;&lt;endl;</span></span><br><span class="line">      arr[k++] = temp[j++];</span><br><span class="line">      count += mid-l+<span class="number">1</span>  - i; <span class="comment">// 逆序计数</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span>[] temp;</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">repair</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> sz = <span class="number">1</span>; sz &lt; n; sz += sz)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i + sz &lt; n; i += sz+sz)&#123;</span><br><span class="line">      count += __merge(arr, i, i+sz<span class="number">-1</span>, <span class="built_in">min</span>(i+sz+sz<span class="number">-1</span>, n<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 暴力求解</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">repairForce</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j&lt; n; ++j)&#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[j] &lt; arr[i])&#123;</span><br><span class="line">        count++; </span><br><span class="line">        <span class="comment">// cout&lt;&lt;arr[i]&lt;&lt; "----"&lt;&lt;arr[j]&lt;&lt;endl;</span></span><br><span class="line">      &#125; </span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><blockquote>
<ul>
<li>时间复杂度：O(n*logn)</li>
<li>需要额外空间： O(logn)</li>
</ul>
<p>重复元素较多的情况使用三路快排</p>
</blockquote>
<h4 id="快排优化版本"><a href="#快排优化版本" class="headerlink" title="快排优化版本"></a>快排优化版本</h4><ul>
<li>优化1：最小单元的排序使用插入排序</li>
<li>优化2：分割位置的元素随机选择, (不随机的情况下，近乎有序数组的排序时间复杂度就会退化到O(n*n))</li>
</ul>
<p><img src="/2022/01/26/C++/c++algo/202202192210160.png" alt="image-20220219221043450"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对arr[l...r]部分进行partition操作</span></span><br><span class="line"><span class="comment">// 返回p, 使得arr[l...p-1] &lt; arr[p] ; arr[p+1...r] &gt; arr[p]</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> __partition(T arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//优化2： 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot， 避免有序数组拆分时形成链式树（深度退化为n）,时间复杂度也会退化为n*n</span></span><br><span class="line">	swap(arr[l], arr[rand() % (r - l + <span class="number">1</span>) + l]);</span><br><span class="line">	T v = arr[l];</span><br><span class="line">	<span class="keyword">int</span> j = l; <span class="comment">// arr[l+1...j] &lt; v ; arr[j+1...i) &gt; v</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = l + <span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (arr[i] &lt; v) &#123;</span><br><span class="line">			swap(arr[j + <span class="number">1</span>], arr[i]);</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	swap(arr[l], arr[j]);</span><br><span class="line">	<span class="keyword">return</span> j;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对arr[l...r]部分进行快速排序</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> __quickSort(T arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r) &#123;</span><br><span class="line">	<span class="comment">/*if (l &gt;= r) &#123;</span></span><br><span class="line"><span class="comment">		return;</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//优化1： 最小单元用插入排序 </span></span><br><span class="line">	<span class="keyword">if</span> (r - l &lt;= <span class="number">15</span>) &#123;</span><br><span class="line">		insertSort(arr, l, r);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> p = __partition(arr, l, r);</span><br><span class="line">	__quickSort(arr, l, p - <span class="number">1</span>);</span><br><span class="line">	__quickSort(arr, p + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	srand(time(<span class="literal">NULL</span>));</span><br><span class="line">	__quickSort(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="两路快排"><a href="#两路快排" class="headerlink" title="两路快排"></a>两路快排</h4><ul>
<li>用于解决重复元素很多的情况<ul>
<li>重复元素很多的情况下，划分的结果也会很不平衡，导致树的深度接近n,时间复杂度就会退化到O(n*n))</li>
</ul>
</li>
</ul>
<p><img src="/2022/01/26/C++/c++algo/202202192216456.png" alt="image-20220219221627897"></p>
<ul>
<li>二路快排示意图</li>
</ul>
<p><img src="/2022/01/26/C++/c++algo/202202192253159.png" alt="image-20220219225308292"></p>
<ul>
<li>排序完成后，两边都包含了等于v的部分，v正好放在中间，两边划分就比较平衡</li>
</ul>
<p><img src="/2022/01/26/C++/c++algo/202202192257525.png" alt="image-20220219225757590"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二路快排</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对arr[l...r]部分进行partition操作</span></span><br><span class="line"><span class="comment">// 返回p, 使得arr[l...p-1] &lt;= arr[p] ; arr[p+1...r] &gt;= arr[p] 与一路快排相比 等于arr[p]的元素是分布在arr[p]两边的</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> __partition2(T arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//优化2： 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot， 避免有序数组拆分时形成链式树（深度退化为n）,时间复杂度也会退化为n*n</span></span><br><span class="line">	swap(arr[l], arr[rand() % (r - l + <span class="number">1</span>) + l]);</span><br><span class="line">	T v = arr[l];</span><br><span class="line">	<span class="keyword">int</span> i = l + <span class="number">1</span>;<span class="comment">//移动标志位</span></span><br><span class="line">	<span class="keyword">int</span> j = r; <span class="comment">// arr[l+1...j) &lt; v ; arr(j...r] &gt; v</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="keyword">while</span>(i &lt;= r &amp;&amp; arr[i] &lt; v) &#123;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(j&gt;= l+<span class="number">1</span> &amp;&amp; arr[j] &gt; v) &#123;</span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i&gt; j)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		swap(arr[i], arr[j]);</span><br><span class="line">		i++;</span><br><span class="line">		j--;</span><br><span class="line">	&#125;</span><br><span class="line">	swap(arr[l], arr[j]);  <span class="comment">// 最后j是落在&lt;=v的位置上的，i是落在&gt;=v的位置上的，所以应该是arr[j]与arr[l]交换，才能保证arr[l,,,p-1]&lt;=arr[p]</span></span><br><span class="line">	<span class="keyword">return</span> j;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对arr[l...r]部分进行快速排序</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> __quickSort2(T arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r) &#123;</span><br><span class="line">	<span class="comment">/*if (l &gt;= r) &#123;</span></span><br><span class="line"><span class="comment">		return;</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//优化1： 最小单元用插入排序 </span></span><br><span class="line">	<span class="keyword">if</span> (r - l &lt;= <span class="number">15</span>) &#123;</span><br><span class="line">		insertSort(arr, l, r);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> p = __partition2(arr, l, r);</span><br><span class="line">	__quickSort2(arr, l, p - <span class="number">1</span>);</span><br><span class="line">	__quickSort2(arr, p + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort2</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	srand(time(<span class="literal">NULL</span>));</span><br><span class="line">	__quickSort2(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="三路快排"><a href="#三路快排" class="headerlink" title="三路快排"></a>三路快排</h4><ul>
<li>三路快排示意图<ul>
<li>中间等于v的部分不再参与进一步划分的排序</li>
</ul>
</li>
</ul>
<p><img src="/2022/01/26/C++/c++algo/image-20220901160350831.png" alt="image-20220901160350831"></p>
<p><img src="/2022/01/26/C++/c++algo/image-20220901160443789.png" alt="image-20220901160443789"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="comment">//三路快排</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对arr[l...r]部分进行快速排序</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> __quickSort3(T arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r) &#123;</span><br><span class="line">	<span class="comment">/*if (l &gt;= r) &#123;</span></span><br><span class="line"><span class="comment">		return;</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//优化1： 最小单元用插入排序 </span></span><br><span class="line">	<span class="keyword">if</span> (r - l &lt;= <span class="number">15</span>) &#123;</span><br><span class="line">		insertSort(arr, l, r);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//优化2： 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot， 避免有序数组拆分时形成链式树（深度退化为n）,时间复杂度也会退化为n*n</span></span><br><span class="line">	swap(arr[l], arr[rand() % (r - l + <span class="number">1</span>) + l]);</span><br><span class="line">	T v = arr[l];</span><br><span class="line">	<span class="keyword">int</span> lt = l;     <span class="comment">// arr[l+1...lt] &lt; v</span></span><br><span class="line">	<span class="keyword">int</span> gt = r + <span class="number">1</span>; <span class="comment">// arr[gt...r] &gt; v</span></span><br><span class="line">	<span class="keyword">int</span> i = l + <span class="number">1</span>;    <span class="comment">// arr[lt+1...i) == v</span></span><br><span class="line">	<span class="keyword">while</span> (i &lt; gt) &#123;</span><br><span class="line">		<span class="keyword">if</span> (arr[i] &lt; v) &#123;</span><br><span class="line">			swap(arr[i], arr[lt + <span class="number">1</span>]);</span><br><span class="line">			i++; <span class="comment">// 此时交换来的arr[lt+1] = v 所以要++</span></span><br><span class="line">			lt++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &gt; v)</span><br><span class="line">		&#123;</span><br><span class="line">			swap(arr[gt - <span class="number">1</span>], arr[i]); <span class="comment">// 此时交换来的arr[gt - 1]大小不确定，所以不能++i,需要进入下一轮判断</span></span><br><span class="line">			gt--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	swap(arr[l], arr[lt]);<span class="comment">// 注意次处交换后 [l,lt) &lt; arr[l] 而不是[l,lt] &lt; arr[l]</span></span><br><span class="line"></span><br><span class="line">	__quickSort3(arr, l, lt - <span class="number">1</span>);  <span class="comment">//[lt....gt-1]的部分不用再参与排序，因为都等于v</span></span><br><span class="line">	__quickSort3(arr, gt, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort3</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	srand(time(<span class="literal">NULL</span>));</span><br><span class="line">	__quickSort3(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="快排求解第n大元素"><a href="#快排求解第n大元素" class="headerlink" title="快排求解第n大元素"></a>快排求解第n大元素</h4><blockquote>
<p>正确性待检验</p>
<p>使用一路或二路快排，每次排完的p都正好在整个数组排好序的位置上，如果查找nmax == p 则可以提前终止排序</p>
<p>而且排序后<code>arr[l,p-1] &lt;= arr[p]  arr[p+1, r] &gt;= arr[p]</code> </p>
<p>如果<code>nmax != p</code> 也只需要大小判断后选择左右某一部分进入递归查找即可  类似二分查找</p>
<p>时间复杂度： n + n/2 + n/4 + n/8 + n/16 + …. + 1  = O（2n） = O (n)</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求解第n小的元素  求第k大元素要转化为求 第（n-k）小的元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">// 要求 l &lt; r</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partion1</span><span class="params">(T arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">  swap(arr[l], arr[rand()%(r-l+<span class="number">1</span>)+l]);</span><br><span class="line">  T v = arr[l];</span><br><span class="line">  <span class="keyword">int</span> i = l+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> j = r;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> (arr[i] &lt; v &amp;&amp; i&lt;=r) ++i;</span><br><span class="line">    <span class="keyword">while</span> (arr[j] &gt; v &amp;&amp; j &gt;= l+<span class="number">1</span>) --j;</span><br><span class="line">    swap(arr[i++], arr[j--]);</span><br><span class="line">  &#125;</span><br><span class="line">  swap(arr[l], arr[j]);</span><br><span class="line">  <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [l+1, i] &lt;= v [j,r]&gt;=v </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T __quickSort(T arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> nMax)&#123;</span><br><span class="line">  <span class="comment">// if( r &gt; l)return;</span></span><br><span class="line">  <span class="comment">// if(r==l) return arr[l]; 需要在这里处理r&gt;=l的情况  因为进入partion1需要 l&lt;r</span></span><br><span class="line">  <span class="keyword">int</span> p = partion1(arr, l, r);</span><br><span class="line">  <span class="keyword">if</span>(p == nMax)&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"p: "</span>&lt;&lt;p&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> arr[p];</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>( p &lt; nMax)&#123;</span><br><span class="line">    __quickSort(arr, p+<span class="number">1</span>, r, nMax);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    __quickSort(arr, l, p<span class="number">-1</span>, nMax);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">nthmax</span><span class="params">(T arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> nMax)</span></span>&#123;</span><br><span class="line">  srand(time(<span class="literal">NULL</span>));</span><br><span class="line">  __quickSort(arr, <span class="number">0</span>, n<span class="number">-1</span>, nMax);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><blockquote>
<p>时间复杂度：O(n*logn)</p>
<p>需要额外空间： O(1)</p>
<p>堆必须是一颗完全二叉树</p>
<ul>
<li>完全二叉树： 只有最后一层是不满的，其它层都是满节点</li>
</ul>
<p>堆排序大多用于动态数据的维护，而不用于系统级别的排序，因为比归并和快排慢</p>
</blockquote>
<h4 id="构建堆"><a href="#构建堆" class="headerlink" title="构建堆"></a>构建堆</h4><p><img src="/2022/01/26/C++/c++algo/202202202158199.png" alt="image-20220220215808534"></p>
<ul>
<li><p>通常用数组来表示堆，以<strong>广度优先遍历</strong>顺序存储到数组中</p>
</li>
<li><p>起点为0的情况</p>
<ul>
<li>左侧子节点的位置(数组中的索引值)：<code>2*index+1</code></li>
<li>右侧子节点的位置(数组中的索引值)：<code>2*index+2</code></li>
<li>父节点的位置： <code>floor((index-1)/2)</code> 向下取整</li>
</ul>
</li>
<li><p>起点为1的情况</p>
<ul>
<li>左侧子节点的位置(数组中的索引值)：<code>2*index</code></li>
<li>右侧子节点的位置(数组中的索引值)：<code>2*index+1</code></li>
<li>父节点的位置： <code>floor((index)/2)</code> 向下取整</li>
</ul>
</li>
</ul>
<h4 id="堆排序-1"><a href="#堆排序-1" class="headerlink" title="堆排序"></a>堆排序</h4><blockquote>
<p>将n个元素逐个插入到一个空堆中，时间复杂度是O(nlogn)</p>
<p>heapify的过程，时间复杂度为O(n), 时间复杂度证明较复杂，需要数学证明，记住结论即可</p>
<ul>
<li>heapify就是原地构造堆，在原来的数组上构造堆，从第一个非叶子节点开始shifDown，每次shifDown后以这个节点为根的子树就符合最大堆要求了</li>
<li>为什么不是从0开始shiftDown,举例即可知道：15，17，19，13，22，16，28，30，41，62</li>
</ul>
</blockquote>
<ul>
<li>构建最大堆，可以实现升序排序也可以实现逆序排序<ul>
<li>升序排序： 将依次取出的堆顶元素按数组正序写入</li>
<li>逆序排序： 将依次取出的堆顶元素按数组逆序写入</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxHeap</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Item* data;</span><br><span class="line">	<span class="keyword">int</span> count;</span><br><span class="line">	<span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">shiftUp</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; data[k / <span class="number">2</span>] &lt; data[k]) &#123;</span><br><span class="line">			swap(data[k / <span class="number">2</span>], data[k]);</span><br><span class="line">			k /= <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">shiftDown</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (<span class="number">2</span> * k &lt;= count<span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> j = <span class="number">2</span> * k;</span><br><span class="line">			<span class="keyword">if</span> (j + <span class="number">1</span> &lt;= count<span class="number">-1</span> &amp;&amp; data[j + <span class="number">1</span>] &gt; data[j]) j++;</span><br><span class="line">			<span class="keyword">if</span> (data[k] &gt;= data[j]) <span class="keyword">break</span>;</span><br><span class="line">			swap(data[k], data[j]);</span><br><span class="line">			k = j;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 构造函数, 构造一个空堆, 可容纳capacity个元素</span></span><br><span class="line">	MaxHeap(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">		data = <span class="keyword">new</span> Item[capacity ];</span><br><span class="line">		count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 构造函数, 通过一个给定数组创建一个最大堆</span></span><br><span class="line">	<span class="comment">// 该构造堆的过程, 时间复杂度为O(n)</span></span><br><span class="line">	MaxHeap(Item arr[], <span class="keyword">int</span> n) &#123;</span><br><span class="line">		data = <span class="keyword">new</span> Item[n];</span><br><span class="line">		capacity = n;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">			data[i] = arr[i];</span><br><span class="line">		count = n;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = count<span class="number">-1</span> / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)<span class="comment">//不是插入，而是就地构建堆，所以时间复杂度比插入小</span></span><br><span class="line">			shiftDown(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~MaxHeap() &#123;</span><br><span class="line">		<span class="keyword">delete</span>[] data;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回堆中的元素个数</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回一个布尔值, 表示堆中是否为空</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 向最大堆中插入一个新的元素 item</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Item item)</span> </span>&#123;</span><br><span class="line">		assert(count  &lt; capacity);</span><br><span class="line">		data[count] = item;</span><br><span class="line">		shiftUp(count);</span><br><span class="line">		count++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从最大堆中取出堆顶元素, 即堆中所存储的最大数据</span></span><br><span class="line">	<span class="function">Item <span class="title">extractMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		assert(count &gt; <span class="number">0</span>);</span><br><span class="line">		Item ret = data[<span class="number">0</span>];</span><br><span class="line">		swap(data[<span class="number">0</span>], data[count<span class="number">-1</span>]);</span><br><span class="line">		count--;</span><br><span class="line">		shiftDown(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取最大堆中的堆顶元素</span></span><br><span class="line">	<span class="function">Item <span class="title">getMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		assert(count &gt; <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> data[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// heapSort1, 将所有的元素依次添加到堆中, 在将所有元素从堆中依次取出来, 即完成了排序</span></span><br><span class="line"><span class="comment">// 无论是创建堆的过程, 还是从堆中依次取出元素的过程, 时间复杂度均为O(nlogn)</span></span><br><span class="line"><span class="comment">// 整个堆排序的整体时间复杂度为O(nlogn)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort1</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	MaxHeap&lt;T&gt; maxheap = MaxHeap&lt;T&gt;(n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		maxheap.insert(arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 逆序排序</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		arr[i] = maxheap.extractMax();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// heapSort2, 借助我们的heapify过程创建堆</span></span><br><span class="line"><span class="comment">// 此时, 创建堆的过程时间复杂度为O(n), 将所有元素依次从堆中取出来, 时间复杂度为O(nlogn)</span></span><br><span class="line"><span class="comment">// 堆排序的总体时间复杂度依然是O(nlogn), 但是比上述heapSort1性能更优, 因为创建堆的性能更优</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort2</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	MaxHeap&lt;T&gt; maxheap = MaxHeap&lt;T&gt;(arr, n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; </span><br><span class="line">		arr[i] = maxheap.extractMax();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="索引堆"><a href="#索引堆" class="headerlink" title="索引堆"></a>索引堆</h4><blockquote>
<p>引入索引堆的原因</p>
<ul>
<li>不是int型的数据，交换位置很耗费性能，例如string类型</li>
<li>堆排序后，查找元素不好索引，只能遍历数组查找，时间复杂度上升为O(n)</li>
</ul>
<p>索引堆的实现</p>
<ul>
<li>堆排序的所有操作都用int型的索引（index）来实现，数据本身(data)位置不变</li>
</ul>
<p>注意事项：</p>
<ul>
<li>一定注意count的值是否是预期的值，还有边界值，一定要明确，如果不清楚就用实例测试</li>
<li><strong>不用swap交换时，要注意用temp记录比较的值</strong>（shiftUp shiftDown中使用时）</li>
</ul>
</blockquote>
<p><img src="/2022/01/26/C++/c++algo/202202202107515.png" alt="image-20220220210719390"></p>
<ul>
<li><p>reverse的引入</p>
<ul>
<li><p>引入reverse的意义： 当data中的数据修改后，就需要重新调整堆，那么就需要知道修改的这元素在index中是在什么位置，以便调用shiftUp()或shiftDown()来调整堆</p>
</li>
<li><p>例如修改了data[4] = 26, 那么就需要知道data[4]的索引<code>4</code>在index中存储的位置，而reverse就保存了这个位置，即reverse[4]=9,</p>
<p>data[index[9]] = 26,  所以拿到索引<code>9</code>后执行<code>shiftUp(9)或shiftDown(9)</code>即可完成堆的调整</p>
</li>
</ul>
</li>
</ul>
<p><img src="/2022/01/26/C++/c++algo/202202212148699.png" alt="image-20220221214847006"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxHeap</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Item* data;</span><br><span class="line">	<span class="keyword">int</span>* index;</span><br><span class="line">	<span class="keyword">int</span> count;</span><br><span class="line">	<span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">shiftUp</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; data[index[k / <span class="number">2</span>]] &lt; data[index[k]]) &#123;</span><br><span class="line">			swap(index[k / <span class="number">2</span>], index[k]);</span><br><span class="line">			reverse[index[k / <span class="number">2</span>]] = k / <span class="number">2</span>;</span><br><span class="line">			reverse[index[k]] = k;</span><br><span class="line">			k /= <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">shiftDown</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (<span class="number">2</span> * k &lt;= count - <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> j = <span class="number">2</span> * k;</span><br><span class="line">			<span class="keyword">if</span> (j + <span class="number">1</span> &lt;= count - <span class="number">1</span> &amp;&amp; data[index[j + <span class="number">1</span>]] &gt; data[index[j]]) j++;</span><br><span class="line">			<span class="keyword">if</span> (data[index[k]] &gt;= data[index[j]]) <span class="keyword">break</span>;</span><br><span class="line">			swap(index[k], index[j]);</span><br><span class="line">			reverse[index[k]] = k;</span><br><span class="line">			reverse[index[j]] = j;</span><br><span class="line">			k = j;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//查看索引i这个位置的元素是否在堆中</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isInHeap</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">		assert(i &gt;= <span class="number">0</span> &amp;&amp; i &lt; capacity);<span class="comment">//首先i这个元素不能超过data中存储元素的个数</span></span><br><span class="line">		<span class="keyword">return</span> reverse[i] != <span class="number">-1</span>; <span class="comment">// = -1表示这个元素不在堆中</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 构造函数, 构造一个空堆, 可容纳capacity个元素</span></span><br><span class="line">	MaxHeap(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">		data = <span class="keyword">new</span> Item[capacity];</span><br><span class="line">		index = <span class="keyword">new</span> <span class="keyword">int</span>[capacity];</span><br><span class="line">		reverse = <span class="keyword">new</span> <span class="keyword">int</span>[capacity];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; capacity; i++) &#123;</span><br><span class="line">			reverse[i] = <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 构造函数, 通过一个给定数组创建一个最大堆</span></span><br><span class="line">	<span class="comment">// 该构造堆的过程, 时间复杂度为O(n)</span></span><br><span class="line">	MaxHeap(Item arr[], <span class="keyword">int</span> n) &#123;</span><br><span class="line">		data = <span class="keyword">new</span> Item[n];</span><br><span class="line">		index = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">		capacity = n;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			data[i] = arr[i];</span><br><span class="line">			index[i] = i;</span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line">		count = n;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = count - <span class="number">1</span> / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">			shiftDown(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~MaxHeap() &#123;</span><br><span class="line">		<span class="keyword">delete</span>[] data;</span><br><span class="line">		<span class="keyword">delete</span>[] index;</span><br><span class="line">		<span class="keyword">delete</span>[] reverse;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回堆中的元素个数</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回一个布尔值, 表示堆中是否为空</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 向最大堆中插入一个新的元素 item</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> i, Item item)</span> </span>&#123;</span><br><span class="line">		assert(count &lt; capacity);</span><br><span class="line">		assert(i &gt;= <span class="number">0</span> &amp;&amp; i &lt; capacity);</span><br><span class="line">		data[i] = item;</span><br><span class="line">		index[count] = i;</span><br><span class="line">		reverse[i] = count;</span><br><span class="line">		shiftUp(count);</span><br><span class="line">		count++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从最大堆中取出堆顶元素, 即堆中所存储的最大数据</span></span><br><span class="line">	<span class="function">Item <span class="title">extractMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		assert(count &gt; <span class="number">0</span>);</span><br><span class="line">		Item ret = data[index[<span class="number">0</span>]];</span><br><span class="line">		swap(index[<span class="number">0</span>], index[count - <span class="number">1</span>]);</span><br><span class="line">		reverse(index[<span class="number">0</span>]) = <span class="number">0</span>;</span><br><span class="line">		reverse(index[count - <span class="number">1</span>]) = <span class="number">-1</span>;</span><br><span class="line">		count--;</span><br><span class="line">		shiftDown(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取最大堆中的堆顶元素</span></span><br><span class="line">	<span class="function">Item <span class="title">getMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		assert(count &gt; <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> data[index[<span class="number">0</span>]];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取最大堆堆顶的索引</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getMaxIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		assert(count &gt; <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> index[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取最大索引堆中索引为i的元素</span></span><br><span class="line">	<span class="function">Item <span class="title">getItem</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">		assert( isInHeap(i));</span><br><span class="line">		<span class="keyword">return</span> data[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将最大索引堆中索引为i的元素修改为newItem</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> i, Item newItem)</span> </span>&#123;</span><br><span class="line">		assert(isInHeap(i));</span><br><span class="line">		data[i] = newItem;</span><br><span class="line">		<span class="comment">// 找到indexes[j] = i, j表示data[i]在堆中的位置</span></span><br><span class="line">	    <span class="comment">// 之后shiftUp(j), 再shiftDown(j)</span></span><br><span class="line">		<span class="comment">/*for (int j = 0; j &lt; count; j++) &#123;</span></span><br><span class="line"><span class="comment">			if (index[j] = i) &#123;</span></span><br><span class="line"><span class="comment">				shiftUp(j);</span></span><br><span class="line"><span class="comment">				shiftDown(j);</span></span><br><span class="line"><span class="comment">				break;</span></span><br><span class="line"><span class="comment">			&#125;</span></span><br><span class="line"><span class="comment">		&#125;*/</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> j = reverse[i];</span><br><span class="line">		shiftUp(j);</span><br><span class="line">		shiftDown(j);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// heapSort1, 将所有的元素依次添加到堆中, 在将所有元素从堆中依次取出来, 即完成了排序</span></span><br><span class="line"><span class="comment">// 无论是创建堆的过程, 还是从堆中依次取出元素的过程, 时间复杂度均为O(nlogn)</span></span><br><span class="line"><span class="comment">// 整个堆排序的整体时间复杂度为O(nlogn)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort1</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	MaxHeap&lt;T&gt; maxheap = MaxHeap&lt;T&gt;(n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		maxheap.insert(arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		arr[i] = maxheap.extractMax();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// heapSort2, 借助我们的heapify过程创建堆</span></span><br><span class="line"><span class="comment">// 此时, 创建堆的过程时间复杂度为O(n), 将所有元素依次从堆中取出来, 时间复杂度为O(nlogn)</span></span><br><span class="line"><span class="comment">// 堆排序的总体时间复杂度依然是O(nlogn), 但是比上述heapSort1性能更优, 因为创建堆的性能更优</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort2</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	MaxHeap&lt;T&gt; maxheap = MaxHeap&lt;T&gt;(arr, n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		arr[i] = maxheap.extractMax();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexMaxHeap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> count;</span><br><span class="line">  <span class="keyword">int</span> capacity;</span><br><span class="line">  T* data;</span><br><span class="line">  <span class="keyword">int</span>* index;</span><br><span class="line">  <span class="keyword">int</span>* rev;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">shiftUp</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    T temp = data[index[k]];</span><br><span class="line">    <span class="keyword">int</span> tempIndex = index[k];</span><br><span class="line">    <span class="keyword">while</span>(k&gt;<span class="number">0</span> &amp;&amp; data[index[(k<span class="number">-1</span>)/<span class="number">2</span>]] &lt; temp)&#123;</span><br><span class="line">      index[k] = index[(k<span class="number">-1</span>)/<span class="number">2</span>];</span><br><span class="line">      rev[index[k]] = k;</span><br><span class="line">      k = (k<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    index[k] = tempIndex;</span><br><span class="line">    rev[tempIndex] = k;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">shiftDown</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tempIndex = index[k];</span><br><span class="line">    T temp = data[tempIndex];</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">2</span>*k+<span class="number">1</span> &lt; count)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> j = <span class="number">2</span>*k+<span class="number">1</span> ;<span class="comment">// left node</span></span><br><span class="line">      <span class="keyword">if</span>(j+<span class="number">1</span> &lt; count &amp;&amp; data[index[j+<span class="number">1</span>]] &gt; data[index[j]]) ++j;</span><br><span class="line">      <span class="keyword">if</span>(data[index[j]] &lt;= temp) <span class="keyword">break</span>;</span><br><span class="line">      index[k] = index[j];</span><br><span class="line">      rev[index[k]] = k;</span><br><span class="line">      k = j;</span><br><span class="line">    &#125;</span><br><span class="line">    index[k] = tempIndex;</span><br><span class="line">    rev[tempIndex] = k;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">isInHeap</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rev[k] != INT32_MAX;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  IndexMaxHeap(<span class="keyword">int</span> capacity)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    data = <span class="keyword">new</span> T[capacity];</span><br><span class="line">    index = <span class="keyword">new</span> <span class="keyword">int</span>[capacity];</span><br><span class="line">    rev = <span class="keyword">new</span> <span class="keyword">int</span>[capacity];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; capacity; ++i)&#123;</span><br><span class="line">      rev[i] = INT32_MAX;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ~IndexMaxHeap()&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] data;</span><br><span class="line">    <span class="keyword">delete</span>[] index;</span><br><span class="line">    <span class="keyword">delete</span>[] rev;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(T item)</span></span>&#123;</span><br><span class="line">    assert(count&lt;capacity);</span><br><span class="line">    data[count] = item;</span><br><span class="line">    index[count] = count;</span><br><span class="line">    rev[count] = count;</span><br><span class="line">    shiftUp(count);</span><br><span class="line">    ++count;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">T <span class="title">extractMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// print();</span></span><br><span class="line">    T res = data[index[<span class="number">0</span>]];</span><br><span class="line">    swap(index[<span class="number">0</span>], index[--count]); <span class="comment">// 注意是--count</span></span><br><span class="line">    rev[index[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">    rev[index[count]] = INT32_MAX;<span class="comment">// 等同于这个点移除出堆了</span></span><br><span class="line">    shiftDown(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> i, T item)</span></span>&#123;</span><br><span class="line">      assert(isInHeap(i));</span><br><span class="line">      data[i] = item;</span><br><span class="line">      <span class="keyword">int</span> k = rev[i];</span><br><span class="line">      shiftDown(k);</span><br><span class="line">      shiftUp(k);</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"     : "</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; capacity; ++i)&#123;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;i &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"index: "</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; count; ++i)&#123;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;index[i] &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"data : "</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; capacity; ++i)&#123;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;data[i] &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"rev  : "</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; capacity; ++i)&#123;</span><br><span class="line">      <span class="keyword">if</span>(rev[i] == INT32_MAX)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"x"</span> &lt;&lt;<span class="string">"\t"</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;rev[i] &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"max  : "</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; count; ++i)&#123;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;data[index[i]] &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"----------------------------------------------------------------"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IndexHeapSort</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  IndexMaxHeap&lt;<span class="keyword">int</span>&gt; heap = IndexMaxHeap&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; n; ++i)&#123;</span><br><span class="line">    heap.insert(arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; n; ++i)&#123;</span><br><span class="line">    arr[i] = heap.extractMax();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="堆的应用"><a href="#堆的应用" class="headerlink" title="堆的应用"></a>堆的应用</h4><ul>
<li><p>在1 ,000,000个元素中选出前100名? 在N个元素中选出前M个元素</p>
<ul>
<li>用一个最小堆，维护100个元素，当插入元素个数超过100时，移除堆顶（也就是最小的元素），最后留下的100个元素就是最大的100个元素</li>
<li>时间复杂度NlogM</li>
</ul>
</li>
<li><p>多路归并</p>
</li>
<li><p>二项堆</p>
</li>
<li><p>斐波那契堆</p>
</li>
</ul>
<h3 id="排序算法总结"><a href="#排序算法总结" class="headerlink" title="排序算法总结"></a>排序算法总结</h3><p><img src="/2022/01/26/C++/c++algo/202202202057660.png" alt="image-20220220205712305"></p>
<ul>
<li>原地排序：就在原来的数组上操作</li>
<li>稳定性：如下图<ul>
<li>插入排序和归并排序在元素相等的情况下不会交换  所以稳定</li>
<li>快排在选择标定点的时候是随机选择的就会存在不稳定的情况，且对于二路归并相等的元素是会对调的，所以也不稳定</li>
<li>堆排序不稳定的情况：取出堆顶元素后会将堆顶元素与最后一个元素交换，这个过程可能导师相同元素不交换，导致不稳定</li>
</ul>
</li>
</ul>
<p><img src="/2022/01/26/C++/c++algo/202202202052061.png" alt="image-20220220205223400"></p>
<h2 id="搜索算法"><a href="#搜索算法" class="headerlink" title="搜索算法"></a>搜索算法</h2><h3 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a>二分查找法</h3><blockquote>
<p>Binary Search<br>对于有序数列，才能使用二分查找法(排序的作用)</p>
<p>时间复杂度O(logn)</p>
<p>非递归算法在性能上有微弱优势</p>
</blockquote>
<ul>
<li>非递归版</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分查找法 非递归</span></span><br><span class="line"><span class="comment">// 在有序数组arr中,查找target</span></span><br><span class="line"><span class="comment">// 如果找到target,返回相应的索引index</span></span><br><span class="line"><span class="comment">// 如果没有找到target,返回-1</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(T arr[], <span class="keyword">int</span> n, T target )</span> </span>&#123;</span><br><span class="line">	<span class="comment">//arr已经按升序排好序</span></span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> r = n - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (l &lt; r) &#123; <span class="comment">// 应该不能 l==r 否则l==r ---&gt; mid = l 这种情况就会漏掉</span></span><br><span class="line">		<span class="comment">//int mid = (l + r) / 2;//l+r有可能溢出，所以使用下面的方式求中点</span></span><br><span class="line">		<span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (target == arr[mid]) &#123;</span><br><span class="line">			<span class="keyword">return</span> mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (target &lt; arr[mid]) &#123;</span><br><span class="line">			r = mid - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			l = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//没有找到则返回-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>递归版</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> __binarySearch(T arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r, T target) &#123;</span><br><span class="line">	<span class="keyword">if</span> (l &gt; r)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="comment">//int mid = (l+r)/2;</span></span><br><span class="line">   <span class="comment">// 防止极端情况下的整形溢出，使用下面的逻辑求出mid</span></span><br><span class="line">	<span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span> (arr[mid] == target)</span><br><span class="line">		<span class="keyword">return</span> mid;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; target)</span><br><span class="line">		<span class="keyword">return</span> __binarySearch(arr, mid + <span class="number">1</span>, r, target);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> __binarySearch(arr, l, mid - <span class="number">1</span>, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//二分查找递归版</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch2</span><span class="params">(T arr[], <span class="keyword">int</span> n, T target)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> __binarySearch(arr, <span class="number">0</span>, n - <span class="number">1</span>, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二分搜索树"><a href="#二分搜索树" class="headerlink" title="二分搜索树"></a>二分搜索树</h3><blockquote>
<p> 二分搜索数是一个二叉树，但不一定是完全二叉树</p>
<p> 定义：每个节点的键值大于左孩子;每个节点的键值小于右孩子;以左右孩子为根的子树仍为二分搜索树</p>
<p> 二分搜索树中插入、搜索、删除时间复杂度都是O(logn)</p>
</blockquote>
<p><img src="/2022/01/26/C++/c++algo/202202222147102.png" alt="image-20220222214721719"></p>
<ul>
<li><p>二分搜索树的插入和搜索 </p>
</li>
<li><p>二分搜索树的遍历</p>
<ul>
<li>深度优先<ul>
<li>前序遍历∶先访问当前节点，再依次递归访问左右子树</li>
<li>中序遍历:先递归访问左子树，再访问自身，再递归访问右子树</li>
<li>后续遍历︰先递归访问左右子树，再访问自身节点<ul>
<li>后续遍历应用：二叉搜索树的空间释放，对new出来的节点进行delete</li>
</ul>
</li>
</ul>
</li>
<li>广度优先</li>
</ul>
</li>
<li><p>二分搜索树中删除最大值和最小值</p>
<ul>
<li>删除最大值思路：一直找右节点，直到没有右节点则这个点是最大值，删除后用这个点的左节点来顶替这个点</li>
<li>删除最小值思路：一直找左节点，直到没有左节点则这个点是最小值，删除后用这个点的右节点来顶替这个点</li>
</ul>
</li>
<li><p>二分搜索树中删除一个节点</p>
<ul>
<li><p>需要两个前置函数</p>
<ul>
<li>查找最小（大）值</li>
<li>删除最小（大）值</li>
</ul>
</li>
<li><p>用这个节点的右子树中的最小值（右子树中的最小值来顶替这个点才满足二分搜索树的定义）来顶替这个点</p>
<ul>
<li>找到这个节点的右子树的最小值后，用这个最小值的右节点来顶替这个最小值（原理同上面删除最小值类似），再用这个最小点来顶替这个要删除的点</li>
</ul>
</li>
<li><p>也可以用这个节点的左子树的最大值来顶替这个点</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分搜索树</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BST</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 树中的节点为私有的结构体, 外界不需要了解二分搜索树节点的具体实现</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">		Key key;</span><br><span class="line">		Value value;</span><br><span class="line">		Node* left;</span><br><span class="line">		Node* right;</span><br><span class="line"></span><br><span class="line">		Node(Key key, Value value) &#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;key = key;</span><br><span class="line">			<span class="keyword">this</span>-&gt;value = value;</span><br><span class="line">			<span class="keyword">this</span>-&gt;left = <span class="keyword">this</span>-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Node(Node* node) &#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;key = node-&gt;key;</span><br><span class="line">			<span class="keyword">this</span>-&gt;value = node-&gt;value;</span><br><span class="line">			<span class="keyword">this</span>-&gt;left = node-&gt;left;</span><br><span class="line">			<span class="keyword">this</span>-&gt;right = node-&gt;right;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	Node* root;<span class="comment">//根节点</span></span><br><span class="line">	<span class="keyword">int</span> count;<span class="comment">//树中的节点个数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 向以node为根的二分搜索树中, 插入节点(key, value), 使用递归算法，</span></span><br><span class="line">	<span class="comment">// 返回插入新节点后的二分搜索树的根</span></span><br><span class="line">    <span class="comment">// 这里的Node* node 是值传递，相当于又多了一个指针指向传进来的root, 如果new的新节点赋值给node,相当于改变此处node的指向，root指向的内容并没有改变，需要将new的新节点返回，让root接受并赋值</span></span><br><span class="line">	<span class="function">Node* <span class="title">insert</span><span class="params">(Node* node, Key key, Value value)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			count++;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Node(key, value);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (node-&gt;key == key)</span><br><span class="line">			node-&gt;value = value;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;key &lt; key)</span><br><span class="line">			node-&gt;right = insert(node-&gt;right, key, value);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			node-&gt;left = insert(node-&gt;left, key, value);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> node;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 查看以node为根的二分搜索树中是否包含键值为key的节点, 使用递归算法</span></span><br><span class="line">	<span class="keyword">bool</span> __contain(Node* node, Key key) &#123;</span><br><span class="line">		<span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (node-&gt;key == key)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (key &lt; node-&gt;key)</span><br><span class="line">			<span class="keyword">return</span> __contain(node-&gt;left, key);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> __contain(node-&gt;right, key);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在以node为根的二分搜索树中查找key所对应的value, 递归算法</span></span><br><span class="line">    <span class="comment">// 若value不存在, 则返回NULL， 因为要返回NULL表示没有找到，所以需要是指针</span></span><br><span class="line">	Value* __search(Node* node, Key key) &#123;</span><br><span class="line">		<span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">if</span> (node-&gt;key == key)</span><br><span class="line">			<span class="keyword">return</span> &amp;(node-&gt;value);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (key &lt; node-&gt;key)</span><br><span class="line">			<span class="keyword">return</span> __search(node-&gt;left, key);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> __search(node-&gt;right, key);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对以node为根的二叉搜索树进行前序遍历, 递归算法</span></span><br><span class="line">	<span class="keyword">void</span> __preOrder(Node* node) &#123;</span><br><span class="line">		<span class="keyword">if</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; node-&gt;key &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			__preOrder(node-&gt;left);</span><br><span class="line">			__preOrder(node -&gt; right);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对以node为根的二叉搜索树进行中序遍历, 递归算法</span></span><br><span class="line">	<span class="keyword">void</span> __inOrder(Node* node) &#123;</span><br><span class="line">		<span class="keyword">if</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			__inOrder(node-&gt;left);</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; node-&gt;key &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			__inOrder(node-&gt;right);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对以node为根的二叉搜索树进行后序遍历, 递归算法</span></span><br><span class="line">	<span class="keyword">void</span> __postOrder(Node* node) &#123;</span><br><span class="line">		<span class="keyword">if</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			__postOrder(node-&gt;left);</span><br><span class="line">			__postOrder(node-&gt;right);</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; node-&gt;key &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 释放以node为根的二分搜索树的所有节点</span></span><br><span class="line">    <span class="comment">// 采用后续遍历的递归算法</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			destroy(node-&gt;left);</span><br><span class="line">			destroy(node-&gt;right);</span><br><span class="line">			<span class="keyword">delete</span> node;</span><br><span class="line">			count--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回以node为根的二分搜索树的最小键值所在的节点</span></span><br><span class="line">	<span class="function">Node* <span class="title">mininum</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (node-&gt;left == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> mininum(node-&gt;left);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回以node为根的二分搜索树的最大键值所在的节点</span></span><br><span class="line">	<span class="function">Node* <span class="title">maxinum</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (node-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> maxinum(node-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 删除掉以node为根的二分搜索树中的最小节点</span></span><br><span class="line">	<span class="comment">// 返回删除节点后新的二分搜索树的根</span></span><br><span class="line">	<span class="function">Node* <span class="title">removeMin</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (node-&gt;left == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			Node* rightNode = node-&gt;right;</span><br><span class="line">			<span class="keyword">delete</span> node;</span><br><span class="line">			count--;</span><br><span class="line">			<span class="keyword">return</span> rightNode;</span><br><span class="line">		&#125;</span><br><span class="line">		node-&gt;left = removeMin(node-&gt;left);</span><br><span class="line">		<span class="keyword">return</span> node;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 删除掉以node为根的二分搜索树中的最大节点</span></span><br><span class="line">	<span class="comment">// 返回删除节点后新的二分搜索树的根</span></span><br><span class="line">	<span class="function">Node* <span class="title">removeMax</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (node-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			Node* leftNode = node-&gt;left;</span><br><span class="line">			<span class="keyword">delete</span> node;</span><br><span class="line">			count--;</span><br><span class="line">			<span class="keyword">return</span> leftNode;</span><br><span class="line">		&#125;</span><br><span class="line">		node-&gt;right = removeMax(node-&gt;right);</span><br><span class="line">		<span class="keyword">return</span> node;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这种方式更简洁  对于左右都有孩子的情况</span></span><br><span class="line">    Node* __remove(Node* root, Key key)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;key == key)&#123;</span><br><span class="line">          <span class="keyword">if</span>(root-&gt;left ==<span class="literal">NULL</span> &amp;&amp; root-&gt;right ==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">delete</span> root;</span><br><span class="line">            --count;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(root-&gt;left ==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            Node* node = root-&gt;right;</span><br><span class="line">            <span class="keyword">delete</span> root;</span><br><span class="line">            --count;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(root-&gt;right == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            Node* node = root-&gt;left;</span><br><span class="line">            <span class="keyword">delete</span> root;</span><br><span class="line">            --count;</span><br><span class="line">            <span class="keyword">return</span> node;        </span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 左右都有</span></span><br><span class="line">          Node* rightMin = __mininum(root-&gt;right);</span><br><span class="line">          <span class="comment">// 先赋值  因为后面删除会删除指向的地方</span></span><br><span class="line">          root-&gt;key = rightMin-&gt;key;</span><br><span class="line">          root-&gt;value = rightMin-&gt;value;</span><br><span class="line">          <span class="comment">// 再去删除</span></span><br><span class="line">          root-&gt;right = __removeMin(root-&gt;right);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key &lt; root-&gt;key)&#123;</span><br><span class="line">          root-&gt;left = __remove(root-&gt;left, key);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          root-&gt;right = __remove(root-&gt;right, key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 删除掉以node为根的二分搜索树中键值为key的节点, 递归算法</span></span><br><span class="line">	<span class="comment">// 返回删除节点后新的二分搜索树的根</span></span><br><span class="line">	<span class="function">Node* <span class="title">remove</span><span class="params">(Node* node, Key key)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (key &lt; node-&gt;key) &#123;</span><br><span class="line">			node-&gt;left = <span class="built_in">remove</span>(node-&gt;left, key);</span><br><span class="line">			<span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(key &gt; node-&gt;key)&#123;</span><br><span class="line">			node-&gt;right = <span class="built_in">remove</span>(node-&gt;right, key);</span><br><span class="line">			<span class="keyword">return</span> node;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123; <span class="comment">// key == node-&gt;key</span></span><br><span class="line">			<span class="comment">// 待删除节点左子树为空的情况</span></span><br><span class="line">			<span class="keyword">if</span> (node-&gt;left == <span class="literal">NULL</span>) &#123;</span><br><span class="line">				Node* rightNode = node-&gt;right;</span><br><span class="line">				<span class="keyword">delete</span> node;</span><br><span class="line">				count--;</span><br><span class="line">				<span class="keyword">return</span> rightNode;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 待删除节点右子树为空的情况</span></span><br><span class="line">			<span class="keyword">if</span> (node-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">				Node* leftNode = node-&gt;left;</span><br><span class="line">				<span class="keyword">delete</span> node;</span><br><span class="line">				count--;</span><br><span class="line">				<span class="keyword">return</span> leftNode;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 待删除节点左右子树均不为空的情况</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 找到比待删除节点大的最小节点, 即待删除节点右子树的最小节点</span></span><br><span class="line">            <span class="comment">// 用这个节点顶替待删除节点的位置</span></span><br><span class="line"></span><br><span class="line">			Node* tempNode = <span class="keyword">new</span> Node(mininum(node-&gt;right));<span class="comment">//找到当前节点右子树的最小节点， 注意这里要new Node 因为后面的removeMin会删掉这个节点</span></span><br><span class="line">			count++;<span class="comment">//new Node相当于加一个点，后面removeMin里count--  抵消</span></span><br><span class="line">			tempNode-&gt;left = node-&gt;left;</span><br><span class="line">			tempNode-&gt;right = removeMin(node-&gt;right);<span class="comment">//将node右子树中最小节点删除，并将右子树赋值给，，</span></span><br><span class="line">			<span class="keyword">delete</span> node;</span><br><span class="line">			count--;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">			<span class="keyword">return</span> tempNode;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 构造函数, 默认构造一棵空二分搜索树</span></span><br><span class="line">	BST() &#123;</span><br><span class="line">		root = <span class="literal">NULL</span>;</span><br><span class="line">		count = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~BST() &#123;</span><br><span class="line">		destroy(root);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回二分搜索树的节点个数</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回二分搜索树是否为空</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 向二分搜索树中插入一个新的(key, value)数据对</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Key key , Value value)</span> </span>&#123;</span><br><span class="line">		root = insert(root,key, value);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断键值key在二分搜索树中是否存在</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">contain</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> __contain(root,key);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//在二分搜索树中查找键值为key的value值</span></span><br><span class="line">	<span class="function">Value* <span class="title">search</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> __search(root, key);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//前序遍历</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		__preOrder(root);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//中序遍历</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		__inOrder(root);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//后序遍历</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		__postOrder(root);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//层序遍历 广度优先</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">queue</span>&lt;Node*&gt; q;</span><br><span class="line">		q.push(root);</span><br><span class="line">		<span class="keyword">while</span> (!q.empty())</span><br><span class="line">		&#123;</span><br><span class="line">			Node* node = q.front();</span><br><span class="line">			q.pop();</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; node-&gt;key &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">if</span>(node-&gt;left)</span><br><span class="line">				q.push(node-&gt;left);</span><br><span class="line">			<span class="keyword">if</span>(node-&gt;right)</span><br><span class="line">				q.push(node-&gt;right);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 寻找二分搜索树的最小的键值</span></span><br><span class="line">	<span class="function">Key <span class="title">mininum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		assert(count != <span class="number">0</span>);</span><br><span class="line">		Node* minNode = mininum(root);</span><br><span class="line">		<span class="keyword">return</span> minNode-&gt;key;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 寻找二分搜索树的最大的键值</span></span><br><span class="line">	<span class="function">Key <span class="title">maxinum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		assert(count != <span class="number">0</span>);</span><br><span class="line">		Node* maxNode = maxinum(root);</span><br><span class="line">		<span class="keyword">return</span> maxNode-&gt;key;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从二分搜索树中删除最小值所在节点</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">removeMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root)</span><br><span class="line">			root = removeMin(root);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从二分搜索树中删除最大值所在节点</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">removeMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root)</span><br><span class="line">			root = removeMax(root);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从二分搜索树中删除键值为key的节点</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">		root = <span class="built_in">remove</span>(root, key);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<p><strong>二分搜索树的顺序性</strong></p>
<ul>
<li><p>二分搜索树的floor和ceil</p>
<ul>
<li>如果查找的元素存在，则这个元素的floor和ceil就是这个元素本身</li>
<li>floor是找到最接近key的且小于key的值 ，key可以在二分搜索树中不存在</li>
<li>ceil是找到最接近key的且大于key的值，key可以在二分搜索树中不存在</li>
</ul>
</li>
<li><p>二分搜索树的rank(key)   key是排名第几的元素</p>
<ul>
<li>思路：给每个节点添加一个count，记录以该节点为根的树共有几个节点（包括当前节点）</li>
<li>由于每个节点count的添加，需要在insert和remove方法中维护count</li>
<li>58是排名第几的元素<ul>
<li>由根元素知有11个元素，由根元素左孩子知根元素排名至少大于等于6，由根元素右孩子知根元素排名为6，元素58大于等于7，由58元素左孩子为3知元素58排名为10</li>
</ul>
</li>
</ul>
<p><img src="/2022/01/26/C++/c++algo/202202232316544.png" alt="image-20220223231609976"></p>
</li>
<li><p>二分搜索树的select（num）  找排名第num的元素</p>
<ul>
<li>思路同上面的rank（）方法</li>
<li>由于每个节点count的添加，需要在insert和remove方法中维护count</li>
</ul>
</li>
<li><p>支持重复元素的二分搜索树</p>
<ul>
<li>思路1：插入时&lt;=则插入到左子树  即左子树包括了等于的情况</li>
<li>思路2：当重复元素特别多时，且同key一定同value时，为了节约空间，也可以给每个节点添加一个属性count用于记录这个阶段被加入了多少次</li>
<li>insert和remove等函数需要修改以维护每个节点count的正确</li>
</ul>
</li>
</ul>
<p><strong>二分搜索树的局限性</strong></p>
<ul>
<li>局限性：<ul>
<li>当插入的元素是有序的时，插入的结果就不是一个二叉树，而是只有左孩子（降序）或只有右孩子（升序）的情况，树的深度就为n了，时间复杂度就退化为O(n)</li>
<li>以上情况虽然和链表的时间复杂度都是O(n)，但实际情况比链表还要差，因为链表只维护一个指针，而二分搜索树需要维护左节点和右节点两个指针，而且还要一直判断左右节点是否为空</li>
</ul>
</li>
<li>解决方案：<ul>
<li>平衡二叉树：红黑树、2-3 tree、AVL tree、Splay tree</li>
</ul>
</li>
</ul>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><blockquote>
<p><strong>并查集Union Find</strong><br>主要功能：</p>
<ul>
<li>判断两点是否相连</li>
</ul>
<p>主要方法：</p>
<ul>
<li>union( p , q ) //将p,q合并到一个组中</li>
<li>find( p )          //找到p所在的组</li>
<li>isConnected( p , q )  //判断p、 q是否相连</li>
</ul>
</blockquote>
<h4 id="Quick-Find"><a href="#Quick-Find" class="headerlink" title="Quick Find"></a><strong>Quick Find</strong></h4><blockquote>
<p>用一个数组存储数据, id的值存储的是组号，组号相同则是相连的</p>
<p>查的时间复杂度为O(1)</p>
<p>并的时间复杂度为O(n)</p>
</blockquote>
<p><img src="/2022/01/26/C++/c++algo/202202241632360.png" alt="image-20220224163258018"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一版并查集</span></span><br><span class="line"><span class="keyword">namespace</span> UF1 &#123;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">int</span> *id;   <span class="comment">//存储并查集   存储数据结构为数组</span></span><br><span class="line">		<span class="keyword">int</span> count; <span class="comment">//并查集数据个数</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		UnionFind(<span class="keyword">int</span> n) &#123;</span><br><span class="line">			count = n;</span><br><span class="line">			id = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">				id[i] = i; <span class="comment">//初始化时每个元素自己一组</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		~UnionFind() &#123;</span><br><span class="line">			<span class="keyword">delete</span>[] id;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 查找过程, 查找元素p所对应的集合编号</span></span><br><span class="line">		<span class="comment">//时间复杂度O(1)</span></span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">			assert(p &gt;= <span class="number">0</span> &amp;&amp; p &lt; count);</span><br><span class="line">			<span class="keyword">return</span> id[p];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 查看元素p和元素q是否所属一个集合</span></span><br><span class="line">		<span class="comment">// O(1)复杂度</span></span><br><span class="line">		<span class="function"><span class="keyword">bool</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">find</span>(p) == <span class="built_in">find</span>(q);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 合并元素p和元素q所属的集合</span></span><br><span class="line">		<span class="comment">// O(n) 复杂度</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">unionElements</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">int</span> unionP = <span class="built_in">find</span>(p);</span><br><span class="line">			<span class="keyword">int</span> unionQ = <span class="built_in">find</span>(q);</span><br><span class="line">			<span class="keyword">if</span> (unionP == unionQ)<span class="comment">//已经在一个组</span></span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (id[i] == unionP) &#123;</span><br><span class="line">					id[i] = unionQ;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Quick-Union"><a href="#Quick-Union" class="headerlink" title="Quick Union"></a><strong>Quick Union</strong></h4><blockquote>
<p>用节点存储数据，节点a与节点b相连则节点a的指针指向节点b，返回过来也可以， 即每个节点有一个指针，和谁相连指针就指向谁</p>
<p><strong>思想用指针但实际用数组</strong>，因为每个节点只有指针这一个属性，则可以用数组的值存储，parent是几就表示和谁相连</p>
<p>find(): 找到根元素</p>
<p>uion(): 查找到各自的根，然后合并到根元素</p>
<p>isConnected(): 判断根元素相同则相连</p>
<p>查时间复杂度O(h), h为树的高度</p>
<p>并时间复杂度O(h), h为树的高度，用到了查的过程，除开查其实时间复杂度为O(1)</p>
</blockquote>
<ul>
<li>parent初始情况</li>
</ul>
<p><img src="/2022/01/26/C++/c++algo/202202241635774.png" alt="image-20220224163553529"></p>
<ul>
<li>合并操作<ul>
<li>先找到要合并的两个点的根节点</li>
<li>再将其中一个根节点指向另一个根节点</li>
<li>为什么不直接让合并的两个点中的一个指向另一个而是让它们的根节点中的一个指向另一个<ul>
<li>因为构造的结果是树，查找的时候树的深度越浅，查找越快，所以尽量不要构造成很长的链，所以让它们的根节点中的一个指向另一个，这样树的深度就会尽量的浅</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/2022/01/26/C++/c++algo/202202241639380.png" alt="image-20220224163917648"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二版并查集</span></span><br><span class="line"><span class="keyword">namespace</span> UF2 &#123;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">int</span>* parent;   <span class="comment">//存储并查集   存储数据结构为数组</span></span><br><span class="line">		<span class="keyword">int</span> count; <span class="comment">//并查集数据个数</span></span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		UnionFind(<span class="keyword">int</span> n) &#123;</span><br><span class="line">			count = n;</span><br><span class="line">			parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">				parent[i] = i; <span class="comment">//初始化时每个元素自己一组</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		~UnionFind() &#123;</span><br><span class="line">			<span class="keyword">delete</span>[] parent;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 查找过程</span></span><br><span class="line">		<span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">findRoot</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;<span class="comment">//查找p的根节点</span></span><br><span class="line">			assert(p &gt;= <span class="number">0</span> &amp;&amp; p &lt; count);</span><br><span class="line">			<span class="keyword">while</span> (p != parent[p])</span><br><span class="line">				p = parent[p];</span><br><span class="line">			<span class="keyword">return</span> p;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 查看元素p和元素q是否所属一个集合</span></span><br><span class="line">		<span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">		<span class="function"><span class="keyword">bool</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> findRoot(p) == findRoot(q);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 合并元素p和元素q所属的集合</span></span><br><span class="line">		<span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">unionElements</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">int</span> rootP = findRoot(p);</span><br><span class="line">			<span class="keyword">int</span> rootQ = findRoot(q);</span><br><span class="line">			<span class="keyword">if</span> (rootP == rootQ)</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			parent[rootP] = rootQ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Quick-Union的优化"><a href="#Quick-Union的优化" class="headerlink" title="Quick Union的优化"></a>Quick Union的优化</h4><blockquote>
<p>Quick Union存在的问题</p>
<ul>
<li>合并的时候是任意选择一个根节点指向另一个根节点</li>
<li>如果是层数高的根节点指向了层数低的根节点，则整体层数增加了</li>
<li>如果是层数低的根节点指向了层数高的根节点，则整体层数没有增加，所以每次合并应该选择这种方式，而不是任意的</li>
<li>例如上面图中的9和4合并，如果是8指向了9则层数变为4， 如果是9指向了8则层数还是3</li>
</ul>
<p>size优化和rank优化都是使得树的高度降低，即H尽量小，时间复杂仍然都是O(H) H为数的高度</p>
</blockquote>
<h5 id="基于size的优化"><a href="#基于size的优化" class="headerlink" title="基于size的优化"></a><strong>基于size的优化</strong></h5><ul>
<li><p>增加一个属性sz[]  存储每个根节点所在的树包含多少个节点</p>
</li>
<li><p>合并时不是随机合并，而是通过size的大小判断，让深度浅的指向深度高的根</p>
<ul>
<li>合并时使用sz同时更新sz</li>
</ul>
</li>
<li><p><em>本优化可以提高时间复杂度两个数量级</em></p>
<ul>
<li>百万级别也可以再1s内完成百万次合并和百万次查找</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三版并查集 优化合并的过程</span></span><br><span class="line"><span class="keyword">namespace</span> UF3 &#123;   </span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">int</span>* parent;   <span class="comment">//存储并查集   存储数据结构为数组</span></span><br><span class="line">		<span class="keyword">int</span>* sz; <span class="comment">// sz[i]表示以i为根的节点个数</span></span><br><span class="line">		<span class="keyword">int</span> count; <span class="comment">//并查集数据个数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		UnionFind(<span class="keyword">int</span> n) &#123;</span><br><span class="line">			count = n;</span><br><span class="line">			parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">			sz = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">				parent[i] = i; <span class="comment">//初始化时每个元素自己一组</span></span><br><span class="line">				sz[i] = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		~UnionFind() &#123;</span><br><span class="line">			<span class="keyword">delete</span>[] parent;</span><br><span class="line">			<span class="keyword">delete</span>[] sz;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 查找过程, 查找元素p所对应的集合编号</span></span><br><span class="line">		<span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">findRoot</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;<span class="comment">//查找p的根节点</span></span><br><span class="line">			assert(p &gt;= <span class="number">0</span> &amp;&amp; p &lt; count);</span><br><span class="line">			<span class="keyword">while</span> (p != parent[p])</span><br><span class="line">				p = parent[p];</span><br><span class="line">			<span class="keyword">return</span> p;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 查看元素p和元素q是否所属一个集合</span></span><br><span class="line">		<span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">		<span class="function"><span class="keyword">bool</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> findRoot(p) == findRoot(q);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 合并元素p和元素q所属的集合</span></span><br><span class="line">		<span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">unionElements</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">int</span> rootP = findRoot(p);</span><br><span class="line">			<span class="keyword">int</span> rootQ = findRoot(q);</span><br><span class="line">			<span class="keyword">if</span> (rootP == rootQ)</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			<span class="keyword">if</span> (sz[rootP] &gt;= sz[rootQ]) &#123;</span><br><span class="line">				parent[rootQ] = rootP;</span><br><span class="line">				sz[rootP] += sz[rootQ];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				parent[rootP] = rootQ;</span><br><span class="line">				sz[rootQ] += sz[rootP];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="基于rank的优化"><a href="#基于rank的优化" class="headerlink" title="基于rank的优化"></a><strong>基于rank的优化</strong></h5><ul>
<li>基于size的优化并没有真的比较两个根节点所在的树的深度，而是比较的根节点所在的树的节点个数，这导致结果仍然不理想<ul>
<li>如下图，按size方法，size[7] = 6  &gt;  size[8] = 3    ,所以是8指向7，结果仍然使得层数增加了</li>
</ul>
</li>
<li>基于rank则是完全按层数来选择<ul>
<li>如下图， 按rank方法，rank[7] = 1 &lt; rank[8] =3, 所以应该是层数少的7指向层数高的8</li>
</ul>
</li>
<li>rank优化的时间复杂度和size优化的时间复杂度差不多，只是可以处理一些特殊情况（避免树的层数太深），应用更广</li>
</ul>
<p><img src="/2022/01/26/C++/c++algo/202202241954265.png" alt="image-20220224195418308"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第四版并查集 优化合并的过程</span></span><br><span class="line"><span class="keyword">namespace</span> UF4 &#123;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">int</span>* parent;   <span class="comment">//存储并查集   存储数据结构为数组</span></span><br><span class="line">		<span class="keyword">int</span>* rank;      <span class="comment">// rank[i]表示以i为根的集合所表示的树的层数</span></span><br><span class="line">		<span class="keyword">int</span> count; <span class="comment">//并查集数据个数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		UnionFind(<span class="keyword">int</span> n) &#123;</span><br><span class="line">			count = n;</span><br><span class="line">			parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">			rank = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">				parent[i] = i; <span class="comment">//初始化时每个元素自己一组</span></span><br><span class="line">				rank[i] = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		~UnionFind() &#123;</span><br><span class="line">			<span class="keyword">delete</span>[] parent;</span><br><span class="line">			<span class="keyword">delete</span>[] rank;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 查找过程, 查找元素p所对应的集合编号</span></span><br><span class="line">		<span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">findRoot</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;<span class="comment">//查找p的根节点</span></span><br><span class="line">			assert(p &gt;= <span class="number">0</span> &amp;&amp; p &lt; count);</span><br><span class="line">			<span class="keyword">while</span> (p != parent[p])</span><br><span class="line">				p = parent[p];</span><br><span class="line">			<span class="keyword">return</span> p;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 查看元素p和元素q是否所属一个集合</span></span><br><span class="line">		<span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">		<span class="function"><span class="keyword">bool</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> findRoot(p) == findRoot(q);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 合并元素p和元素q所属的集合</span></span><br><span class="line">		<span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">unionElements</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">int</span> rootP = findRoot(p);</span><br><span class="line">			<span class="keyword">int</span> rootQ = findRoot(q);</span><br><span class="line">			<span class="keyword">if</span> (rootP == rootQ)</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			<span class="keyword">if</span> (rank[rootP] &gt; rank[rootQ]) &#123;</span><br><span class="line">				parent[rootQ] = rootP;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(rank[rootP] &lt; rank[rootQ])</span><br><span class="line">			&#123;</span><br><span class="line">				parent[rootP] = rootQ;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;<span class="comment">//rank[rootP] = rank[rootQ] 时，只有此时层数才会加1</span></span><br><span class="line">				parent[rootQ] = rootP;</span><br><span class="line">				rank[rootP] += <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h5><blockquote>
<p>在find的过程中将树的高度压缩即路径压缩</p>
<p>下面两个路径压缩的结果都使得<strong>时间复杂度近乎O(1)</strong></p>
<p>理论上递归的方式，树的层数更少，速度应该更快，但实际测试非递归的方式用时更短，应该是递归的过程使得时间更长了</p>
<p>路径压缩过程中需要更新rank，递归反方式可以更新，但是非递归则不太方便（不会）</p>
</blockquote>
<p><strong>非递归的方式</strong></p>
<ul>
<li>优化find函数，在查找一个元素的根元素的过程中同时降低树的层数</li>
<li>4不是根节点则让4的父节点指向父节点的父节点即4-&gt;2, 此时跳到2，2不是根节点则2的父节点指向父节点的父节点即2-&gt;0,结果如下图，此时跳到0，0为根节点，找到返回</li>
<li>此过程优化两个方面<ul>
<li>查找过程是跳着找的，中间没有访问3和1</li>
<li>查找过程顺便压缩了树的高度，使得下一次查找路径更短</li>
</ul>
</li>
</ul>
<p><img src="/2022/01/26/C++/c++algo/202202242138929.png" alt="image-20220224213819105"></p>
<p><strong>递归的方式</strong></p>
<ul>
<li>上面的压缩方式并不是最优结果</li>
<li>最优结果应该如下图所示</li>
<li>从4开始递归，4-&gt;find(4), 3-&gt;find(3),2-&gt;find(2),1-&gt;find(1),递归到底返回则一条链上的点都指向了根节点<ul>
<li>思路是一次递归到底，拿到根节点，再一层层返回赋值给链上的点</li>
</ul>
</li>
</ul>
<p> <img src="/2022/01/26/C++/c++algo/202202242201960.png" alt="image-20220224220121334"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第五版并查集 路径压缩，优化find</span></span><br><span class="line"><span class="keyword">namespace</span> UF5 &#123;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">int</span>* parent;   <span class="comment">//存储并查集   存储数据结构为数组</span></span><br><span class="line">		<span class="keyword">int</span>* rank;      <span class="comment">// rank[i]表示以i为根的集合所表示的树的层数</span></span><br><span class="line">		<span class="keyword">int</span> count; <span class="comment">//并查集数据个数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		UnionFind(<span class="keyword">int</span> n) &#123;</span><br><span class="line">			count = n;</span><br><span class="line">			parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">			rank = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">				parent[i] = i; <span class="comment">//初始化时每个元素自己一组</span></span><br><span class="line">				rank[i] = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		~UnionFind() &#123;</span><br><span class="line">			<span class="keyword">delete</span>[] parent;</span><br><span class="line">			<span class="keyword">delete</span>[] rank;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 查找过程, 查找元素p所对应的集合编号</span></span><br><span class="line">		<span class="comment">//非递归版  不太方便更新深度</span></span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">findRoot</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;<span class="comment">//查找p的根节点</span></span><br><span class="line">			assert(p &gt;= <span class="number">0</span> &amp;&amp; p &lt; count);</span><br><span class="line">			<span class="keyword">while</span> (p != parent[p]) &#123;</span><br><span class="line">				parent[p] = parent[parent[p]];</span><br><span class="line">				p = parent[p];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> p;</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//递归版</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">findRoot</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;<span class="comment">//查找p的根节点</span></span><br><span class="line">			assert(p &gt;= <span class="number">0</span> &amp;&amp; p &lt; count);</span><br><span class="line">			<span class="keyword">if</span> (p != parent[p]) &#123;</span><br><span class="line">				parent[p] = findRoot(parent[p]);</span><br><span class="line">                <span class="comment">// rank[p] = 1; 更新深度  待验证</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> parent[p];<span class="comment">//注意这里是parent[p]而不是p,因为需要返回的是根节点，递归的回溯的时候每一层只有parent[p]一直是指向根节点的</span></span><br><span class="line">		&#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">findRoot</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;<span class="comment">//查找p的根节点</span></span><br><span class="line">			assert(p &gt;= <span class="number">0</span> &amp;&amp; p &lt; count);</span><br><span class="line">            <span class="keyword">int</span> parentp;</span><br><span class="line">			<span class="keyword">if</span> (p != parent[p]) &#123;</span><br><span class="line">				parentp = findRoot(parent[p]);</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                parentp = p;</span><br><span class="line">            &#125;</span><br><span class="line">            parent[p] = parentp</span><br><span class="line">			<span class="keyword">return</span> parentp;<span class="comment">//每层记录根节点，保证返回的是根节点也行</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 查看元素p和元素q是否所属一个集合</span></span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">bool</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> findRoot(p) == findRoot(q);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 合并元素p和元素q所属的集合</span></span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">unionElements</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">int</span> rootP = findRoot(p);</span><br><span class="line">			<span class="keyword">int</span> rootQ = findRoot(q);</span><br><span class="line">			<span class="keyword">if</span> (rootP == rootQ)</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			<span class="keyword">if</span> (rank[rootP] &gt; rank[rootQ]) &#123;</span><br><span class="line">				parent[rootQ] = rootP;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (rank[rootP] &lt; rank[rootQ])</span><br><span class="line">			&#123;</span><br><span class="line">				parent[rootP] = rootQ;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;<span class="comment">//rank[rootP] = rank[rootQ] 时，只有此时层数才会加1</span></span><br><span class="line">				parent[rootQ] = rootP;</span><br><span class="line">				rank[rootP] += <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><h3 id="图论基础"><a href="#图论基础" class="headerlink" title="图论基础"></a>图论基础</h3><p>图的分类</p>
<ul>
<li>有向图</li>
<li>无向图</li>
<li>有权图</li>
<li>无权图</li>
</ul>
<p>图的连通性</p>
<ul>
<li>各点之间是相互连通的</li>
</ul>
<p><img src="/2022/01/26/C++/c++algo/202202251258467.png" alt="image-20220225125809972"></p>
<p>简单图</p>
<ul>
<li>没有自环边和平行边</li>
</ul>
<p><img src="/2022/01/26/C++/c++algo/202202251302297.png" alt="image-20220225130229656"></p>
<p>图的表示</p>
<ul>
<li>邻接矩阵    适合表示稠密的图</li>
<li>邻接表        适合表示稀疏的图</li>
</ul>
<h3 id="邻边迭代器"><a href="#邻边迭代器" class="headerlink" title="邻边迭代器"></a>邻边迭代器</h3><blockquote>
<p>遍历一个点的所有邻边</p>
<p>因为遍历一个点的所有邻边需要拿到存储图的二维数组g，但是g是对象的私有属性，用户不能直接使用</p>
<p>所以考虑用迭代器，通过迭代器在迭代器内部可以访问g，将访问结果返回，就可以遍历所有邻边了</p>
</blockquote>
<ul>
<li>邻接表</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//稀疏图 邻接表 简单无向图</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SparseGraph</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> vec;<span class="comment">//顶点数</span></span><br><span class="line">	<span class="keyword">int</span> edge;<span class="comment">//边数</span></span><br><span class="line">	<span class="keyword">bool</span> directed;<span class="comment">//是否是有向图  true是</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; g;<span class="comment">//邻接表</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	SparseGraph(<span class="keyword">int</span> n, <span class="keyword">bool</span> directed) &#123;</span><br><span class="line">		assert(n &gt;= <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">this</span>-&gt;vec = n;</span><br><span class="line">		<span class="keyword">this</span>-&gt;edge = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;directed = directed;</span><br><span class="line">		g = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~SparseGraph() &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getE</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> edge;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getV</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> vec;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">		assert(v &gt;= <span class="number">0</span> &amp;&amp; v &lt; vec);</span><br><span class="line">		assert(w &gt;= <span class="number">0</span> &amp;&amp; w &lt; vec);</span><br><span class="line">		<span class="comment">/*if (hasEdge(v, w))   //时间复杂度太高不使用</span></span><br><span class="line"><span class="comment">			return;*/</span></span><br><span class="line">		g[v].push_back(w);</span><br><span class="line">		<span class="keyword">if</span> (v!=w &amp;&amp; !directed)</span><br><span class="line">			g[w].push_back(v);</span><br><span class="line">		edge++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//时间复杂度O(n)</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">hasEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">		assert(v &gt;= <span class="number">0</span> &amp;&amp; v &lt; vec);</span><br><span class="line">		assert(w &gt;= <span class="number">0</span> &amp;&amp; w &lt; vec);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[v].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (g[v][i] == w)</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"SparseGraph: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;vec; i++) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; g[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; g[i][j] &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 邻边迭代器, 传入一个图和一个顶点,</span></span><br><span class="line">    <span class="comment">// 迭代在这个图中和这个顶点向连的所有顶点</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">adjIterator</span> &#123;</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		SparseGraph&amp; G;<span class="comment">//图G的引用</span></span><br><span class="line">		<span class="keyword">int</span> v;  <span class="comment">//要遍历边的顶点</span></span><br><span class="line">		<span class="keyword">int</span> index; <span class="comment">//记录遍历的位置</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		adjIterator(SparseGraph&amp; G, <span class="keyword">int</span> v):G(G) &#123;</span><br><span class="line">			<span class="comment">//this-&gt;G = G;</span></span><br><span class="line">			<span class="keyword">this</span>-&gt;v = v;</span><br><span class="line">			<span class="keyword">this</span>-&gt;index = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		~adjIterator() &#123;&#125;</span><br><span class="line">		<span class="comment">// 返回图G中与顶点v相连接的第一个顶点</span></span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			index = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (G.g[v].<span class="built_in">size</span>()) &#123;</span><br><span class="line">				<span class="keyword">return</span> G.g[v][index];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 若没有顶点和v相连接, 则返回-1</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 返回图G中与顶点v相连接的下一个顶点</span></span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			index++;</span><br><span class="line">			<span class="keyword">if</span> (index &lt; G.g[v].<span class="built_in">size</span>())</span><br><span class="line">				<span class="keyword">return</span> G.g[v][index];</span><br><span class="line">			<span class="comment">// 若没有顶点和v相连接, 则返回-1</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 查看是否已经迭代完了图G中与顶点v相连接的所有顶点</span></span><br><span class="line">		<span class="function"><span class="keyword">bool</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> index &gt;= G.g[v].<span class="built_in">size</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>邻接矩阵</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//稠密图  邻接矩阵   无向简单图</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DenseGraph</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> vec;<span class="comment">//顶点数</span></span><br><span class="line">	<span class="keyword">int</span> edge;<span class="comment">//边数</span></span><br><span class="line">	<span class="keyword">int</span> directed;<span class="comment">//是否为有向图</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; g;<span class="comment">//图的具体数据</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	DenseGraph(<span class="keyword">int</span> n, <span class="keyword">bool</span> directed) &#123;</span><br><span class="line">		assert(n &gt;= <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">this</span>-&gt;vec = n;</span><br><span class="line">		<span class="keyword">this</span>-&gt;edge = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;directed = directed;</span><br><span class="line">		g = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;(n, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n,<span class="literal">false</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~DenseGraph() &#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getE</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> edge;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getV</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> vec;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">		assert(v &gt;= <span class="number">0</span> &amp;&amp; v &lt; vec);</span><br><span class="line">		assert(w &gt;= <span class="number">0</span> &amp;&amp; w &lt; vec);</span><br><span class="line">		<span class="keyword">if</span> (hasEdge(v,w))</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		g[v][w] = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (!directed)</span><br><span class="line">			g[w][v] = <span class="literal">true</span>;</span><br><span class="line">		edge++;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">hasEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">		assert(v &gt;= <span class="number">0</span> &amp;&amp; v &lt; vec);</span><br><span class="line">		assert(w &gt;= <span class="number">0</span> &amp;&amp; w &lt; vec);</span><br><span class="line">		<span class="keyword">return</span> g[v][w];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"DenseGraph: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec; i++) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vec; j++) &#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; g[i][j] &lt;&lt;<span class="string">"\t"</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 邻边迭代器, 传入一个图和一个顶点,</span></span><br><span class="line">    <span class="comment">// 迭代在这个图中和这个顶点向连的所有顶点</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">adjIterator</span> &#123;</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		DenseGraph&amp; G;</span><br><span class="line">		<span class="keyword">int</span> v;</span><br><span class="line">		<span class="keyword">int</span> index;</span><br><span class="line">		<span class="keyword">bool</span> isEnd;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		adjIterator(DenseGraph&amp; G, <span class="keyword">int</span> v) :G(G) &#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;v = v;</span><br><span class="line">			<span class="keyword">this</span>-&gt;index = <span class="number">-1</span>; <span class="comment">// 索引从-1开始, 因为每次遍历都需要调用一次next()</span></span><br><span class="line">		&#125;</span><br><span class="line">		~adjIterator() &#123;&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 返回图G中与顶点v相连接的第一个顶点</span></span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			index = <span class="number">-1</span>; <span class="comment">// 索引从-1开始, 因为每次遍历都需要调用一次next()</span></span><br><span class="line">			<span class="keyword">return</span> next();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 返回图G中与顶点v相连接的下一个顶点</span></span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">// 从当前index开始向后搜索, 直到找到一个g[v][index]为true</span></span><br><span class="line">			<span class="keyword">for</span>(index +=  <span class="number">1</span>; index &lt; G.getV(); index++)&#123;</span><br><span class="line">				<span class="keyword">if</span> (G.g[v][index]) &#123;</span><br><span class="line">					<span class="keyword">return</span> index;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 若没有顶点和v相连接, 则返回-1</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 查看是否已经迭代完了图G中与顶点v相连接的所有顶点</span></span><br><span class="line">		<span class="function"><span class="keyword">bool</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> index &gt;= G.getV();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="读取图"><a href="#读取图" class="headerlink" title="读取图"></a>读取图</h3><blockquote>
<p>c++中文件读写部分  fstream相关</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//读取文件内容构建图  文件格式第一行 v(顶点个数) e(边的条数)   第二行开始i j  (i,j)表示一条边  </span></span><br><span class="line"><span class="comment">//传入图的引用，和文件地址</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Graph&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadGraph</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	ReadGraph(Graph&amp; g, <span class="built_in">string</span> filename) &#123;</span><br><span class="line">		<span class="function">ifstream <span class="title">file</span><span class="params">(filename)</span></span>;<span class="comment">//打开文件</span></span><br><span class="line">		<span class="built_in">string</span> <span class="built_in">line</span>;<span class="comment">//存储读取的一行的内容</span></span><br><span class="line">		<span class="keyword">int</span> V, E;</span><br><span class="line">		assert(file.is_open());<span class="comment">//判断是否打开成功</span></span><br><span class="line"></span><br><span class="line">		assert(getline(file, <span class="built_in">line</span>));<span class="comment">//将第一行读取到line中</span></span><br><span class="line">		<span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(<span class="built_in">line</span>)</span></span>;</span><br><span class="line">		ss &gt;&gt; V &gt;&gt; E;<span class="comment">//将ss中的内容读取到V,E中</span></span><br><span class="line"></span><br><span class="line">		assert(V == g.getV());<span class="comment">//判断读取的顶点数和初始化的顶点数相同</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//读取每一条边</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">			assert(getline(file, <span class="built_in">line</span>));<span class="comment">//读取下一行</span></span><br><span class="line">			<span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(<span class="built_in">line</span>)</span></span>;</span><br><span class="line">			<span class="keyword">int</span> a, b;</span><br><span class="line">			ss &gt;&gt; a &gt;&gt; b;<span class="comment">//读取边的两个顶点</span></span><br><span class="line">			assert(a &gt;= <span class="number">0</span> &amp;&amp; a &lt; V);</span><br><span class="line">			assert(b &gt;= <span class="number">0</span> &amp;&amp; b &lt; V);</span><br><span class="line">			g.addEdge(a, b);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>ReadGraph的使用</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> filename = <span class="string">"testG1.txt"</span>;</span><br><span class="line">DenseGraph dg = DenseGraph(<span class="number">13</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="function">ReadGraph&lt;DenseGraph&gt; <span class="title">rg1</span><span class="params">(dg, filename)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><blockquote>
<p>此部分实现了深度优先遍历、计算图的连通分量个数、用并查集记录同一个连通分量</p>
<p>深度优先遍历时间复杂度</p>
<ul>
<li>邻接表：O(v+E)  访问了每个点和每个边</li>
<li>邻接矩阵：O(v^2)  整个矩阵都访问了一遍</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入一个图，按深度优先遍历， 找出一个图中有多少个连通分量</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Graph&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Graph&amp; G;</span><br><span class="line">	<span class="keyword">bool</span>* visited;<span class="comment">//记录已经访问的点</span></span><br><span class="line">	<span class="keyword">int</span> ccount;<span class="comment">//记录连通分量个数 </span></span><br><span class="line">	<span class="keyword">int</span>* id;<span class="comment">//记录每个连通分量的标记  并查集 </span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//深度优先遍历</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">		visited[v] = <span class="literal">true</span>;</span><br><span class="line">		id[v] = ccount;</span><br><span class="line">		<span class="function"><span class="keyword">typename</span> Graph::adjIterator <span class="title">adj</span><span class="params">(G, v)</span></span>; <span class="comment">//typename声明Graph是typename,不然会报错</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> w = adj.<span class="built_in">begin</span>(); !adj.<span class="built_in">end</span>(); w = adj.next()) &#123;</span><br><span class="line">			<span class="keyword">if</span>(!visited[w])</span><br><span class="line">				dfs( w);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Component(Graph&amp; G) :G(G) &#123;</span><br><span class="line">		visited = <span class="keyword">new</span> <span class="keyword">bool</span>[G.getV()];</span><br><span class="line">		ccount = <span class="number">0</span>;</span><br><span class="line">		id = <span class="keyword">new</span> <span class="keyword">int</span>[G.getV()];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.getV(); i++) &#123;</span><br><span class="line">			visited[i] = <span class="literal">false</span>;</span><br><span class="line">			id[i] = <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.getV(); i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">				dfs(i);</span><br><span class="line">				ccount++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	~Component() &#123;</span><br><span class="line">		<span class="keyword">delete</span>[] visited;</span><br><span class="line">		<span class="keyword">delete</span>[] id;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> ccount;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断两点是否相连  用到了并查集</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">		assert(v &gt;= <span class="number">0</span> &amp;&amp; v &lt; G.getV());</span><br><span class="line">		assert(w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.getV());</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> id[v] == id[w];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="寻路"><a href="#寻路" class="headerlink" title="寻路"></a>寻路</h3><blockquote>
<p>通过深度优先的方式找到两点之间的一条路径（不管是不是最近的一条）</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;vector&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入一个图和一个起始点s, 按深度优先遍历， 构建从s出发是所有路径</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Graph&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Path</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Graph&amp; G;</span><br><span class="line">	<span class="keyword">bool</span>* visited;<span class="comment">//记录已经访问的点</span></span><br><span class="line">	<span class="keyword">int</span> s;<span class="comment">//起始点</span></span><br><span class="line">	<span class="keyword">int</span>* from;<span class="comment">//记录每个点的前驱节点from[w] = v 表示是从v访问到w的  构建的路径存储在from中</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//深度优先遍历</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">		visited[v] = <span class="literal">true</span>;</span><br><span class="line">		<span class="function"><span class="keyword">typename</span> Graph::adjIterator <span class="title">adj</span><span class="params">(G, v)</span></span>; <span class="comment">//typename声明Graph是typename,不然会报错</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> w = adj.<span class="built_in">begin</span>(); !adj.<span class="built_in">end</span>(); w = adj.next()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!visited[w]) &#123;</span><br><span class="line">				from[w] = v;</span><br><span class="line">				dfs(w);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Path(Graph&amp; G , <span class="keyword">int</span> s) :G(G) &#123;</span><br><span class="line">		assert(s &gt;= <span class="number">0</span> &amp;&amp; s &lt; G.getV());</span><br><span class="line">		visited = <span class="keyword">new</span> <span class="keyword">bool</span>[G.getV()];</span><br><span class="line">		from = <span class="keyword">new</span> <span class="keyword">int</span>[G.getV()];</span><br><span class="line">		<span class="keyword">this</span>-&gt;s = s;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.getV(); i++) &#123;</span><br><span class="line">			visited[i] = <span class="literal">false</span>;</span><br><span class="line">			from[i] = - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		dfs(s);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	~Path() &#123;</span><br><span class="line">		<span class="keyword">delete</span>[] visited;</span><br><span class="line">		<span class="keyword">delete</span>[] from;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断s和w之间是否有路</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">		assert(w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.getV());</span><br><span class="line">		<span class="keyword">return</span> visited[w];<span class="comment">//访问到了w则一定有路径</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将s到w的路径存入vec</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">path</span><span class="params">(<span class="keyword">int</span> w, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec)</span> </span>&#123;</span><br><span class="line">		assert(hasPath(w));</span><br><span class="line"></span><br><span class="line">		<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;  s;</span><br><span class="line">		<span class="keyword">int</span> p = w;</span><br><span class="line">		<span class="keyword">while</span> (p != <span class="number">-1</span>) &#123;</span><br><span class="line">			s.push(p);</span><br><span class="line">			p = from[p];<span class="comment">//最后from[s]==-1 所以找到s就会退出</span></span><br><span class="line">		&#125;</span><br><span class="line">		vec.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">			vec.push_back(s.top());</span><br><span class="line">			s.pop();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//打印s到w的路径</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">showPath</span><span class="params">(<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">		assert(hasPath(w));</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">		path(w, vec);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; vec[i] ;</span><br><span class="line">			<span class="keyword">if</span> (i == vec.<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"---&gt;"</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h3><blockquote>
<p>广度优先遍历时间复杂度</p>
<ul>
<li>邻接表：O(v+E)  访问了每个点和每个边</li>
<li>邻接矩阵：O(v^2)  整个矩阵都访问了一遍</li>
</ul>
<p>以下代码实现了广度优先方式的寻路，可对比上面的深度优先方式</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入一个图，按深度优先遍历， 找出一个图中有多少个连通分量</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Graph&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShortestPath</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Graph&amp; G;</span><br><span class="line">	<span class="keyword">bool</span>* visited;<span class="comment">//记录已经访问的点</span></span><br><span class="line">	<span class="keyword">int</span> s;<span class="comment">//起始点</span></span><br><span class="line">	<span class="keyword">int</span>* from;<span class="comment">//记录每个点的前驱节点from[w] = v 表示是从v访问到w的</span></span><br><span class="line">	<span class="keyword">int</span>* ord;<span class="comment">//记录每一个点的层数，即每个点到起点的距离</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	ShortestPath(Graph&amp; G, <span class="keyword">int</span> s) :G(G) &#123;</span><br><span class="line">		assert(s &gt;= <span class="number">0</span> &amp;&amp; s &lt; G.getV());</span><br><span class="line">		visited = <span class="keyword">new</span> <span class="keyword">bool</span>[G.getV()];</span><br><span class="line">		from = <span class="keyword">new</span> <span class="keyword">int</span>[G.getV()];</span><br><span class="line">		ord = <span class="keyword">new</span> <span class="keyword">int</span>[G.getV()];</span><br><span class="line">		<span class="keyword">this</span>-&gt;s = s;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.getV(); i++) &#123;</span><br><span class="line">			visited[i] = <span class="literal">false</span>;</span><br><span class="line">			from[i] = <span class="number">-1</span>;</span><br><span class="line">			ord[i] = <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//广度优先遍历</span></span><br><span class="line">		<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">		q.push(s);</span><br><span class="line">		visited[s] = <span class="literal">true</span>;</span><br><span class="line">		ord[s] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (!q.empty())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> w = q.front();</span><br><span class="line">			q.pop();</span><br><span class="line">			<span class="function"><span class="keyword">typename</span> Graph::adjIterator <span class="title">adj</span><span class="params">(G, w)</span></span>;<span class="comment">//拿到s的所有邻接点</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> v = adj.<span class="built_in">begin</span>(); !adj.<span class="built_in">end</span>(); v = adj.next()) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!visited[v]) &#123;</span><br><span class="line">					q.push(v);</span><br><span class="line">					visited[v] = <span class="literal">true</span>;</span><br><span class="line">					from[v] = w;</span><br><span class="line">					ord[v] = ord[w] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	~ShortestPath() &#123;</span><br><span class="line">		<span class="keyword">delete</span>[] visited;</span><br><span class="line">		<span class="keyword">delete</span>[] from;</span><br><span class="line">		<span class="keyword">delete</span>[] ord;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断s和w之间是否有路</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">		assert(w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.getV());</span><br><span class="line">		<span class="keyword">return</span> visited[w];<span class="comment">//访问到了w则一定有路径</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将s到w的路径存入vec</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">path</span><span class="params">(<span class="keyword">int</span> w, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">		assert(hasPath(w));</span><br><span class="line"></span><br><span class="line">		<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;  s;</span><br><span class="line">		<span class="keyword">int</span> p = w;</span><br><span class="line">		<span class="keyword">while</span> (p != <span class="number">-1</span>) &#123;</span><br><span class="line">			s.push(p);</span><br><span class="line">			p = from[p];<span class="comment">//最后from[s]==-1 所以找到s就会退出</span></span><br><span class="line">		&#125;</span><br><span class="line">		vec.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">			vec.push_back(s.top());</span><br><span class="line">			s.pop();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//打印s到w的路径</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">showPath</span><span class="params">(<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">		assert(hasPath(w));</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">		path(w, vec);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; vec[i];</span><br><span class="line">			<span class="keyword">if</span> (i == vec.<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"---&gt;"</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//查询w到s的路径长度</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">(<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">		assert(w &gt;= <span class="number">0</span> &amp;&amp; w &lt; G.getV());</span><br><span class="line">		<span class="keyword">return</span> ord[w];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><blockquote>
<p>生成树：图中有n个节点，通过n-1条边将n个节点连接起来所构成的树就叫生成树</p>
<p>最小生成树：生成树中n-1条边的权值相加最小的那个生成树</p>
<p>最小生成树针对：带权无向图、连通图</p>
</blockquote>
<p><img src="/2022/01/26/C++/c++algo/202202282226104.png" alt="image-20220228222623771"></p>
<h3 id="有权图"><a href="#有权图" class="headerlink" title="有权图"></a>有权图</h3><ul>
<li>邻接矩阵实现带权图： 矩阵的存储值直接存储权值，为了和下面的邻接表统一，不直接存储权值，而是也存储边的指针，若两点间没有边则存储NULL</li>
<li>邻接表实现带权图： 边作为一个单独的类，邻接表存储边的指针</li>
</ul>
<p><img src="/2022/01/26/C++/c++algo/202202281916752.png" alt="image-20220228191642778"></p>
<h4 id="边的定义"><a href="#边的定义" class="headerlink" title="边的定义"></a><strong>边的定义</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Weight&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> a; <span class="comment">//边的顶点</span></span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">	Weight w;<span class="comment">//边的权值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Edge(<span class="keyword">int</span> a, <span class="keyword">int</span> b, Weight w) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">		<span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">		<span class="keyword">this</span>-&gt;w = w;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Edge() &#123;&#125;</span><br><span class="line"></span><br><span class="line">	~Edge() &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getv</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a; <span class="comment">//返回一个顶点</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> b;<span class="comment">//返回另一个顶点</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">Weight <span class="title">getWt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> w;<span class="comment">//返回权值</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 给定一个顶点, 返回另一个顶点</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">other</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">		assert(v == a || v == b);</span><br><span class="line">		<span class="keyword">return</span> v == a ? b : a;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 输出边的信息</span></span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="keyword">const</span> Edge&amp; e) &#123;</span><br><span class="line">		os &lt;&lt; e.a &lt;&lt; <span class="string">"-"</span> &lt;&lt; e.b &lt;&lt; <span class="string">": "</span> &lt;&lt; e.w;</span><br><span class="line">		<span class="keyword">return</span> os;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 边的大小比较, 是对边的权值的大小比较</span></span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(Edge&lt;Weight&gt;&amp; e) &#123;</span><br><span class="line">		<span class="keyword">return</span> w &lt; e.getWt();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>&lt;=(Edge&lt;Weight&gt;&amp; e) &#123;</span><br><span class="line">		<span class="keyword">return</span> w &lt;= e.getWt();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(Edge&lt;Weight&gt;&amp; e) &#123;</span><br><span class="line">		<span class="keyword">return</span> w &gt; e.getWt();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>&gt;=(Edge&lt;Weight&gt;&amp; e) &#123;</span><br><span class="line">		<span class="keyword">return</span> w &gt;= e.getWt();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>==(Edge&lt;Weight&gt;&amp; e) &#123;</span><br><span class="line">		<span class="keyword">return</span> w == e.getWt();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="邻接矩阵构建图"><a href="#邻接矩阵构建图" class="headerlink" title="邻接矩阵构建图"></a><strong>邻接矩阵构建图</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Edge.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//稠密图  邻接矩阵   带权无向简单图 </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Weight&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DenseGraph</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> vec;<span class="comment">//顶点数</span></span><br><span class="line">	<span class="keyword">int</span> edge;<span class="comment">//边数</span></span><br><span class="line">	<span class="keyword">int</span> directed;<span class="comment">//是否为有向图</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;Edge&lt;Weight&gt; *&gt;&gt; g;<span class="comment">//图的具体数据</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	DenseGraph(<span class="keyword">int</span> n, <span class="keyword">bool</span> directed) &#123;</span><br><span class="line">		assert(n &gt;= <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">this</span>-&gt;vec = n;</span><br><span class="line">		<span class="keyword">this</span>-&gt;edge = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;directed = directed;</span><br><span class="line">		g = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;Edge&lt;Weight&gt; *&gt;&gt;(n, <span class="built_in">vector</span>&lt;Edge&lt;Weight&gt; *&gt;(n, <span class="literal">NULL</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~DenseGraph() &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vec; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (g[i][j] != <span class="literal">NULL</span>)</span><br><span class="line">					<span class="keyword">delete</span> g[i][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getE</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> edge;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getV</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> vec;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w ,Weight wt)</span> </span>&#123;</span><br><span class="line">		assert(v &gt;= <span class="number">0</span> &amp;&amp; v &lt; vec);</span><br><span class="line">		assert(w &gt;= <span class="number">0</span> &amp;&amp; w &lt; vec);</span><br><span class="line">		<span class="keyword">if</span> (hasEdge(v, w)) &#123;</span><br><span class="line">			<span class="keyword">delete</span> g[v][w];</span><br><span class="line">			<span class="keyword">if</span> (v!= w &amp;&amp; !directed)</span><br><span class="line">				<span class="keyword">delete</span> g[w][v];</span><br><span class="line">			edge--;</span><br><span class="line">		&#125;</span><br><span class="line">		g[v][w] = <span class="keyword">new</span> Edge&lt;Weight&gt;(v,w,wt);</span><br><span class="line">		<span class="keyword">if</span> (v!=w &amp;&amp; !directed)</span><br><span class="line">			g[w][v] = <span class="keyword">new</span> Edge&lt;Weight&gt;(w,v,wt);</span><br><span class="line">		edge++;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">hasEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">		assert(v &gt;= <span class="number">0</span> &amp;&amp; v &lt; vec);</span><br><span class="line">		assert(w &gt;= <span class="number">0</span> &amp;&amp; w &lt; vec);</span><br><span class="line">		<span class="keyword">return</span> g[v][w] != <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"DenseGraph: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec; i++) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vec; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (g[i][j])</span><br><span class="line">					<span class="built_in">cout</span> &lt;&lt; g[i][j]-&gt;getWt() &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					<span class="built_in">cout</span> &lt;&lt; <span class="string">"NULL\t"</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 邻边迭代器, 传入一个图和一个顶点,</span></span><br><span class="line">	<span class="comment">// 迭代在这个图中和这个顶点向连的所有顶点</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">adjIterator</span> &#123;</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		DenseGraph&amp; G;</span><br><span class="line">		<span class="keyword">int</span> v;</span><br><span class="line">		<span class="keyword">int</span> index;</span><br><span class="line">		<span class="keyword">bool</span> isEnd;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		adjIterator(DenseGraph&amp; G, <span class="keyword">int</span> v) :G(G) &#123;</span><br><span class="line">			<span class="keyword">this</span>-&gt;v = v;</span><br><span class="line">			<span class="keyword">this</span>-&gt;index = <span class="number">-1</span>; <span class="comment">// 索引从-1开始, 因为每次遍历都需要调用一次next()</span></span><br><span class="line">		&#125;</span><br><span class="line">		~adjIterator() &#123;&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 返回图G中与顶点v相连接的第一个顶点</span></span><br><span class="line">		<span class="function">Edge&lt;Weight&gt;* <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			index = <span class="number">-1</span>; <span class="comment">// 索引从-1开始, 因为每次遍历都需要调用一次next()</span></span><br><span class="line">			<span class="keyword">return</span> next();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 返回图G中与顶点v相连接的下一个顶点</span></span><br><span class="line">		<span class="function">Edge&lt;Weight&gt;* <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">// 从当前index开始向后搜索, 直到找到一个g[v][index]为true</span></span><br><span class="line">			<span class="keyword">for</span> (index += <span class="number">1</span>; index &lt; G.getV(); index++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (G.g[v][index]) &#123;</span><br><span class="line">					<span class="keyword">return</span> G.g[v][index];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 若没有顶点和v相连接, 则返回-1</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 查看是否已经迭代完了图G中与顶点v相连接的所有顶点</span></span><br><span class="line">		<span class="function"><span class="keyword">bool</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> index &gt;= G.getV();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="邻接表构建矩阵"><a href="#邻接表构建矩阵" class="headerlink" title="邻接表构建矩阵"></a><strong>邻接表构建矩阵</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="comment">//#include "Edge.h"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//稀疏图 邻接表 带权简单无向图</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Weight&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SparseGraph</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> vec;<span class="comment">//顶点数</span></span><br><span class="line">	<span class="keyword">int</span> edge;<span class="comment">//边数</span></span><br><span class="line">	<span class="keyword">bool</span> directed;<span class="comment">//是否是有向图  true是</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;Edge&lt;Weight&gt; *&gt;&gt; g;<span class="comment">//邻接表</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	SparseGraph(<span class="keyword">int</span> n, <span class="keyword">bool</span> directed) &#123;</span><br><span class="line">		assert(n &gt;= <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">this</span>-&gt;vec = n;</span><br><span class="line">		<span class="keyword">this</span>-&gt;edge = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;directed = directed;</span><br><span class="line">		g = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;Edge&lt;Weight&gt; *&gt;&gt;(n, <span class="built_in">vector</span>&lt;Edge&lt;Weight&gt; *&gt;());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~SparseGraph() &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; g[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">				<span class="keyword">delete</span> g[i][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getE</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> edge;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getV</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> vec;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w, Weight wt)</span> </span>&#123;</span><br><span class="line">		assert(v &gt;= <span class="number">0</span> &amp;&amp; v &lt; vec);</span><br><span class="line">		assert(w &gt;= <span class="number">0</span> &amp;&amp; w &lt; vec);</span><br><span class="line">		<span class="comment">/*if (hasEdge(v, w))   //时间复杂度太高不使用</span></span><br><span class="line"><span class="comment">			return;*/</span></span><br><span class="line">		g[v].push_back(<span class="keyword">new</span> Edge&lt;Weight&gt;(v,w,wt));</span><br><span class="line">		<span class="keyword">if</span> (v != w &amp;&amp; !directed)</span><br><span class="line">			g[w].push_back(<span class="keyword">new</span> Edge&lt;Weight&gt;(w,v,wt));</span><br><span class="line">		edge++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//时间复杂度O(n)</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">hasEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">		assert(v &gt;= <span class="number">0</span> &amp;&amp; v &lt; vec);</span><br><span class="line">		assert(w &gt;= <span class="number">0</span> &amp;&amp; w &lt; vec);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[v].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (g[v][i]-&gt;other(v) == w)</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"SparseGraph: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec; i++) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"vertex "</span> &lt;&lt; i &lt;&lt; <span class="string">":\t"</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; g[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"( to:"</span> &lt;&lt; g[i][j]-&gt;getw() &lt;&lt; <span class="string">",wt:"</span> &lt;&lt; g[i][j]-&gt;getWt() &lt;&lt; <span class="string">")\t"</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 邻边迭代器, 传入一个图和一个顶点,</span></span><br><span class="line">	<span class="comment">// 迭代在这个图中和这个顶点向连的所有顶点</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">adjIterator</span> &#123;</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		SparseGraph&amp; G;<span class="comment">//图G的引用</span></span><br><span class="line">		<span class="keyword">int</span> v;  <span class="comment">//要遍历边的顶点</span></span><br><span class="line">		<span class="keyword">int</span> index; <span class="comment">//记录遍历的位置</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		adjIterator(SparseGraph&amp; G, <span class="keyword">int</span> v) :G(G) &#123;</span><br><span class="line">			<span class="comment">//this-&gt;G = G;</span></span><br><span class="line">			<span class="keyword">this</span>-&gt;v = v;</span><br><span class="line">			<span class="keyword">this</span>-&gt;index = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		~adjIterator() &#123;&#125;</span><br><span class="line">		<span class="comment">// 返回图G中与顶点v相连接的第一个顶点</span></span><br><span class="line">		<span class="function">Edge&lt;Weight&gt;* <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			index = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (G.g[v].<span class="built_in">size</span>()) &#123;</span><br><span class="line">				<span class="keyword">return</span> G.g[v][index];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 若没有顶点和v相连接, 则返回-1</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 返回图G中与顶点v相连接的下一个顶点</span></span><br><span class="line">		<span class="function">Edge&lt;Weight&gt;* <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			index++;</span><br><span class="line">			<span class="keyword">if</span> (index &lt; G.g[v].<span class="built_in">size</span>())</span><br><span class="line">				<span class="keyword">return</span> G.g[v][index];</span><br><span class="line">			<span class="comment">// 若没有顶点和v相连接, 则返回-1</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 查看是否已经迭代完了图G中与顶点v相连接的所有顶点</span></span><br><span class="line">		<span class="function"><span class="keyword">bool</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> index &gt;= G.g[v].<span class="built_in">size</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="读取并构建带权图"><a href="#读取并构建带权图" class="headerlink" title="读取并构建带权图"></a><strong>读取并构建带权图</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//读取文件内容构建图  文件格式第一行 v(顶点个数) e(边的条数)   第二行开始i j  (i,j)表示一条边  </span></span><br><span class="line"><span class="comment">//传入图的引用，和文件地址</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Graph, <span class="keyword">typename</span> Weight&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadGraph</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	ReadGraph(Graph&amp; g, <span class="built_in">string</span> filename) &#123;</span><br><span class="line">		<span class="function">ifstream <span class="title">file</span><span class="params">(filename)</span></span>;<span class="comment">//打开文件</span></span><br><span class="line">		<span class="built_in">string</span> <span class="built_in">line</span>;<span class="comment">//存储读取的一行的内容</span></span><br><span class="line">		<span class="keyword">int</span> V, E;</span><br><span class="line">		assert(file.is_open());<span class="comment">//判断是否打开成功</span></span><br><span class="line"></span><br><span class="line">		assert(getline(file, <span class="built_in">line</span>));<span class="comment">//将第一行读取到line中</span></span><br><span class="line">		<span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(<span class="built_in">line</span>)</span></span>;</span><br><span class="line">		ss &gt;&gt; V &gt;&gt; E;<span class="comment">//将ss中的内容读取到V,E中</span></span><br><span class="line"></span><br><span class="line">		assert(V == g.getV());<span class="comment">//判断读取的顶点数和初始化的顶点数相同</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//读取每一条边</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E; i++) &#123;</span><br><span class="line">			assert(getline(file, <span class="built_in">line</span>));<span class="comment">//读取下一行</span></span><br><span class="line">			<span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(<span class="built_in">line</span>)</span></span>;</span><br><span class="line">			<span class="keyword">int</span> a, b;</span><br><span class="line">			Weight w;</span><br><span class="line">			ss &gt;&gt; a &gt;&gt; b&gt;&gt;w;<span class="comment">//读取边的两个顶点</span></span><br><span class="line">			assert(a &gt;= <span class="number">0</span> &amp;&amp; a &lt; V);</span><br><span class="line">			assert(b &gt;= <span class="number">0</span> &amp;&amp; b &lt; V);</span><br><span class="line">			g.addEdge(a, b, w);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="最小堆"><a href="#最小堆" class="headerlink" title="最小堆"></a>最小堆</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最小堆</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinHeap</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Item* data;</span><br><span class="line">	<span class="keyword">int</span> count;</span><br><span class="line">	<span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">shiftUp</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; data[k / <span class="number">2</span>] &gt; data[k]) &#123;</span><br><span class="line">			swap(data[k / <span class="number">2</span>], data[k]);</span><br><span class="line">			k /= <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">shiftDown</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (<span class="number">2</span> * k &lt;= count - <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> j = <span class="number">2</span> * k;</span><br><span class="line">			<span class="keyword">if</span> (j + <span class="number">1</span> &lt;= count - <span class="number">1</span> &amp;&amp; data[j + <span class="number">1</span>] &lt; data[j]) j++;</span><br><span class="line">			<span class="keyword">if</span> (data[k] &lt;= data[j]) <span class="keyword">break</span>;</span><br><span class="line">			swap(data[k], data[j]);</span><br><span class="line">			k = j;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 构造函数, 构造一个空堆, 可容纳capacity个元素</span></span><br><span class="line">	MinHeap(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">		data = <span class="keyword">new</span> Item[capacity];</span><br><span class="line">		count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 构造函数, 通过一个给定数组创建一个最大堆</span></span><br><span class="line">	<span class="comment">// 该构造堆的过程, 时间复杂度为O(n)</span></span><br><span class="line">	MinHeap(Item arr[], <span class="keyword">int</span> n) &#123;</span><br><span class="line">		data = <span class="keyword">new</span> Item[n];</span><br><span class="line">		capacity = n;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">			data[i] = arr[i];</span><br><span class="line">		count = n;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = count - <span class="number">1</span> / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)<span class="comment">//不是插入，而是就地构建堆，所以时间复杂度比插入小</span></span><br><span class="line">			shiftDown(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~MinHeap() &#123;</span><br><span class="line">		<span class="keyword">delete</span>[] data;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回堆中的元素个数</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回一个布尔值, 表示堆中是否为空</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 向最小堆中插入一个新的元素 item</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Item item)</span> </span>&#123;</span><br><span class="line">		assert(count &lt; capacity);</span><br><span class="line">		data[count] = item;</span><br><span class="line">		shiftUp(count);</span><br><span class="line">		count++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从最小堆中取出堆顶元素, 即堆中所存储的最小数据</span></span><br><span class="line">	<span class="function">Item <span class="title">extractMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		assert(count &gt; <span class="number">0</span>);</span><br><span class="line">		Item ret = data[<span class="number">0</span>];</span><br><span class="line">		swap(data[<span class="number">0</span>], data[count - <span class="number">1</span>]);</span><br><span class="line">		count--;</span><br><span class="line">		shiftDown(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取最小堆中的堆顶元素</span></span><br><span class="line">	<span class="function">Item <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		assert(count &gt; <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> data[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="最小索引堆"><a href="#最小索引堆" class="headerlink" title="最小索引堆"></a>最小索引堆</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexMinHeap</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Item* data;</span><br><span class="line">	<span class="keyword">int</span>* index;</span><br><span class="line">	<span class="keyword">int</span>* reverse;</span><br><span class="line">	<span class="keyword">int</span> count;</span><br><span class="line">	<span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">shiftUp</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; data[index[k / <span class="number">2</span>]] &gt; data[index[k]]) &#123;</span><br><span class="line">			swap(index[k / <span class="number">2</span>], index[k]);</span><br><span class="line">			reverse[index[k / <span class="number">2</span>]] = k / <span class="number">2</span>;</span><br><span class="line">			reverse[index[k]] = k;</span><br><span class="line">			k /= <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">shiftDown</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (<span class="number">2</span> * k &lt;= count - <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> j = <span class="number">2</span> * k;</span><br><span class="line">			<span class="keyword">if</span> (j + <span class="number">1</span> &lt;= count - <span class="number">1</span> &amp;&amp; data[index[j + <span class="number">1</span>]] &lt; data[index[j]]) j++;</span><br><span class="line">			<span class="keyword">if</span> (data[index[k]] &lt;= data[index[j]]) <span class="keyword">break</span>;</span><br><span class="line">			swap(index[k], index[j]);</span><br><span class="line">			reverse[index[k]] = k;</span><br><span class="line">			reverse[index[j]] = j;</span><br><span class="line">			k = j;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//查看索引i这个位置的元素是否在堆中</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isInHeap</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">		assert(i &gt;= <span class="number">0</span> &amp;&amp; i &lt; capacity);<span class="comment">//首先i这个元素不能超过data中存储元素的个数</span></span><br><span class="line">		<span class="keyword">return</span> reverse[i] != <span class="number">-1</span>; <span class="comment">// = -1表示这个元素不在堆中</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 构造函数, 构造一个空堆, 可容纳capacity个元素</span></span><br><span class="line">	IndexMinHeap(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">		data = <span class="keyword">new</span> Item[capacity];</span><br><span class="line">		index = <span class="keyword">new</span> <span class="keyword">int</span>[capacity];</span><br><span class="line">		reverse = <span class="keyword">new</span> <span class="keyword">int</span>[capacity];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; capacity; i++) &#123;</span><br><span class="line">			reverse[i] = <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 构造函数, 通过一个给定数组创建一个最小堆</span></span><br><span class="line">	<span class="comment">// 该构造堆的过程, 时间复杂度为O(n)</span></span><br><span class="line">	IndexMinHeap(Item arr[], <span class="keyword">int</span> n) &#123;</span><br><span class="line">		data = <span class="keyword">new</span> Item[n];</span><br><span class="line">		index = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">		capacity = n;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			data[i] = arr[i];</span><br><span class="line">			index[i] = i;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		count = n;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = count - <span class="number">1</span> / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">			shiftDown(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~IndexMinHeap() &#123;</span><br><span class="line">		<span class="keyword">delete</span>[] data;</span><br><span class="line">		<span class="keyword">delete</span>[] index;</span><br><span class="line">		<span class="keyword">delete</span>[] reverse;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回堆中的元素个数</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回一个布尔值, 表示堆中是否为空</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 向最小堆中插入一个新的元素 item  i是用户角度data的位置</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> i, Item item)</span> </span>&#123;</span><br><span class="line">		assert(count &lt; capacity);</span><br><span class="line">		assert(i &gt;= <span class="number">0</span> &amp;&amp; i &lt; capacity);</span><br><span class="line">		data[i] = item;</span><br><span class="line">		index[count] = i;</span><br><span class="line">		reverse[i] = count;</span><br><span class="line">		shiftUp(count);</span><br><span class="line">		count++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从最小堆中取出堆顶元素, 即堆中所存储的最小数据</span></span><br><span class="line">	<span class="function">Item <span class="title">extractMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		assert(count &gt; <span class="number">0</span>);</span><br><span class="line">		Item ret = data[index[<span class="number">0</span>]];</span><br><span class="line">		swap(index[<span class="number">0</span>], index[count - <span class="number">1</span>]);</span><br><span class="line">		reverse[index[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">		reverse[index[count - <span class="number">1</span>]] = <span class="number">-1</span>;</span><br><span class="line">		count--;</span><br><span class="line">		shiftDown(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取最小堆堆顶元素的在data中存储的索引，同时删除堆顶元素</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">extracIndexMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		assert(count &gt; <span class="number">0</span>);</span><br><span class="line">		Item ret = index[<span class="number">0</span>];</span><br><span class="line">		swap(index[<span class="number">0</span>], index[count - <span class="number">1</span>]);</span><br><span class="line">		reverse[index[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">		reverse[index[count - <span class="number">1</span>]] = <span class="number">-1</span>;</span><br><span class="line">		count--;</span><br><span class="line">		shiftDown(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取最小堆中的堆顶元素</span></span><br><span class="line">	<span class="function">Item <span class="title">getMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		assert(count &gt; <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> data[index[<span class="number">0</span>]];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取最小堆堆顶的索引</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getMaxIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		assert(count &gt; <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> index[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取最小索引堆中索引为i的元素</span></span><br><span class="line">	<span class="function">Item <span class="title">getItem</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">		assert(isInHeap(i));</span><br><span class="line">		<span class="keyword">return</span> data[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将最小索引堆中索引为i的元素修改为newItem</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> i, Item newItem)</span> </span>&#123;</span><br><span class="line">		assert(isInHeap(i));</span><br><span class="line">		data[i] = newItem;</span><br><span class="line">		<span class="comment">// 找到indexes[j] = i, j表示data[i]在堆中的位置</span></span><br><span class="line">		<span class="comment">// 之后shiftUp(j), 再shiftDown(j)</span></span><br><span class="line">		<span class="comment">/*for (int j = 0; j &lt; count; j++) &#123;</span></span><br><span class="line"><span class="comment">			if (index[j] = i) &#123;</span></span><br><span class="line"><span class="comment">				shiftUp(j);</span></span><br><span class="line"><span class="comment">				shiftDown(j);</span></span><br><span class="line"><span class="comment">				break;</span></span><br><span class="line"><span class="comment">			&#125;</span></span><br><span class="line"><span class="comment">		&#125;*/</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> j = reverse[i];</span><br><span class="line">		shiftUp(j);</span><br><span class="line">		shiftDown(j);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 看索引i所在的位置是否存在元素</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">contain</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> reverse[index ] != <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h3><h4 id="切分定理"><a href="#切分定理" class="headerlink" title="切分定理"></a>切分定理</h4><p>把图中的结点分为两部分,成为一个<strong>切分(Cut)</strong></p>
<p>如果一个边的两个端点，属于切分(Cut)不同的两边，这个边称为<strong>横切边(CrossingEdge)</strong></p>
<p><strong>切分定理:</strong> 给定<em>任意</em>切分，横切边中权值最小的边必然属于最小生成树。</p>
<p><img src="/2022/01/26/C++/c++algo/202202282232078.png" alt="image-20220228223210045"></p>
<p><img src="/2022/01/26/C++/c++algo/image-20220922202627813.png" alt="image-20220922202627813"></p>
<h4 id="Lazy-Prim"><a href="#Lazy-Prim" class="headerlink" title="Lazy Prim"></a>Lazy Prim</h4><blockquote>
<p>时间复杂度O(ElogE)  需要遍历每条边(E)，每条边都需要插入堆和取出堆(logE)</p>
</blockquote>
<ul>
<li>用一个最小堆维护权值</li>
<li>从0开始，将与0相连的所有边加入堆中，此时堆顶就是横切边中最短的边，即0-7：0.16</li>
<li>再将与7相连的所有边加入堆中（加入不重复，判断边的另一个点是否已经访问），拿到堆顶元素1-7：0.19</li>
<li>再将与1相连的所有边加入堆中，，，，，</li>
<li>当将与2相连的所有边加入堆中后，会发现1-2、2-7这两条边并不是横切边<ul>
<li>这就是Lazy的部分，不是横切边，但仍然放在堆中</li>
<li>当堆顶元素就是这个不是横切边的边时，就判断边的两个端点是否在同一个切分中，如果是则在堆中将其删除，再拿到堆顶元素，做同样的判断，直到堆顶元素是横切边</li>
</ul>
</li>
</ul>
<p><img src="/2022/01/26/C++/c++algo/202203012026674.png" alt="image-20220301202614156"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Edge.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MinHeap.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//LazyPrim算法实现最小生成树</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Graph , <span class="keyword">typename</span> Weight&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LazyPrimMST</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Graph&amp; g; <span class="comment">//带权图</span></span><br><span class="line">	MinHeap&lt;Edge&lt;Weight&gt;&gt; mp;<span class="comment">//最小堆 </span></span><br><span class="line">	<span class="keyword">bool</span>* marked;   <span class="comment">//记录点是否已访问</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;Edge&lt;Weight&gt;&gt; mst;<span class="comment">// 记录最小生成树的权值</span></span><br><span class="line">	Weight minWt;  <span class="comment">//最小生成树的权值和</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//访问一个图中的一个顶点，将其边加入堆中</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">		assert(!marked[v]);<span class="comment">//当前顶点没有访问过</span></span><br><span class="line">		marked[v] = <span class="literal">true</span>; <span class="comment">//访问该点</span></span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">typename</span> Graph::adjIterator <span class="title">adj</span><span class="params">(g, v)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (Edge&lt;Weight&gt;* i = adj.<span class="built_in">begin</span>(); !adj.<span class="built_in">end</span>(); i = adj.next())<span class="comment">//拿到与v相连的每一条边</span></span><br><span class="line">			<span class="keyword">if</span> (!marked[i-&gt;other(v)])<span class="comment">//该边没有被加入过则加入堆中</span></span><br><span class="line">				mp.insert(*i);  <span class="comment">//复杂度是O(loge)</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	LazyPrimMST(Graph&amp; g) :g(g), mp(MinHeap&lt;Edge&lt;Weight&gt;&gt;(g.getE())) &#123;</span><br><span class="line">		marked = <span class="keyword">new</span> <span class="keyword">bool</span>[g.getV()];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.getV(); i++) &#123;</span><br><span class="line">			marked[i] = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		mst.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">		visit(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">while</span> (!mp.isEmpty()) &#123;</span><br><span class="line">			Edge&lt;Weight&gt; e = mp.extractMin();<span class="comment">//取出堆顶元素  这一步的时间复杂度是O(loge) e是插入堆中的元素个数</span></span><br><span class="line">			<span class="keyword">if</span> (marked[e.getv()] == marked[e.getw()]) <span class="comment">//如果边的两个端点在同一个切分中则跳过，该边不是横切边</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			mst.push_back(e);<span class="comment">//找到了最小生成树的一条横切边，并加入最小生成树</span></span><br><span class="line">			<span class="keyword">if</span> (!marked[e.getv()])</span><br><span class="line">				visit(e.getv());</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				visit(e.getw());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		minWt = mst[<span class="number">0</span>].getWt();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; mst.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">			minWt += mst[i].getWt();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~LazyPrimMST() &#123;</span><br><span class="line">		<span class="keyword">delete</span>[] marked;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//返回最小生成树</span></span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;Edge&lt;Weight&gt;&gt; <span class="title">getMST</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> mst;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取最小生成树的权值和</span></span><br><span class="line">	<span class="function">Weight <span class="title">getMinWt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> minWt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>









<h4 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h4><blockquote>
<p>时间复杂度O(ElogV)  考察了每条边(E), 最小索引堆相较LazyPrim变小了，最多存储顶点个数(logV)</p>
</blockquote>
<ul>
<li>利用最小索引堆来维护权值<ul>
<li>最小索引堆中data[i]存储的是到达 i 这个点最短的边(已经访问的边中到达该点最短的边)的权值，</li>
</ul>
</li>
<li>从0开始，将0的所有边加入最小索引堆，此时堆顶就是横切边中最短的边，即0-7：0.16</li>
<li>再考察与7相连的所有边，判断边的另一端的点是否已访问，若已访问则不加入，若未访问则需要判断是否已经有边到达该点，若没有则直接插入，若已经有则判断当前的边的权值是否小于已经有的到达该点的边的权值，若小于则覆盖，否则不修改<ul>
<li>对于0-7，因为0已经访问不加入</li>
<li>对于2-7，已经有边0-2：0.26到达2， 2-7：0.34的权值大于0-2：0.26 所以data[2]的值保持不变</li>
<li>对于4-7，已经有边0-4：0.38到达4， 4-7：0.37的权值小于0-4：0.38 所以data[4]的修改为0.37</li>
<li>按以上规则考察与7相连的所有边后，取出堆顶元素：7-1：0.19</li>
</ul>
</li>
<li>再考察与1相连的所有边，，，，，</li>
</ul>
<p><img src="/2022/01/26/C++/c++algo/202203012214278.png" alt="image-20220301221448922"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Edge.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"IndexMinHeap.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Prim算法实现最小生成树</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Graph, <span class="keyword">typename</span> Weight&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimMST</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Graph&amp; g; <span class="comment">//带权图</span></span><br><span class="line">	IndexMinHeap&lt;Weight&gt; imp;<span class="comment">//最小堆 存储的是权值</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;Edge&lt;Weight&gt;*&gt; edgeTo;<span class="comment">//已经加入堆中的边</span></span><br><span class="line">	<span class="keyword">bool</span>* marked;   <span class="comment">//记录点是否已访问</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;Edge&lt;Weight&gt;&gt; mst;<span class="comment">// 记录最小生成树的权值</span></span><br><span class="line">	Weight minWt;  <span class="comment">//最小生成树的权值和</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//访问一个图中的一个顶点，将其边加入堆中</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">		assert(!marked[v]);<span class="comment">//当前顶点没有访问过</span></span><br><span class="line">		marked[v] = <span class="literal">true</span>; <span class="comment">//访问该点</span></span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">typename</span> Graph::adjIterator <span class="title">adj</span><span class="params">(g, v)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (Edge&lt;Weight&gt;* i = adj.<span class="built_in">begin</span>(); !adj.<span class="built_in">end</span>(); i = adj.next()) &#123;<span class="comment">//拿到与v相连的每一条边</span></span><br><span class="line">			<span class="keyword">int</span> w = i-&gt;other(v);</span><br><span class="line">			<span class="keyword">if</span> (!marked[w]) &#123;<span class="comment">//该边的另一个顶点没有被考察过</span></span><br><span class="line">				<span class="keyword">if</span> (!edgeTo[w]) &#123; <span class="comment">//不存在已经有到达w的边</span></span><br><span class="line">					imp.insert(w, i-&gt;getWt());  <span class="comment">//复杂度是O(loge)</span></span><br><span class="line">					edgeTo[w] = i;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (i-&gt;getWt() &lt; edgeTo[w]-&gt;getWt())</span><br><span class="line">				&#123;<span class="comment">//已经存在达到w的边，此时i的边也到达w，若i边的权值小于原来已经存在的边的权值，则覆盖原来的边</span></span><br><span class="line">					imp.change(w, i-&gt;getWt());</span><br><span class="line">					edgeTo[w] = i;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	PrimMST(Graph&amp; g) :g(g), imp(IndexMinHeap&lt;Weight&gt;(g.getV())) &#123;</span><br><span class="line">		marked = <span class="keyword">new</span> <span class="keyword">bool</span>[g.getV()];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.getV(); i++) &#123;</span><br><span class="line">			marked[i] = <span class="literal">false</span>;</span><br><span class="line">			edgeTo.push_back(<span class="literal">NULL</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		mst.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">		visit(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">while</span> (!imp.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> v = imp.extracIndexMin();<span class="comment">//取出堆顶元素在data中存储的索引 即最小横切边中还未访问的一端的顶点  这一步的时间复杂度是O(loge) e是插入堆中的元素个数</span></span><br><span class="line">			assert(edgeTo[v]);</span><br><span class="line">			mst.push_back(*edgeTo[v]);<span class="comment">//找到了最小生成树的一条横切边，并加入最小生成树</span></span><br><span class="line">			</span><br><span class="line">			visit(v);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		minWt = mst[<span class="number">0</span>].getWt();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; mst.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">			minWt += mst[i].getWt();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~PrimMST() &#123;</span><br><span class="line">		<span class="keyword">delete</span>[] marked;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//返回最小生成树</span></span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;Edge&lt;Weight&gt;&gt; <span class="title">getMST</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> mst;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取最小生成树的权值和</span></span><br><span class="line">	<span class="function">Weight <span class="title">getMinWt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> minWt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h3><blockquote>
<p>效率： LazyPrim &lt; kruskal算法 &lt; Prim算法</p>
<p>时间复杂度O(ElogE)</p>
</blockquote>
<ul>
<li>先将所有的边排序  时间复杂度O(ElogE) ，用最小堆排序，便于拿到每个点 <ul>
<li>插入和获取堆顶元素时间复杂度都是O(logE), 遍历每条边时间复杂度O(E)</li>
<li>使用基于find优化的路径压缩的并查集，非递归版</li>
</ul>
</li>
<li>从最小边开始考察，若这条边加入不使得形成环，则这条边一定是最小生成树的一条边<ul>
<li>用并查集来判断边的加入是否形成环，若边的两点是可达的，则说明这条边的加入会形成环</li>
<li>并查集的时间复杂度为O(logV), 每条边都要考察，所以总时间复杂度O(ElogV)</li>
</ul>
</li>
</ul>
<p><img src="/2022/01/26/C++/c++algo/202203032049395.png" alt="image-20220303204948079"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"UF.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Edge.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MinHeap.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Graph, <span class="keyword">typename</span> Weight&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KruskalMST</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">vector</span>&lt;Edge&lt;Weight&gt;&gt; mst;<span class="comment">//存储最小生成树</span></span><br><span class="line">	Weight minWt;<span class="comment">//最小生成树的权值和</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	KruskalMST(Graph&amp; g) &#123;</span><br><span class="line">		<span class="function">MinHeap&lt;Edge&lt;Weight&gt;&gt; <span class="title">mp</span><span class="params">(g.getE())</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.getV(); i++) &#123;</span><br><span class="line">			<span class="function"><span class="keyword">typename</span> Graph::adjIterator <span class="title">adj</span><span class="params">(g, i)</span></span>;</span><br><span class="line">			<span class="keyword">for</span> (Edge&lt;Weight&gt;* v = adj.<span class="built_in">begin</span>(); !adj.<span class="built_in">end</span>(); v = adj.next()) &#123;</span><br><span class="line">				<span class="keyword">if</span>(v-&gt;getv() &lt; v-&gt;getw())<span class="comment">//因为是无向图，会重复插入，所以在这里去重</span></span><br><span class="line">					mp.insert(*v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function">UnionFind <span class="title">uf</span><span class="params">(g.getV())</span></span>;</span><br><span class="line">		<span class="keyword">while</span> (!mp.isEmpty() &amp;&amp; mst.<span class="built_in">size</span>() &lt; g.getV()<span class="number">-1</span>) <span class="comment">//当mst中边的条数已经等于边数-1时可提前结束循环</span></span><br><span class="line">		&#123;</span><br><span class="line">			Edge&lt;Weight&gt; e = mp.extractMin();</span><br><span class="line">			<span class="keyword">if</span> (!uf.isConnected(e.getv(), e.getw())) &#123;<span class="comment">//该边不是环则加入最小生成树</span></span><br><span class="line">				mst.push_back(e);</span><br><span class="line">				uf.unionElements(e.getv(), e.getw());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		minWt = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mst.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">			minWt += mst[i].getWt();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~KruskalMST() &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//返回最小生成树的边</span></span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;Edge&lt;Weight&gt;&gt; <span class="title">getMST</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> mst;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//返回最小生成树的权值和</span></span><br><span class="line">	<span class="function">Weight <span class="title">getMinWt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> minWt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><blockquote>
<p>单源最短路径: 某一个点到图中任意一点的最短路径</p>
<p>本部分辅助类沿用最小生成树部分的辅助类</p>
</blockquote>
<h3 id="dijkstra算法"><a href="#dijkstra算法" class="headerlink" title="dijkstra算法"></a>dijkstra算法</h3><blockquote>
<p>dijkstra算法: 解决单源最短路径</p>
<p>前提: 图中不能有负权边</p>
<p>时间复杂度O(E log(V) )</p>
</blockquote>
<p><img src="/2022/01/26/C++/c++algo/202203072251192.png" alt="image-20220307225117825"></p>
<ul>
<li>使用最小索引堆选取下一个访问节点，最小索引堆存储已经访问的到达每个点的最短路径，堆顶元素的索引即是下一个要访问的点</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Weight* distTo; <span class="comment">//记录源点到每个点的最短路径值</span></span><br><span class="line"><span class="keyword">bool</span>* marked;   <span class="comment">//记录每个点的访问情况</span></span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&lt;Weight&gt;*&gt; from; <span class="comment">//记录最短路径中每个点的前驱节点</span></span><br><span class="line"><span class="function">IndexMinHeap&lt;Weight&gt; <span class="title">imh</span><span class="params">(g.getV())</span></span>; <span class="comment">// 使用索引堆记录当前找到的到达每个顶点的最短距离</span></span><br></pre></td></tr></table></figure>



<ul>
<li>从0开始，将0标记为已访问，将所有与0相连的边的权值加入堆中，并将1、2、3的前驱标记为0，并记录到达1、2、3的最短路径值分别为5、2、6，取出堆顶元素的索引2，即下一个访问的节点</li>
<li>从2开始<ul>
<li>将2标记为已访问</li>
<li>考察(2,1)边，因为(0,2)+(2,1)边的权值小于distTo[1]， 所以有如下操作，若没有小于则不操作<ul>
<li>因为distTo[1] = 5，值不为零，说明已经插入过堆中，所以使用最小堆的change方法，修改到达1的最短路径为3</li>
<li>distTo[1]更新为3</li>
<li>1的前驱节点更新为2</li>
</ul>
</li>
<li>考察（2，4）边，<ul>
<li>因为distTo[4] = 0，值为零，说明之前没有插入过堆中，直接插入</li>
<li>distTo[4]更新为7</li>
<li>4的前驱节点更新为2</li>
</ul>
</li>
<li>，，，，，</li>
</ul>
</li>
<li>关键步骤是<strong>松弛操作</strong><ul>
<li>只有当前点未被访问才进行松弛操作<ul>
<li>当前点未被访问，且之前没有赋值，则直接插入堆中</li>
<li>当前点未被访问，且之前有赋值，则比较当前值是否比以前小，如果小则更新堆中的数据</li>
</ul>
</li>
</ul>
</li>
<li>为什么松弛操作可以找到更短的路径<ul>
<li>为什么每次选堆顶元素，也就是路径最短的那个点作为下一个扩展点就是可以最终获得最短路劲</li>
<li>因为：如上图0到1的权值为5，而可以到1的不止0，还有2，也就是说存在一种可能：从0出发到2再到1可能权值更小，同理如果还有多个点也可以到1，则可能存在从0到这些点再到1路径更短，而应该选择哪个点到1最有可能路径最短呢？<strong>那一定是与1相连的点中路径最短的那个点也就是堆顶的那个点</strong>，由此反推，从0出发时，每次选路径最短的那个点扩展</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"IndexMinHeap.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Edge.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Graph, <span class="keyword">typename</span> Weight&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dijkstra</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Graph&amp; g;</span><br><span class="line">	<span class="keyword">int</span> s;  <span class="comment">//源点</span></span><br><span class="line">	Weight* distTo; <span class="comment">//记录源点到每个点的最短路径值</span></span><br><span class="line">	<span class="keyword">bool</span>* marked;<span class="comment">//记录每个点的访问情况</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;Edge&lt;Weight&gt;* &gt; from; <span class="comment">//记录最短路径中每个点的前驱节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Dijkstra(Graph&amp; g, <span class="keyword">int</span> s) :g(g) &#123;</span><br><span class="line">		assert(s &gt;= <span class="number">0</span> &amp;&amp; s &lt; g.getV());</span><br><span class="line">		<span class="keyword">this</span>-&gt;s = s;</span><br><span class="line">		distTo = <span class="keyword">new</span> Weight[g.getV()];</span><br><span class="line">		marked = <span class="keyword">new</span> <span class="keyword">bool</span>[g.getV()];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.getV(); i++) &#123;</span><br><span class="line">			distTo[i] = Weight();<span class="comment">//Weight为int的化，则都初始化为0</span></span><br><span class="line">			marked[i] = <span class="literal">false</span>;</span><br><span class="line">			from.push_back(<span class="literal">NULL</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 使用索引堆记录当前找到的到达每个顶点的最短距离</span></span><br><span class="line">		<span class="function">IndexMinHeap&lt;Weight&gt; <span class="title">imh</span><span class="params">(g.getV())</span></span>;</span><br><span class="line">		imh.insert(s, distTo[s]);</span><br><span class="line">		<span class="keyword">while</span> (!imh.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> cur_id = imh.extracIndexMin();<span class="comment">//获取堆顶元素的索引，即下一个要访问的点</span></span><br><span class="line">			<span class="function"><span class="keyword">typename</span> Graph::adjIterator <span class="title">adj</span><span class="params">(g, cur_id)</span></span>;</span><br><span class="line">			marked[cur_id] = <span class="literal">true</span>;</span><br><span class="line">			<span class="comment">//cout &lt;&lt; "marked[cur_id]: "&lt;&lt;marked[cur_id] &lt;&lt; endl;</span></span><br><span class="line">			<span class="keyword">for</span> (Edge&lt;Weight&gt;* e = adj.<span class="built_in">begin</span>(); !adj.<span class="built_in">end</span>(); e = adj.next()) &#123;</span><br><span class="line">				<span class="keyword">int</span> v = e-&gt;other(cur_id);</span><br><span class="line">				Weight wt = e-&gt;getWt();</span><br><span class="line"></span><br><span class="line">				<span class="comment">//松弛操作  </span></span><br><span class="line">				<span class="keyword">if</span> (!marked[v]) &#123;<span class="comment">//该点还未访问</span></span><br><span class="line">					<span class="keyword">if</span> (from[v] == <span class="literal">NULL</span> ) &#123;</span><br><span class="line">						distTo[v] = distTo[cur_id] + wt;</span><br><span class="line">						from[v] = e;</span><br><span class="line">						imh.insert(v, distTo[v]);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> (distTo[cur_id] + wt &lt; distTo[v]) &#123;</span><br><span class="line">						distTo[v] = distTo[cur_id] + wt;</span><br><span class="line">						from[v] = e;</span><br><span class="line">						imh.change(v, distTo[v]);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;		</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~Dijkstra() &#123;</span><br><span class="line">		<span class="keyword">delete</span>[] distTo;</span><br><span class="line">		<span class="keyword">delete</span>[] marked;</span><br><span class="line">		<span class="comment">//delete from[0];</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回从s点到w点的最短路径长度</span></span><br><span class="line">	<span class="function">Weight <span class="title">shortestPathTo</span><span class="params">(<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">		assert(w &gt;= <span class="number">0</span> &amp;&amp; w &lt; g.getV());</span><br><span class="line">		assert(hasPathTo(w));</span><br><span class="line">		<span class="keyword">return</span> distTo[w];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断从s点到w点是否联通</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">hasPathTo</span><span class="params">(<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">		assert(w &gt;= <span class="number">0</span> &amp;&amp; w &lt; g.getV());</span><br><span class="line">		<span class="keyword">return</span> marked[w];</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 寻找从s到w的最短路径, 将整个路径经过的边存放在vec中</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">shortestPath</span><span class="params">(<span class="keyword">int</span> w, <span class="built_in">vector</span>&lt;Edge&lt;Weight&gt;&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">		assert(w &gt;= <span class="number">0</span> &amp;&amp; w &lt; g.getV());</span><br><span class="line">		assert(hasPathTo(w));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 通过from数组逆向查找到从s到w的路径, 存放到栈中</span></span><br><span class="line">		<span class="built_in">stack</span>&lt;Edge&lt;Weight&gt;*&gt; s;</span><br><span class="line">		<span class="keyword">while</span> (from[w]) &#123;</span><br><span class="line">			s.push(from[w]);</span><br><span class="line">			w = from[w]-&gt;other(w);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 从栈中依次取出元素, 获得顺序的从s到w的路径</span></span><br><span class="line">		<span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">			vec.push_back(*s.top());</span><br><span class="line">			s.pop();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打印出从s点到w点的路径</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">showPath</span><span class="params">(<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">		assert(w &gt;= <span class="number">0</span> &amp;&amp; w &lt; g.getV());</span><br><span class="line">		assert(hasPathTo(w));</span><br><span class="line"></span><br><span class="line">		<span class="built_in">vector</span>&lt;Edge&lt;Weight&gt;&gt; vec;</span><br><span class="line">		shortestPath(w, vec);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; vec[i].getv() &lt;&lt; <span class="string">"--&gt;"</span>;</span><br><span class="line">			<span class="keyword">if</span> (i == vec.<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; vec[i].getw() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman-Ford算法"></a>Bellman-Ford算法</h3><blockquote>
<p>Bellman-Ford算法：解决有负权边的单源最短路径</p>
<p>前提：图中不能有负权环</p>
<p>时间复杂度：O(EV)</p>
<p>一般用于处理有向图，因为无向图中只要存在一条负权边就一定形成了负权环</p>
</blockquote>
<p><strong>负权环</strong></p>
<ul>
<li>0–1–2  三点之间就构成了负权环（这三个点构成环，且环的所有边的权值之和为负值），当有负权环时，则不存在最短路径，因为只要一直走这个环，路径会越来越小，直至负无穷</li>
<li>1–2 两点之间也够成了负权环</li>
<li>0–2 两点之间也够成了负权环</li>
</ul>
<p><img src="/2022/01/26/C++/c++algo/202203092259286.png" alt="image-20220309225840814"></p>
<p><strong>判断图中是否有负权环</strong></p>
<ul>
<li>假设一个图没有负权环</li>
<li>从一点到另外一点的最短路径，最多经过所有的V个顶点，有V-1条边</li>
<li>否则（经过了大于v个顶点），存在顶点经过了两次，既存在负权环，与假设矛盾</li>
<li>所以只要经过的点大于v个顶点则判断图中有负权环，不可能存在最短路径，直接结束查找</li>
</ul>
<p><strong>松弛操作</strong></p>
<ul>
<li>核心思想：从一个点出发，通过另外一个点到达本来要到达的点的路径可能比直接到达更短</li>
</ul>
<p><strong>前提思考</strong></p>
<ul>
<li>对一个点的一次松弛操作，就是找到经过这个点的另外一条路径，多一条边，权值更小。</li>
<li>如果一个图没有负权环，从一点到另外一点的最短路径,最多经过所有的V个顶线，有V-1条边</li>
<li>对所有的点进行V-1次松弛操作</li>
</ul>
<p><strong>Bellman-Ford算法思想</strong></p>
<ul>
<li>对所有的点进行V-1次松弛操作，理论上就找到了从源点到其他所有点的最短路径。</li>
<li>如果还可以继续松弛(V次及V次以上)，说明原图中有负权环。</li>
<li>算法核心步骤如下:</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进行第v次松弛操作，若此次操作仍然可以缩短路径，则一定存在负权环</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">detectNegativeCycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.getV(); i++) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">typename</span> Graph::adjIterator <span class="title">adj</span><span class="params">(g, i)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (Edge&lt;Weight&gt;* e = adj.<span class="built_in">begin</span>(); !adj.<span class="built_in">end</span>(); e = adj.next()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (from[e-&gt;getw()] == <span class="literal">NULL</span> || distTo[e-&gt;getv()] + e-&gt;getWt() &lt; distTo[e-&gt;getw()]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//不存在负权环</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//对每个顶点进行v-1次松弛操作</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> pass = <span class="number">1</span>; pass &lt; g.getV(); pass++) &#123;</span><br><span class="line">    <span class="comment">//对每个点进行松弛操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.getV(); i++) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">typename</span> Graph::adjIterator <span class="title">adj</span><span class="params">(g, i)</span></span>;</span><br><span class="line">        <span class="comment">//考察i这个点的所有出度边</span></span><br><span class="line">        <span class="keyword">for</span> (Edge&lt;Weight&gt;* e = adj.<span class="built_in">begin</span>(); !adj.<span class="built_in">end</span>(); e = adj.next()) &#123;</span><br><span class="line">            <span class="comment">// 对于每一个边首先判断e-&gt;v()可达，也就是e-&gt;v()访问过，也确保只能从源点开始，因为一开始只有源点的from[s]初始化了，满足条件</span></span><br><span class="line">            <span class="comment">// 之后看如果e-&gt;w()以前没有到达过， 显然我们可以更新distTo[e-&gt;w()]</span></span><br><span class="line">            <span class="comment">//若已经记录的源点到达i点的最短距离(distTo[e-&gt;getv()])加上出度边的权值(e-&gt;getWt())</span></span><br><span class="line">            <span class="comment">//小于源点到这条出度边的终点的距离则松弛有效</span></span><br><span class="line">            <span class="keyword">if</span> (from[e-&gt;getv()] &amp;&amp; (from[e-&gt;getw()] == <span class="literal">NULL</span> || distTo[e-&gt;getv()] + e-&gt;getWt() &lt; distTo[e-&gt;getw()])） &#123;</span><br><span class="line">                distTo[e-&gt;getw()] = distTo[e-&gt;getv()] + e-&gt;getWt();<span class="comment">//e.getv()是起点，e.getw()是终点</span></span><br><span class="line">                from[e-&gt;getw()] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">                </span><br><span class="line">hasNegativeCycle = detectNegativeCycle();</span><br></pre></td></tr></table></figure>

<ul>
<li>可以理解为从源点出发的层序遍历，第一次松弛操作只更新了距离源点为1的点，第二次更新了距离源点为2的点，，，，</li>
<li>下图是特殊情况，因为源点正好是0, 而编程中也是选择的从序号最小的点开始扩展，所以等到扩展序号大的点时，一定保证了他的前继节点已经更新了到源点的最短距离，所以一轮松弛操作就可以得到最终结果</li>
<li>对每个点都需要进行v-1次松弛操作的原因：源点可能不是正好是0，如果是比较大的点，按编程中的的扩展顺序，当扩展0的时候0的前继节点可能还没更新，所以0在第一次松弛操作时就没有得到扩展，同理，只要比源点小的点都存在这个问题</li>
<li>为什么第v次松弛操作时有点没有更新(<code>from[e-&gt;getw()] == NULL</code>)也可以判定有负权环：因为有负权环的存在，会导致每次松弛操作一直在环中进行，不会继续扩展到下一个节点，所以到v次扩展仍然有点没有访问到，反过来就可以判断有负权环</li>
</ul>
<p><img src="/2022/01/26/C++/c++algo/202203102222665.png" alt="image-20220310222210117"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">上图的执行结果</span><br><span class="line">bellmanford:</span><br><span class="line">0 -&gt; 0</span><br><span class="line">shortestPathTo:0-&gt;0 : 0</span><br><span class="line">0 -&gt; 1</span><br><span class="line">shortestPathTo:0-&gt;1 : 5</span><br><span class="line">0 -&gt; 1 -&gt; 2</span><br><span class="line">shortestPathTo:0-&gt;2 : 1</span><br><span class="line">0 -&gt; 1 -&gt; 2 -&gt; 4 -&gt; 3</span><br><span class="line">shortestPathTo:0-&gt;3 : 3</span><br><span class="line">0 -&gt; 1 -&gt; 2 -&gt; 4</span><br><span class="line">shortestPathTo:0-&gt;4 : 6</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Edge.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Graph, <span class="keyword">typename</span> Weight&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BellmanFord</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Graph&amp; g;                   <span class="comment">//图</span></span><br><span class="line">	<span class="keyword">int</span> s;                      <span class="comment">//源点</span></span><br><span class="line">	Weight* distTo;             <span class="comment">// distTo[i]存储从起始点s到i的最短路径长度</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;Edge&lt;Weight&gt;*&gt; from; <span class="comment">// from[i]记录最短路径中, 到达i点的边是哪一条</span></span><br><span class="line">								<span class="comment">// 可以用来恢复整个最短路径</span></span><br><span class="line">	<span class="keyword">bool</span> hasNegativeCycle;      <span class="comment">// 标记图中是否有负权环</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//进行第v次松弛操作，若此次操作仍然可以缩短路径，则一定存在负权环</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">detectNegativeCycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.getV(); i++) &#123;</span><br><span class="line">            <span class="function"><span class="keyword">typename</span> Graph::adjIterator <span class="title">adj</span><span class="params">(g, i)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (Edge&lt;Weight&gt;* e = adj.<span class="built_in">begin</span>(); !adj.<span class="built_in">end</span>(); e = adj.next()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (from[e-&gt;getw()] == <span class="literal">NULL</span> || distTo[e-&gt;getv()] + e-&gt;getWt() &lt; distTo[e-&gt;getw()]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//不存在负权环</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	BellmanFord(Graph&amp; g, <span class="keyword">int</span> s) :g(g) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;s = s;</span><br><span class="line">		distTo = <span class="keyword">new</span> Weight[g.getV()];</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.getV(); i++) &#123;</span><br><span class="line">			from.push_back(<span class="literal">NULL</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		distTo[s] = Weight();<span class="comment">//初始化，如果Weight为int型，则初始化为0</span></span><br><span class="line">		from[s] = <span class="keyword">new</span> Edge&lt;Weight&gt;(s, s, Weight());<span class="comment">//初始化为一条s指向s的权值为0的边</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//对每个顶点进行v-1次松弛操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> pass = <span class="number">1</span>; pass &lt; g.getV(); pass++) &#123;</span><br><span class="line">            <span class="comment">//对每个点进行松弛操作</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.getV(); i++) &#123;</span><br><span class="line">                <span class="function"><span class="keyword">typename</span> Graph::adjIterator <span class="title">adj</span><span class="params">(g, i)</span></span>;</span><br><span class="line">                <span class="keyword">for</span> (Edge&lt;Weight&gt;* e = adj.<span class="built_in">begin</span>(); !adj.<span class="built_in">end</span>(); e = adj.next()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (from[e-&gt;getv()] &amp;&amp; (from[e-&gt;getw()] == <span class="literal">NULL</span> || distTo[e-&gt;getv()] + e-&gt;getWt() &lt; distTo[e-&gt;getw()])) &#123;</span><br><span class="line">                        distTo[e-&gt;getw()] = distTo[e-&gt;getv()] + e-&gt;getWt();<span class="comment">//e.getv()是起点，e.getw()是终点</span></span><br><span class="line">                        from[e-&gt;getw()] = e;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        hasNegativeCycle = detectNegativeCycle();</span><br><span class="line">       <span class="comment">//hasNegativeCycle = false;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	~BellmanFord() &#123;</span><br><span class="line">		<span class="keyword">delete</span>[] distTo;</span><br><span class="line">		<span class="keyword">delete</span> from[s];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回图中是否有负权环</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">negativeCycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hasNegativeCycle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回从s点到w点的最短路径长度</span></span><br><span class="line">    <span class="function">Weight <span class="title">shortestPathTo</span><span class="params">(<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        assert(w &gt;= <span class="number">0</span> &amp;&amp; w &lt; g.getV());</span><br><span class="line">        assert(!hasNegativeCycle);</span><br><span class="line">        assert(hasPathTo(w));</span><br><span class="line">        <span class="keyword">return</span> distTo[w];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断从s点到w点是否联通</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathTo</span><span class="params">(<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        assert(w &gt;= <span class="number">0</span> &amp;&amp; w &lt; g.getV());</span><br><span class="line">        <span class="keyword">return</span> from[w] != <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找从s到w的最短路径, 将整个路径经过的边存放在vec中</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shortestPath</span><span class="params">(<span class="keyword">int</span> w, <span class="built_in">vector</span>&lt;Edge&lt;Weight&gt;&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        assert(w &gt;= <span class="number">0</span> &amp;&amp; w &lt; g.getV());</span><br><span class="line">        assert(!hasNegativeCycle);</span><br><span class="line">        assert(hasPathTo(w));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过from数组逆向查找到从s到w的路径, 存放到栈中</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;Edge&lt;Weight&gt;*&gt; s;</span><br><span class="line">        Edge&lt;Weight&gt;* e = from[w];</span><br><span class="line">        <span class="keyword">while</span> (e-&gt;getv() != <span class="keyword">this</span>-&gt;s) &#123;</span><br><span class="line">            s.push(e);</span><br><span class="line">            e = from[e-&gt;getv()];<span class="comment">//如果是有向图，e-&gt;getv()就恰好是起点</span></span><br><span class="line">        &#125;</span><br><span class="line">        s.push(e);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从栈中依次取出元素, 获得顺序的从s到w的路径</span></span><br><span class="line">        <span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">            e = s.top();</span><br><span class="line">            vec.push_back(*e);</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印出从s点到w点的路径</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPath</span><span class="params">(<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        assert(w &gt;= <span class="number">0</span> &amp;&amp; w &lt; g.getV());</span><br><span class="line">        assert(!hasNegativeCycle);</span><br><span class="line">        assert(hasPathTo(w));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;Edge&lt;Weight&gt;&gt; vec;</span><br><span class="line">        shortestPath(w, vec);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; vec[i].getv() &lt;&lt; <span class="string">" -&gt; "</span>;</span><br><span class="line">            <span class="keyword">if</span> (i == vec.<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; vec[i].getw() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p><strong>单源最短路径算法：</strong></p>
<p><img src="/2022/01/26/C++/c++algo/202203102336420.png" alt="image-20220310233643686"></p>
<p><strong>所有对最短路径算法：</strong></p>
<blockquote>
<p>计算任意两个点之间的最短路径</p>
</blockquote>
<p>Floyed算法，处理无负权环的图， 时间复杂度O( V^3 )，动态规划思想</p>
<p><strong>最长路径算法</strong></p>
<ul>
<li>最长路径问题不能有正权环。</li>
<li>无权图的最长路径问题是指数级难度的。</li>
<li>对于有权图，不能使用Dijkstra求最长路径问题。可以使用Bellman-Ford算法（把权值取负就可以直接使用该算法了）。</li>
</ul>
<h2 id="字典树（Trie树）"><a href="#字典树（Trie树）" class="headerlink" title="字典树（Trie树）"></a>字典树（Trie树）</h2><blockquote>
<p><a href="https://www.cnblogs.com/inchbyinch/p/12588323.html" target="_blank" rel="noopener">https://www.cnblogs.com/inchbyinch/p/12588323.html</a></p>
<p>208 <a href="https://leetcode.cn/problems/implement-trie-prefix-tree/" target="_blank" rel="noopener">实现 Trie (前缀树)</a></p>
</blockquote>
<h1 id="二"><a href="#二" class="headerlink" title="二"></a>二</h1><p>对一-组数据进行排序<br>这组数据有什么样的特征?</p>
<ul>
<li>有没有可能包含有大量重复的元素?</li>
<li>如果有这种可能的话，三路快排是更好地选择。</li>
</ul>
<p>这组数据有什么样的特征?</p>
<ul>
<li>是否大部分数据距离它正确的位置很近?是否近乎有序?</li>
<li>如果是这样的话，插入排序是更好地选择。</li>
</ul>
<p>这组数据有什么样的特征?</p>
<ul>
<li>是否数据的取值范围非常有限?比如对学生成绩排序。</li>
<li>如果是这样的话，计数排序是更好地选择。</li>
</ul>
<p>对排序有什么额外的要求?</p>
<ul>
<li>是否需要稳定排序?</li>
<li>如果是的话，归并排序是更好地选择。</li>
</ul>
<p>数据的存储状况是怎样的?</p>
<ul>
<li>是否是使用链表存储的?</li>
<li>如果是的话，归并排序是更好地选择。</li>
</ul>
<p>数据的存储状况是怎样的?</p>
<ul>
<li>数据的大小是否可以装载在内存里?</li>
<li>数据量很大，或者内存很小，不足以装载在内存里，需要使用外排序算法。</li>
</ul>
<p>有没有可能包含有大量重复的元素?<br>是否大部分数据距离它正确的位置很近?是否近乎有序?<br>是否数据的取值范围非常有限?比如对学生成绩排序。<br>是否需要稳定排序?<br>是否是使用链表存储的?<br>数据的大小是否可以装载在内存里?</p>
<p>各种排序算法<br>基础数据结构和算法的实现:如堆、二叉树、图…<br>基础数据结构的使用:如链表、栈、队列、哈希表、图、Trie、 并查集…<br>基础算法:深度优先、广度优先、二分查找、递….<br>基本算法思想:递归、分治、回溯搜索、贪心、动态规划…</p>
<p>优化算法<br>遍历常见的算法思路<br>遍历常见的数据结构<br>空间和时间的交换(哈 希表)<br>预处理信息(排序)<br>在瓶颈处寻找答案: O(nlogn) + O(n^2) ; O(n^3)</p>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><blockquote>
<p>它将一个问题分解为<strong>互相重叠</strong>的子问题，通过反复求解子问题，来解决原来的问题</p>
<p>动态规划 VS 分而治之</p>
<ul>
<li>子问题是相互重叠的（例：斐波拉切数列） 则是动态规划</li>
<li>子问题是相互独立的（例：<a href="https://leetcode-cn.com/problems/invert-binary-tree/" target="_blank" rel="noopener">翻转二叉树</a>）则是分而治之</li>
</ul>
<p><strong>先画出树状图，看是否有重叠子问题，可以用递归的方式先思考，再换成动态规划的方式</strong></p>
<p>可以不用数值记录动态过程，直接用三个值记录并更新即可</p>
</blockquote>
<h3 id="专题"><a href="#专题" class="headerlink" title="专题"></a>专题</h3><blockquote>
<p>侯卫东三道例题：<a href="https://blog.csdn.net/weixin_44550963/article/details/107282087" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44550963/article/details/107282087</a></p>
</blockquote>
<ul>
<li><p>动态规划题目特点</p>
<ul>
<li><p>计数</p>
<ul>
<li>有多少种方式走到右下角</li>
<li>有多少种方法选出k个数使得和是Sum</li>
</ul>
</li>
<li><p>求最大最小值</p>
<ul>
<li>从左上角走到右下角路径的最大数字和</li>
<li>最长上升子序列长度</li>
</ul>
</li>
<li><p>求存在性</p>
<ul>
<li>取石子游戏，先手是否必胜</li>
<li>能不能选出k个数使得和是Sum</li>
</ul>
</li>
</ul>
</li>
<li><p>四个组成部分</p>
<ul>
<li>确定状态<ul>
<li>研究最优策略的最后一步<ul>
<li>化为子问题</li>
</ul>
</li>
</ul>
</li>
<li>转移方程<ul>
<li>根据子问题定义直接得到</li>
</ul>
</li>
<li>初始条件和边界情况<ul>
<li>细心，考虑周全</li>
</ul>
</li>
<li>计算顺序<ul>
<li>利用之前的计算结果</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="坐标型动态规划"><a href="#坐标型动态规划" class="headerlink" title="坐标型动态规划"></a><strong>坐标型动态规划</strong></h4><blockquote>
<p>加分项：打印路径  滚动数组</p>
</blockquote>
<ul>
<li>关于打印路径<ul>
<li>记录每个点是从哪里来的，再反向推回去就是最优路径</li>
</ul>
</li>
<li>题目（困难）</li>
</ul>
<p><img src="/2022/01/26/C++/c++algo/image-20221205210745076.png" alt="image-20221205210745076"></p>
<ul>
<li>拆分为上下左右四个方向单独考虑，每个方向采用动态规划计算<ul>
<li><code>up[i][j] = up[i-1][j] + 1 (a[i][j] = E) ||  up[i-1][j](a[i][j] = 0) || 0 (a[i][j] = W)</code></li>
<li>同理定义down、right、left</li>
<li>遍历若<code>a[i][j] = 0  则a[i][j] = up[i][j] + down[i][j] + right[i][j] + left[i][j]</code> 并更新最大值，最后返回</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; a)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> m = a.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">int</span> n = a[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">up</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>))</span></span>;</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">left</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>))</span></span>;</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">right</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>))</span></span>;</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">down</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>))</span></span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">      <span class="keyword">if</span>(a[i][j] == <span class="string">'w'</span>)&#123;</span><br><span class="line">        <span class="keyword">continue</span>; <span class="comment">// 默认为0</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(a[i][j] == <span class="string">'E'</span>)&#123;</span><br><span class="line">        up[i][j] = <span class="number">1</span>;</span><br><span class="line">        left[i][j] =<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(i &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        up[i][j] = up[i<span class="number">-1</span>][j] + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(j &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        left[i][j] = left[i][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = m<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = n<span class="number">-1</span>; j &gt;= <span class="number">0</span> ; --j)&#123;</span><br><span class="line">      <span class="keyword">if</span>(a[i][j] == <span class="string">'w'</span>)&#123;</span><br><span class="line">        <span class="keyword">continue</span>; <span class="comment">// 默认为0</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(a[i][j] == <span class="string">'E'</span>)&#123;  <span class="comment">//为0时本身就是0</span></span><br><span class="line">        down[i][j] = <span class="number">1</span>;</span><br><span class="line">        right[i][j] = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(i &lt; m<span class="number">-1</span>)&#123;</span><br><span class="line">        down[i][j] = down[i+<span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(j &lt; n<span class="number">-1</span>)&#123;</span><br><span class="line">        right[i][j] = right[i][j+<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">      <span class="keyword">if</span>(a[i][j] == <span class="string">'0'</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> t = up[i][j] + down[i][j] + right[i][j] + left[i][j];</span><br><span class="line">        res = <span class="built_in">max</span>(res, t);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="位操作型动态规划"><a href="#位操作型动态规划" class="headerlink" title="位操作型动态规划"></a><strong>位操作型动态规划</strong></h4><ul>
<li><code>f[i] = f[i&gt;&gt;1] + i%2</code><ul>
<li><code>i&gt;&gt;1  再 &lt;&lt;1 正好就是i - i%2</code></li>
</ul>
</li>
</ul>
<p><img src="/2022/01/26/C++/c++algo/image-20221206191856660.png" alt="image-20221206191856660"></p>
<p><img src="/2022/01/26/C++/c++algo/image-20221206192355775.png" alt="image-20221206192355775"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">  res[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=n; ++i)&#123;</span><br><span class="line">    res[i] = res[i&gt;&gt;<span class="number">1</span>] + (<span class="number">1</span>%<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="序列型动态规划"><a href="#序列型动态规划" class="headerlink" title="序列型动态规划"></a><strong>序列型动态规划</strong></h4><ul>
<li>序列+状态</li>
<li>Lintcode 516 <a href="https://www.lintcode.com/problem/516/" target="_blank" rel="noopener">https://www.lintcode.com/problem/516/</a><ul>
<li><code>f[i][j] = min{f[i-1][k] (k != j)} + cost[i][j]</code></li>
<li>时间复杂度：<code>O(N*k*K)</code></li>
<li>优化：<ul>
<li><code>循环j求f[i][j]时,每个j都要计算一次min{f[i-1][k] (k != j)}时</code>  时间复杂度：<code>O(K*K)</code> ,但其实有重复计算</li>
<li>一次性计算出<code>f[i-1][k]</code>的最小值和次小值，当j不等于最小值的k时，最小值就是最小值，<strong>当j等于最小值的k时，最小值就是次小值</strong></li>
<li>假如最小值是<code>f[i-1][a]</code>, 次小值是<code>f[i-1][b]</code></li>
<li><code>f[i][j] = f[i-1][a] + cost[i][j]  j!=a</code></li>
<li><code>f[i][j] = f[i-1][b] + cost[i][j]  j==a</code></li>
<li>时间复杂度降为：<code>O(N*K)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/2022/01/26/C++/c++algo/image-20221206194104943.png" alt="image-20221206194104943"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minCost11</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; cost)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = cost.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">int</span> k = cost[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">f</span><span class="params">(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(k))</span></span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ;j&lt;k;++j)&#123;</span><br><span class="line">    f[<span class="number">0</span>][j] = cost[<span class="number">0</span>][j];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; ++i)&#123;</span><br><span class="line">    <span class="keyword">int</span> first = INT32_MAX, second = INT32_MAX;</span><br><span class="line">    <span class="keyword">int</span> a , b;</span><br><span class="line">    <span class="comment">// 注意最小值 和 次小值的求法</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; ++j)&#123;</span><br><span class="line">      <span class="keyword">if</span>(f[i<span class="number">-1</span>][j] &lt; first)&#123;</span><br><span class="line">        second = first;</span><br><span class="line">        b = a;</span><br><span class="line">        first = f[i<span class="number">-1</span>][j];</span><br><span class="line">        a = j;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(f[i<span class="number">-1</span>][j] &lt; second)&#123;</span><br><span class="line">        second = f[i<span class="number">-1</span>][j];</span><br><span class="line">        b = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j &lt; k; ++j)&#123;</span><br><span class="line">      <span class="keyword">if</span>(j != a)&#123;</span><br><span class="line">        f[i][j] = f[i<span class="number">-1</span>][a] + cost[i][j];</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        f[i][j] = f[i<span class="number">-1</span>][b] + cost[i][j];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> res = INT32_MAX;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;k; ++j)&#123;</span><br><span class="line">    res = <span class="built_in">min</span>(res, f[n<span class="number">-1</span>][j]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>392 · 打劫房屋 <a href="https://www.lintcode.com/problem/392/" target="_blank" rel="noopener">https://www.lintcode.com/problem/392/</a></li>
</ul>
<p><strong>最长序列型动态规</strong></p>
<h4 id="划分型动态规划"><a href="#划分型动态规划" class="headerlink" title="划分型动态规划"></a><strong>划分型动态规划</strong></h4><ul>
<li>lint  513</li>
<li><strong>lint 108</strong><ul>
<li>每次i, j 都固定后再对[j,i-1]判断回文则会导致时间复杂度为n^3</li>
<li>先记录s中的所有回文串，时间复杂度n*n<ul>
<li>从中心点向两边扩展<ul>
<li>奇数情况，n个点可以作为中心点</li>
<li>偶数情况，n-1个点可作为中心点</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//优化前</span></span><br><span class="line">F[i] = <span class="built_in">min</span>(F[j] + <span class="number">1</span>)  [j,i<span class="number">-1</span>]是回文  <span class="number">0</span>&lt;=j&lt;i</span><br><span class="line">F[<span class="number">0</span>] = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//优化后</span></span><br><span class="line">F[i] = <span class="built_in">min</span>(F[j] + <span class="number">1</span>)  isPalin[j,i<span class="number">-1</span>]==<span class="literal">true</span>  <span class="number">0</span>&lt;=j&lt;i</span><br><span class="line">F[<span class="number">0</span>] = <span class="number">-1</span> </span><br><span class="line">用isPalin记录是回文串的区间</span><br><span class="line">    </span><br><span class="line"><span class="keyword">bool</span> isHui(<span class="built_in">string</span> s)&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> j = s.length()<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(s[i] != s[j]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    ++i;</span><br><span class="line">    --j;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createPalin</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp; isPalin)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = s.length();</span><br><span class="line">  <span class="comment">// 奇数情况</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; n; ++c)&#123;</span><br><span class="line">    <span class="keyword">int</span> i = c;</span><br><span class="line">    <span class="keyword">int</span> j = c;</span><br><span class="line">    <span class="comment">// 从中兴向两边扩展</span></span><br><span class="line">    <span class="keyword">while</span> (i&gt;=<span class="number">0</span> &amp;&amp; j &lt; n &amp;&amp; s[i] == s[j])</span><br><span class="line">    &#123;</span><br><span class="line">      isPalin[i][j] = <span class="literal">true</span>;</span><br><span class="line">      --i;</span><br><span class="line">      ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//偶数情况</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; n<span class="number">-1</span>; ++c)&#123;</span><br><span class="line">    <span class="keyword">int</span> i = c;</span><br><span class="line">    <span class="keyword">int</span> j = c+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;=<span class="number">0</span> &amp;&amp; j &lt; n &amp;&amp; s[i] == s[j])</span><br><span class="line">    &#123;</span><br><span class="line">      isPalin[i][j] = <span class="literal">true</span>;</span><br><span class="line">      --i;</span><br><span class="line">      ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lint108</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">  <span class="comment">//1 提前不记录回文</span></span><br><span class="line"><span class="comment">//   F[i] = min(F[j] + 1)  [j,i-1]是回文  0&lt;=j&lt;i</span></span><br><span class="line"><span class="comment">//   F[0] = -1</span></span><br><span class="line">  <span class="keyword">int</span> n = s.length();</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">F</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">  F[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=n; ++i)&#123;</span><br><span class="line">    <span class="keyword">int</span> res = INT32_MAX;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j)&#123;</span><br><span class="line">      <span class="keyword">if</span>(isHui(s.substr(j, i-j)))</span><br><span class="line">        res = <span class="built_in">min</span>(res, F[j] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    F[i] = res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> F[n];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2 提前记录回文</span></span><br><span class="line">  <span class="keyword">int</span> n = s.length();</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">isPalin</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>))</span></span>;</span><br><span class="line">  createPalin(s, isPalin);</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">F</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">  F[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=n; ++i)&#123;</span><br><span class="line">    <span class="keyword">int</span> res = INT32_MAX;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j)&#123;</span><br><span class="line">      <span class="keyword">if</span>(isPalin[j][i-j])</span><br><span class="line">        res = <span class="built_in">min</span>(res, F[j] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    F[i] = res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> F[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>lint 437<ul>
<li>k&gt;= n时，直接返回数组最大值即可</li>
<li>k &lt; n时， 一个人至少处理一本书</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 考虑k，n关系</span></span><br><span class="line">k&lt;n时</span><br><span class="line">F[k][i] = <span class="built_in">min</span>(<span class="built_in">max</span>(F[k<span class="number">-1</span>][j], sum[j, i<span class="number">-1</span>]))  k<span class="number">-1</span>&lt;j&lt;i</span><br><span class="line">F[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">F[<span class="number">0</span>][<span class="number">1</span>---n] = +无穷</span><br><span class="line">F[<span class="number">1</span>---k][<span class="number">0</span>] = <span class="number">0</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是不考虑k，n关系的处理</span></span><br><span class="line">F[k][i] = <span class="built_in">min</span>(<span class="built_in">max</span>(F[k<span class="number">-1</span>][j], sum[j, i<span class="number">-1</span>]))  <span class="number">0</span>&lt;=j&lt;=i</span><br><span class="line">F[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">F[<span class="number">0</span>][<span class="number">1</span>---n] = +无穷</span><br><span class="line">F[<span class="number">1</span>---k][<span class="number">0</span>] = <span class="number">0</span> </span><br><span class="line">    </span><br><span class="line"><span class="keyword">int</span> lint437(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, <span class="keyword">int</span> k)&#123;</span><br><span class="line"><span class="comment">// F[k][i] = min(max(F[k-1][j], sum[j, i-1]))  0&lt;=j&lt;i</span></span><br><span class="line"><span class="comment">// F[0][0] = 0</span></span><br><span class="line"><span class="comment">// F[0][1---n] = +无穷</span></span><br><span class="line"><span class="comment">// F[1---k][0] = 0  </span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 人数大于书时，只需要n个人即可</span></span><br><span class="line">  <span class="keyword">if</span>(k &gt; n)&#123;</span><br><span class="line">    k = n;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">F</span><span class="params">(k+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>))</span></span>;</span><br><span class="line">  F[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">    F[<span class="number">0</span>][i] = INT32_MAX;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">1</span>; c &lt;= k; ++c)&#123;</span><br><span class="line">    F[c][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">      F[k][i] = INT32_MAX;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; --j)&#123;</span><br><span class="line">        F[k][i] = <span class="built_in">min</span>(F[k][i], <span class="built_in">max</span>(F[k<span class="number">-1</span>][j], sum));</span><br><span class="line">        <span class="keyword">if</span>(j &gt; <span class="number">0</span>)</span><br><span class="line">          sum += A[j<span class="number">-1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> F[k][n]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="博弈型动态规划"><a href="#博弈型动态规划" class="headerlink" title="博弈型动态规划"></a><strong>博弈型动态规划</strong></h4><ul>
<li>lint394</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">F[i] = &#123;<span class="literal">true</span>, F[i<span class="number">-1</span>] = <span class="literal">false</span> <span class="keyword">and</span> F[i<span class="number">-2</span>] = <span class="literal">false</span></span><br><span class="line">        <span class="literal">true</span>, F[i<span class="number">-1</span>] = <span class="literal">true</span> <span class="keyword">and</span> F[i<span class="number">-2</span>] = <span class="literal">false</span></span><br><span class="line">        <span class="literal">true</span>, F[i<span class="number">-1</span>] = <span class="literal">false</span> <span class="keyword">and</span> F[i<span class="number">-2</span>] = <span class="literal">true</span></span><br><span class="line">        <span class="literal">false</span>, F[i<span class="number">-1</span>] = <span class="literal">true</span> <span class="keyword">and</span> F[i<span class="number">-2</span>] = <span class="literal">true</span> &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">class Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param n: An integer</span></span><br><span class="line"><span class="comment">     * @return: A boolean which equals to true if the first player will win</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">bool</span> firstWillWin(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1</span></span><br><span class="line">        <span class="comment">// bool F[n+1];</span></span><br><span class="line">        <span class="comment">// F[1] = F[2] = true;</span></span><br><span class="line">        <span class="comment">// for(int i = 3; i &lt;= n; ++i)&#123;</span></span><br><span class="line">        <span class="comment">//     F[i] = !(F[i-1]) || !(F[i-2]);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// return F[n];</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 滚动数组</span></span><br><span class="line">        <span class="keyword">bool</span> one, two;</span><br><span class="line">        one = two = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">bool</span> temp = !one || !two;</span><br><span class="line">            one = two;</span><br><span class="line">            two = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> two;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a><strong>背包问题</strong></h4><blockquote>
<p>注意分类</p>
<ul>
<li>元素可以重复用：零钱问题、lint564、lint440<ul>
<li>考虑对象为背包可容量的大小，用一位数组</li>
</ul>
</li>
<li>元素不可重复用：lint92、lint563、lint125<ul>
<li>考虑对象为元素，需要用二维数组，但可以空间优化</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>lint92 <a href="https://www.lintcode.com/problem/92/record" target="_blank" rel="noopener">https://www.lintcode.com/problem/92/record</a><ul>
<li>记录是否可以  bool</li>
<li>元素不可重复</li>
<li>二维数组  <ul>
<li>从1—n, 0做预处理</li>
</ul>
</li>
<li>需要遍历<code>f[n][0--w]</code>找到j的最大值，因为记录的是可达，需要知道最大可达的j</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* arr:  物品</span><br><span class="line">* arr[i]: i物品重量</span><br><span class="line">* i:   第i个物品     0&lt;&#x3D;i&lt;arr.size()</span><br><span class="line">* w: 背包可容纳的重量</span><br><span class="line">* 诉求：任选物品(不重复)将背包尽可能装满</span><br><span class="line">* i是考虑的对象，最后一个是使用i, 前i-1个是子问题， *背包重量不是考虑对象*   </span><br><span class="line">* 相对零钱问题，背包问题中物品是不能重复使用的，且不一定可以正好凑到w重量</span><br></pre></td></tr></table></figure>



<p><img src="/2022/01/26/C++/c++algo/image-20230211162531680.png" alt="image-20230211162531680"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意： i表示使用arr中第i个元素，即arr[i-1]   使用第1个元素则是a[0]</span></span><br><span class="line">f[i][w] = f[i<span class="number">-1</span>][w] || f[i<span class="number">-1</span>][w-arr[i<span class="number">-1</span>]]     </span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">f[<span class="number">0</span>][<span class="number">1</span>-&gt;w] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 空间优化</span></span><br><span class="line">f[w] = f[w] || f[w-arr[i<span class="number">-1</span>]]  <span class="comment">// 从右往左覆盖</span></span><br><span class="line">f[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">f[<span class="number">1</span>--w] = <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<ul>
<li>lint563 <a href="https://www.lintcode.com/problem/563/" target="_blank" rel="noopener">https://www.lintcode.com/problem/563/</a><ul>
<li>记录组合数</li>
<li>元素不可重复</li>
<li>二维数组<ul>
<li>从1—n, 0做预处理</li>
</ul>
</li>
<li>直接return<code>f[n][w]</code></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// f[i][j] = f[i-1][j] + f[i-1][j-nums[i-1]]   (j &gt;= nums[i-1])   i从1开始</span></span><br><span class="line"><span class="comment">// f[0][0] = 1</span></span><br><span class="line"><span class="comment">// f[0][1---target] = 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 空间优化</span></span><br><span class="line"><span class="comment">// f[j] = f[j] + f[j-nums[i]]  (j &gt;= nums[i])  此时i可以直接从0开始</span></span><br><span class="line"><span class="comment">// f[0] = 1</span></span><br><span class="line"><span class="comment">// f[1---target] = 0   </span></span><br><span class="line"><span class="comment">// 从右往左覆盖</span></span><br></pre></td></tr></table></figure>

<ul>
<li>lint564<ul>
<li>记录组合数</li>
<li>元素可重复</li>
<li>一维数组<ul>
<li>从0—n-1</li>
</ul>
</li>
<li>return f[w]</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">题意:</span><br><span class="line">给定N个正整数: A0,A1，...,AN<span class="number">-1</span></span><br><span class="line">一个正整数Target</span><br><span class="line">求有多少种组合加起来是Target 每个Ai可以用多次</span><br><span class="line">**<span class="number">1</span>+<span class="number">2</span>+<span class="number">1</span> = <span class="number">4</span> ， <span class="number">1</span>+<span class="number">1</span>+<span class="number">2</span> = <span class="number">4</span> 这是算两次的  就是不考虑顺序**</span><br><span class="line"></span><br><span class="line"><span class="comment">// f[j] = 求和&#123;f[j-a[i]]&#125;  0&lt;=i&lt;a.size()   0&lt;j&lt;=target  j &gt;= a[i]</span></span><br><span class="line"><span class="comment">// f[0] = 1</span></span><br><span class="line"><span class="comment">// f[1---target] = 0</span></span><br><span class="line"></span><br><span class="line">solution(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, <span class="keyword">int</span> target)&#123;</span><br><span class="line">	<span class="keyword">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(target+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= target; ++j)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= a[i])&#123;</span><br><span class="line">                f[j] += f[j-a[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>lint125 <a href="https://www.lintcode.com/problem/125/record" target="_blank" rel="noopener">https://www.lintcode.com/problem/125/record</a><ul>
<li>总价值最大</li>
<li>记录总价值</li>
<li>元素不可重复</li>
<li>二维数组<ul>
<li>从1—n, 0做预处理</li>
</ul>
</li>
<li>需要遍历<code>f[n][0--w]</code>找到最大值， 因为价值和重量分离</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// f[i][j] = max&#123;f[i-1][j], f[i-1][j-a[i-1]] + v[i-1]&#125;  0&lt;i&lt;=s.size()   0&lt;=j&lt;=m  j &gt;= a[i-1]</span></span><br><span class="line"><span class="comment">// f[0][0---m] = 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 空间优化</span></span><br><span class="line"><span class="comment">// f[j] = max&#123;f[j], f[j-a[i]] + v[i]&#125;  0&lt;=i&lt;s.size()   0&lt;=j&lt;=m  j &gt;= a[i]</span></span><br><span class="line"><span class="comment">// f[0][0---m] = 0</span></span><br><span class="line"><span class="comment">// 从左往右覆盖</span></span><br></pre></td></tr></table></figure>

<ul>
<li>lint 440 <a href="https://www.lintcode.com/problem/440/" target="_blank" rel="noopener">https://www.lintcode.com/problem/440/</a><ul>
<li>总价值最大</li>
<li>记录总价值</li>
<li>元素可重复</li>
<li>一位数组<ul>
<li>从0—-n-1</li>
</ul>
</li>
<li>需要遍历f[0–w]找到最大值，因为价值和重量分离，记录的是价值</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// f[j] = max(f[j-a[i]] + v[i])   0&lt;j&lt;=m,  0&lt;=i&lt;a.size(),  j&gt;=a[i]</span></span><br><span class="line"><span class="comment">// f[0] = 0</span></span><br></pre></td></tr></table></figure>

<h4 id="区间型动态规划"><a href="#区间型动态规划" class="headerlink" title="区间型动态规划"></a>区间型动态规划</h4><blockquote>
<p>特点：</p>
<ul>
<li>二维数组</li>
<li>初始化是对角线</li>
<li>计算顺序是序列长度</li>
</ul>
</blockquote>
<ul>
<li>lint 667 最长的回文序列<ul>
<li>非连续</li>
<li>记录当前区间（s[i….j]）最长回文序列长度  <code>f[i][j]记录s[i...j]区间最长回文长度</code></li>
<li>难度提升：打印出最长回文序列</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">要求S[i..j]的最长回文子串</span><br><span class="line">如果S[i]=S[j]，需要知道S[i+<span class="number">1.</span>.j<span class="number">-1</span>]的最长回文子串  子问题为去掉回文头尾的子串</span><br><span class="line">如果S[i]/=S[j]答案是S[ i+<span class="number">1.</span>.j]的最长回文子串或S[i..j<span class="number">-1</span>]的最长回文子串子问题  子问题为去掉头的子串或去掉尾的子串</span><br><span class="line">状态︰设f[i]j]为S[i..j]的最长回文子串的长度</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//f[i][j] = max(f[i+1][j], f[i][j-1], f[i+1][j-1]+2(s[i]==s[j]))  i&lt;=j   0&lt;=i,j&lt;s.length()</span></span><br><span class="line"><span class="comment">//f[i][i] = 1  初始化是对角</span></span><br><span class="line"><span class="comment">//计算顺序是序列长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//难度提升：打印出最长回文序列</span></span><br><span class="line"><span class="comment">//pi[i][j]记录当前区间取的是哪个区间</span></span><br><span class="line"><span class="comment">//pi[i][j] = 0  去头   f[i+1][j]</span></span><br><span class="line"><span class="comment">//pi[i][j] = 1  去尾   f[i][j-1]</span></span><br><span class="line"><span class="comment">//pi[i][j] = 0  去t   f[i+1][j-1]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>lint396(博弈+区间)<ul>
<li><code>f[i][j]</code>记录的巧妙性也可以简化问题</li>
</ul>
</li>
</ul>
<p><img src="/2022/01/26/C++/c++algo/image-20230213105233231.png" alt="image-20230213105233231"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自己的思路   可能有误   f[i][j]记录当前区间先手可拿到的最大数</span></span><br><span class="line">取a[i]时剩余区间 [i+<span class="number">1</span>,j], 对手有两种取法， 取a[j]---&gt;[i+<span class="number">1</span>, j<span class="number">-1</span>]  取a[i+<span class="number">1</span>]---&gt;[i+<span class="number">2</span>,j]</span><br><span class="line">f[i][j] = <span class="built_in">max</span>(a[i]+f[i+<span class="number">2</span>][j], a[i]+f[i+<span class="number">1</span>][j<span class="number">-1</span>], a[j]+f[i][j<span class="number">-2</span>], a[j]+f[i+<span class="number">1</span>][j<span class="number">-1</span>])</span><br><span class="line">f[i][i] = a[i]</span><br><span class="line">f[i][i+<span class="number">1</span>] = <span class="built_in">max</span>(a[i],a[i+<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">最后比较先手：f[i][j], 后手：f[i+<span class="number">1</span>][j]，f[i][j<span class="number">-1</span>]  大小即可得答案</span><br><span class="line"></span><br><span class="line">长度为<span class="number">1</span>，<span class="number">2</span>时肯定为<span class="literal">true</span>直接返回</span><br><span class="line"></span><br><span class="line"><span class="comment">// 教程思路 f[i][j]记录当前区间和对手的差值</span></span><br><span class="line">[i,j]上取a[i],剩余[i+<span class="number">1</span>][j], 而f[i+<span class="number">1</span>][j]记录的也是和对手的差值，a[i]-f[i+<span class="number">1</span>][j]就是此时选手和对手的差值</span><br><span class="line">f[i][j] = <span class="built_in">max</span>(a[i]-f[i+<span class="number">1</span>][j], a[j]-f[i][j<span class="number">-1</span>])</span><br><span class="line">f[i][i] = a[i]</span><br><span class="line">f[<span class="number">0</span>][n<span class="number">-1</span>]大于等于<span class="number">0</span>则返回<span class="literal">true</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">bool</span> solution(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a)&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span> || n==<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">f</span><span class="params">(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n))</span></span>;</span><br><span class="line">    <span class="comment">// len = 1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        f[i][i] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// len &gt;= 2</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; n; ++k)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n-k; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + k;</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>((a[i]-f[i+<span class="number">1</span>][j]),(a[j]-f[i][j<span class="number">-1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[<span class="number">0</span>][n<span class="number">-1</span>] &gt;= <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>lint 430</li>
</ul>
<blockquote>
<p>困难，教程：5: 1.38</p>
<p>时间复杂度：O(n^4),  空间复杂度：O(n^3)</p>
</blockquote>
<p><img src="/2022/01/26/C++/c++algo/image-20230213152207201.png" alt="image-20230213152207201"></p>
<p><img src="/2022/01/26/C++/c++algo/image-20230213152430689.png" alt="image-20230213152430689"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 长度不一样直接返回</span></span><br><span class="line"><span class="keyword">int</span> n = s1.length();</span><br><span class="line"><span class="keyword">if</span>(n1 != s2.length()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// f[i][j][k] = (f[i][j][w] and f[i+w][j+w][k-w]) or (f[i][j+k-w][w] and f[i+w][j][k-w])  1&lt;=w&lt;k</span></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="comment">// f[i][j][1] = true(s1[i] == s2[j]) 否则，，</span></span><br><span class="line"><span class="comment">// k=2   0&lt;=i,j&lt;=n-2  &lt;(n-2)+1</span></span><br><span class="line"><span class="comment">// k = n  0&lt;=i,j&lt;=n-n  &lt;(n-2)+1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&gt; <span class="title">f</span><span class="params">(n,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;(n, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n+<span class="number">1</span>,<span class="literal">false</span>)))</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ;j &lt;n; ++j)&#123;</span><br><span class="line">        f[i][j][<span class="number">1</span>] = s1[i] == s2[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">2</span>; k&lt;=n; ++k)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n-k; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n-k; ++j)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> w= <span class="number">1</span>; w &lt; k ++w)&#123;</span><br><span class="line">                <span class="keyword">if</span>((f[i][j][w] &amp;&amp; f[i+w][j+w][k-w]) || (f[i][j+k-w][w] &amp;&amp; f[i+w][j][k-w]))&#123;</span><br><span class="line">                    f[i][j][k] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f[<span class="number">0</span>][<span class="number">0</span>][n];</span><br></pre></td></tr></table></figure>

<ul>
<li>lint168 <a href="https://leetcode.cn/problems/burst-balloons/" target="_blank" rel="noopener">戳气球</a><ul>
<li>困难：5：1.45</li>
<li>时间复杂度：O(n^3),  空间复杂度：O(n^2)</li>
<li><strong>特点：消去型</strong><ul>
<li>逆向思维，从最后剩下的往回推</li>
<li>每个区间先考虑最后被扎的气球</li>
<li>最后被扎的气球将原区间划分为左右两个子区间</li>
<li>只考虑与之相邻的，最后被扎破，则意味着左右气球都扎破了，此时<code>nums[left] * nums[k] * nums[right] = nums[i]*nums[k]*nums[j]</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于消去型解决方案的理解</span></span><br><span class="line"><span class="comment">// 1 重构数组 a[0] = a[n+1] = 1  边界置1便于计算</span></span><br><span class="line"><span class="comment">// 2 f[i][j]记录这个区间可以获得的最大值  可扎破的气球为[i+1，j-1]头尾空出来，因为是边界</span></span><br><span class="line"><span class="comment">// f[i][j] = max(f[i][k]+f[k][j]+a[i]*a[k]*a[j])   i&lt;k&lt;j  最小区间为2，因为至少有两个边界</span></span><br><span class="line"><span class="comment">// a[i]*a[k]*a[j]是因为是逆向考虑的，此时[i,j]区间只有k没有被扎，则其邻接气球就是两个边界a[i],a[j]</span></span><br><span class="line"><span class="comment">// 对于f[i][k]，若区间中还有气球，假设最后被扎破的是z, 则计算结果为a[i]*a[z]*a[k] , 此时边界为a[i],a[k]   a[k]开始参与运算</span></span><br><span class="line"><span class="comment">// 因为a[k]是最后扎破的，所以其左右子区间直接一定无关，有a[k]的存在不可能再相连</span></span><br><span class="line"><span class="comment">// 3 初始化</span></span><br><span class="line"><span class="comment">// f[i][i+1] = 0  区间只有两个边界则获得分数为0</span></span><br></pre></td></tr></table></figure>

<h4 id="双序列型动态规划"><a href="#双序列型动态规划" class="headerlink" title="双序列型动态规划"></a>双序列型动态规划</h4><ul>
<li>lint 77 (LCS) 最长公共子序列<ul>
<li>非连续  注意子串和子序列的区别   子串连续  子序列非连续</li>
<li>时间复杂度：O(MN)  空间复杂度：O(M)  （滚动数组，空间优化）</li>
<li>类比最长回文子序列</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类比最长回文子序列  把第二个数组反转接在第一个数组后面即可，只是范围不同</span></span><br><span class="line"><span class="comment">// f[i][j] = max(f[i+1][j], f[i][j+1], f[i+1][j+1]+1(a[i] == a[j]))   0&lt;=i&lt;n  0&lt;=j&lt;m </span></span><br><span class="line"><span class="comment">// f[n][0----m] = f[0---n][m] = 0  最右边即为比对最后结果都为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 空间优化</span></span><br></pre></td></tr></table></figure>

<ul>
<li>lint 29<ul>
<li>记录是否  记录bool</li>
<li>初始化不好确定</li>
<li>需要反复思考</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// f[k][i][j] 记录 s3前k个元素是否可以由s1前i个元素和s2前j个元素交错形成</span></span><br><span class="line"><span class="comment">// 由于k = i + j</span></span><br><span class="line"><span class="comment">// f[i][j] 记录 s3前i+j个元素是否可以由s1前i个元素和s2前j个元素交错形成</span></span><br><span class="line"><span class="comment">// f[i][j] = (f[i-1][j] and s1[i-1] == s3[i+j-1]) || (f[i][j-1] and s2[j-1] == s3[i+j-1])</span></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="comment">// f[0][0] = true;</span></span><br><span class="line"><span class="comment">// i = 0 不考虑 f[i-1][j] and s1[i-1] == s3[i+j-1]</span></span><br><span class="line"><span class="comment">// j = 0 不考虑 f[i][j-1] and s2[j-1] == s3[i+j-1]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>lint 119 编辑距离<ul>
<li>记录操作次数，比较大小，没有想到比较大小，复习</li>
<li>初始化出错，复习</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录操作次数</span></span><br><span class="line"><span class="comment">// a[0,,,,,n-1]</span></span><br><span class="line"><span class="comment">// b[0,,,,,,m-1]</span></span><br><span class="line"><span class="comment">// 从最后一步考虑  b[m-1]如何得来</span></span><br><span class="line"><span class="comment">//  b[m-1]来自4种情况 </span></span><br><span class="line"><span class="comment">//  1 a[n-1] 不变得来  a[n-1] = b[m-1] </span></span><br><span class="line"><span class="comment">//  2 a[n-1] 删除得来  </span></span><br><span class="line"><span class="comment">//  3 a[n-1] 后面添加一个元素得来  </span></span><br><span class="line"><span class="comment">//  4 a[n-1] 替换得来</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// f[i][j]记录操作次数，经过这些操作次数可以使得a[0,,i-1]变为b[0,,j-1]</span></span><br><span class="line"><span class="comment">// f[i][j] = min(f[i-1][j-1](a[i-1] == b[j-1]), f[i-1][j]+1, f[i][j-1]+1,f[i-1][j-1]+1)</span></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="comment">// f[0][j] = j (0&lt;=j&lt;=m)</span></span><br><span class="line"><span class="comment">// f[i][0] = i (0&lt;=i&lt;=n)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>lint118</p>
<ul>
<li><p>记录出现次数</p>
</li>
<li><p>不同情况应该是相加而不是max，复习</p>
</li>
<li><p>初始条件的确定根据需要来</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 考虑最后一步</span></span><br><span class="line"><span class="comment">// t[m-1] 来自两种情况</span></span><br><span class="line"><span class="comment">// 1 s[n-1]不变得来  s[n-1] == t[m-1]</span></span><br><span class="line"><span class="comment">// 2 删除s[n-1]得来</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// f[i][j]记录t前j个元素序列在s前i个元素序列中出现的次数   有多少个子序列转化为出现过多少次</span></span><br><span class="line"><span class="comment">// f[i][j] = f[i-1][j-1](s[i-1] == t[j-1]) + f[i-1][j]   注意是两种情况次数的和</span></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="comment">// f[0--i][0] = 1;   举例验证，需要的是1</span></span><br><span class="line"><span class="comment">// f[0][1--j] = 0;   </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 滚动数组优化</span></span><br><span class="line"><span class="comment">// 从右往左覆盖</span></span><br><span class="line"><span class="comment">// f[j] = f[j] + f[j-1](s[i-1] == t[j-1])</span></span><br><span class="line"><span class="comment">// f[0] = 1;</span></span><br><span class="line"><span class="comment">// f[1,,,m] = 0;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>lint 154  正则表达式匹配<ul>
<li>下次考虑从s[n-1]作为最后一步考虑，不对正则预处理</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从正则序列考虑最后一步</span></span><br><span class="line"><span class="comment">// 先将正则序列划分为基本匹配单元（字母, ".", ".*", "字母*"） pp[m]</span></span><br><span class="line"><span class="comment">// 考虑最后一步</span></span><br><span class="line"><span class="comment">// pp[m-1]是否可以匹配s[n-1]</span></span><br><span class="line"><span class="comment">// 1 用pp[m-1] (s[n-1] == pp[m-1] || pp[m-1] == "." ) &amp;&amp; (pp[m-2]可以匹配s[n-2])</span></span><br><span class="line"><span class="comment">// 2 用pp[m-1] (pp[m-1] == ".*" || pp[m-1] == "s[n-1]*") and </span></span><br><span class="line"><span class="comment">//   (pp[m-1]可以匹配s[n-2](s[n-1]消除掉) || pp[m-2]可以匹配s[n-2](两个都消除掉)))   // pp[m-2]可以匹配s[n-2](两个都消除掉)加不加不影响结果</span></span><br><span class="line"><span class="comment">// 3 不用pp[m-1]  包含*时才可以不用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// f[i][j] 记录pp前j个匹配单元是否可以匹配s前i个元素序列</span></span><br><span class="line"><span class="comment">// f[i][j] = ((s[i-1] == pp[j-1] || pp[j-1] == ".") &amp;&amp; f[i-1][j-1]) || </span></span><br><span class="line"><span class="comment">// (pp[j-1] == ".*" || pp[j-1] == "s[i-1]*") and (f[i-1][j] || f[i-1][j-1] || )) ||  // f[i-1][j-1]可以不要</span></span><br><span class="line"><span class="comment">// (pp[j-1].size() == 2 &amp;&amp; f[i][j-1])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="comment">// f[0][0] = true;</span></span><br><span class="line"><span class="comment">// f[1,,,n][0] = false;</span></span><br><span class="line"><span class="comment">// f[0][1,,,m] = true(前m都包含* pp[j].size() == 2 则一定包含*)  否则 false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ps</span></span><br><span class="line"><span class="comment">// 2 用pp[m-1] (pp[m-1] == ".*" || pp[m-1] == "s[n-1]*") and </span></span><br><span class="line"><span class="comment">//   (pp[m-1]可以匹配s[n-2](s[n-1]消除掉) || pp[m-2]可以匹配s[n-2](两个都消除掉)))   </span></span><br><span class="line"><span class="comment">// f[i][j] = f[i-1][j-1] (pp[j-1] == ".*" || pp[j-1] == "s[i-1]*")</span></span><br><span class="line"><span class="comment">// f[i-1][j] = f[i-1][j-1] (pp[j-1].size() == 2) 是同一种情况</span></span><br><span class="line"><span class="comment">// f[3][4] = f[2][3] (pp[3] == ".*" || pp[3] == "s[i-1]*")  ---1</span></span><br><span class="line"><span class="comment">// f[2][4] = f[2][3] (pp[3].size() == 2) ---2</span></span><br><span class="line"><span class="comment">// ---1 和 ---2 是同一种情况 ，所以在---1中不用考虑</span></span><br></pre></td></tr></table></figure>

<ul>
<li>lint192</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 考虑最后一步</span></span><br><span class="line"><span class="comment">// s[n-1]</span></span><br><span class="line"><span class="comment">// s[n-1] == p[m-1] || p[m-1] == "?"  ----&gt; s[0,,,n-2] 与 p[0,,,m-2]匹配</span></span><br><span class="line"><span class="comment">// p[m-1] == "*"</span></span><br><span class="line"><span class="comment">//   使用p[m-1]---&gt; s[0,,,n-2] 与 p[0,,,m-1] 匹配</span></span><br><span class="line"><span class="comment">//   不使用p[m-1]---&gt; s[0,,,n-1] 与 p[0,,,m-2]匹配</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// f[i][j] 记录p前j个字符是否可以匹配s前i个字符</span></span><br><span class="line"><span class="comment">// f[i][j] = f[i-1][j-1] (s[i-1] == p[j-1] || p[j-1] == "?")</span></span><br><span class="line"><span class="comment">//           f[i-1][j] || f[i][j-1]  (p[j-1] == "*")</span></span><br><span class="line"><span class="comment">// f[0][0] = true;</span></span><br><span class="line"><span class="comment">// f[1,,n][0] = false;</span></span><br><span class="line"><span class="comment">// f[0][1,,,m] = true(p[j-1] == "*" &amp;&amp; f[0][j-1])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化都为false 因为上面讨论的都是可以匹配的情况，不能匹配则直接为false</span></span><br></pre></td></tr></table></figure>

<ul>
<li>lint 668</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 统计strs中每个字符串的0，1个数并记录, 记录在s中，s长度为l</span></span><br><span class="line"><span class="comment">// f[k][i][j] 记录i个0和j个1可以构造k个字符串中字符串的个数</span></span><br><span class="line"><span class="comment">// 考虑最后一步</span></span><br><span class="line"><span class="comment">// s[l-1]这个字符串是否参与构成</span></span><br><span class="line"><span class="comment">//  1 不参与   f[k][i][j] = f[k-1][i][j]</span></span><br><span class="line"><span class="comment">//  2 参与     f[k][i][j] = f[k-1][i-s[k-1].first][j-s[k-1].second] + 1</span></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="comment">// f[0][i][j] = 0;</span></span><br></pre></td></tr></table></figure>

<h4 id="Hard"><a href="#Hard" class="headerlink" title="Hard"></a>Hard</h4><ul>
<li>lint91<ul>
<li>难度大，不好理解，且状态不好构建</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">题目</span><br><span class="line">给定数组A,每个元素是不超过100的正整数</span><br><span class="line">将A中每个元素修改后形成数组B</span><br><span class="line">要求B中任意两个相邻的元秦的差不能超过Target</span><br><span class="line">求最小修改代价，即|A[0]-B[0]|+...+ |A[n-1]-B[n-1]|</span><br><span class="line"></span><br><span class="line">案例</span><br><span class="line">输人:A&#x3D;[1，4,2,3],Target &#x3D; 1</span><br><span class="line">输出:2 (B&#x3D;[2,3,2.3])</span><br><span class="line"></span><br><span class="line">题目分析</span><br><span class="line">可以证明，最优策略中B的每个元素也一定是不超过100的正整数</span><br><span class="line">否则，将B中小于1的数改成1，大于100的数改成100</span><br><span class="line">1 若左右邻点在100内  则拉回到100 一定总修改代价更小</span><br><span class="line">2 若左右邻点都在100外  都拉回到100 则差值为0 总修改代价还是减少了</span><br><span class="line">这就是后续 1&lt;&#x3D;k&lt;&#x3D;100的由来</span><br></pre></td></tr></table></figure>

<p><img src="/2022/01/26/C++/c++algo/image-20230216154315591.png" alt="image-20230216154315591"></p>
<p><img src="/2022/01/26/C++/c++algo/image-20230216154435308.png" alt="image-20230216154435308"></p>
<p><img src="/2022/01/26/C++/c++algo/image-20230216154634981.png" alt="image-20230216154634981"></p>
<p><img src="/2022/01/26/C++/c++algo/image-20230216154841963.png" alt="image-20230216154841963"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">f</span><span class="params">(n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">101</span>))</span></span></span><br><span class="line"><span class="function">    <span class="title">for</span><span class="params">(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">100</span>; ++j)</span></span>&#123;</span><br><span class="line">        f[<span class="number">1</span>][j] = <span class="built_in">abs</span>(a[<span class="number">0</span>]-j);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i&lt;=n; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;=<span class="number">100</span>; ++j)&#123;</span><br><span class="line">            f[i][j] = INT32_MAX;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = j-target; k &lt;= j+target; ++k)&#123;</span><br><span class="line">                <span class="keyword">if</span>(k&lt;<span class="number">0</span> || k &gt;<span class="number">100</span>) contine;</span><br><span class="line">                f[i][j] = <span class="built_in">min</span>(f[i][j],f[i<span class="number">-1</span>][k]));</span><br><span class="line">            &#125;</span><br><span class="line">            f[i][j] += <span class="built_in">abs</span>(j-a[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = INT32_MAX;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j&lt;=<span class="number">100</span>; ++j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(f[n][j] &lt; res) res = f[n][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>lint89<ul>
<li>背包问题</li>
<li>不可重复使用 所以考虑对象是a数组</li>
<li>k，target作为约束</li>
<li>初始化有难度，复习</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// f[i][j][w] 记录在a前i个元素中使用j个元素可以凑成w个组合数</span></span><br><span class="line"><span class="comment">// 考虑最后一步</span></span><br><span class="line"><span class="comment">// 使用a[n-1]次数+不使用a[n-1]次数</span></span><br><span class="line"><span class="comment">// f[i][j][w] = f[i-1][j-1][w-a[i-1]] + f[i-1][j][w]</span></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="comment">// f[0][0][0] = 1</span></span><br><span class="line"><span class="comment">// f[0][j][w] = 0</span></span><br><span class="line"><span class="comment">// 注意j == 0 时  f[i][0][w]并不一定都是0  f[i][0][0]时是可以为1的</span></span><br></pre></td></tr></table></figure>

<ul>
<li>lint 76 (LIS)<ul>
<li>动态规划  O(n*n)<ul>
<li>用二分查找可以优化为O(nlogn)  教程：7： 30—48</li>
</ul>
</li>
<li>贪心算法  O(nlogn)</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// f[i]记录前i个元素最长上升子序列长度</span></span><br><span class="line"><span class="comment">// 考察最后一步</span></span><br><span class="line"><span class="comment">// a[i]</span></span><br><span class="line"><span class="comment">// f[i] = max(f[j]+1)  (a[j-1] &lt; a[i-1])  0&lt;j &lt;i</span></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="comment">// f[0] = 0;</span></span><br><span class="line"><span class="comment">// 注意最后返回的不是f[n]  而是遍历f找到最大值，因为nums[n-1]不一定在最长序列里</span></span><br></pre></td></tr></table></figure>





<ul>
<li>lint623<ul>
<li>lint119加强版</li>
<li>直接基于lint119做时间复杂度：O(lnm)<ul>
<li>这种方式存在重复计算</li>
<li>例如”abc”和”abd” 前两个字符的计算结果是一样的，应该可以重用才对</li>
</ul>
</li>
<li>基于字母树优化<ul>
<li>利用了空间优化的思想，因为递推公式只和当前<code>f[i][j]</code>和上一层<code>f[i-1][j]</code>有关系</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/2022/01/26/C++/c++algo/image-20230217101205867.png" alt="image-20230217101205867"></p>
<p><img src="/2022/01/26/C++/c++algo/image-20230217105825043.png" alt="image-20230217105825043"></p>
<p><img src="/2022/01/26/C++/c++algo/image-20230217105301828.png" alt="image-20230217105301828"></p>
<p><img src="/2022/01/26/C++/c++algo/image-20230217105756723.png" alt="image-20230217105756723"></p>
<p><img src="/2022/01/26/C++/c++algo/image-20230217110214584.png" alt="image-20230217110214584"></p>
<p><img src="/2022/01/26/C++/c++algo/image-20230217110303025.png" alt="image-20230217110303025"></p>
<p><img src="/2022/01/26/C++/c++algo/image-20230217110533906.png" alt="image-20230217110533906"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暴力版</span></span><br><span class="line"><span class="comment">// 考虑最后一步 target最后一个元素</span></span><br><span class="line"><span class="comment">// f[i][j] 记录a中字符串前j个元素修改为target前i个元素的最小编辑距离</span></span><br><span class="line"><span class="comment">// f[i][j] = f[i-1][j-1]  t[i-1] == a[j-1]  不修改</span></span><br><span class="line"><span class="comment">// f[i][j] = f[i-1][j-1]+1  t[i-1] != a[j-1] 修改</span></span><br><span class="line"><span class="comment">// f[i][j] = f[i][j-1]+1  t[i-1] != a[j-1] 删除</span></span><br><span class="line"><span class="comment">// f[i][j] = f[i-1][j]+1  t[i-1] != a[j-1] 插入</span></span><br><span class="line"><span class="comment">// 四次修改取最小值   注意不修改也参与比较</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// f[i][j] = min(f[i-1][j-1]  (t[i-1] == a[j-1]), f[i-1][j-1]+1, f[i][j-1]+1, f[i-1][j]+1)</span></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="comment">// f[0][1,,,m] = j;</span></span><br><span class="line"><span class="comment">// f[1,,,n][0] = i;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; A, <span class="keyword">int</span> t, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = t.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> it = <span class="number">0</span> ; it &lt; A.<span class="built_in">size</span>(); ++it)&#123;</span><br><span class="line">        <span class="built_in">string</span> a = A[it];</span><br><span class="line">        <span class="keyword">int</span> m = a.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">f</span><span class="params">(n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m+<span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;=n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;=m; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                    f[i][j] = j;</span><br><span class="line">                    contine;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j == <span class="number">0</span>)&#123;</span><br><span class="line">                    f[i][j] = i;</span><br><span class="line">                    contine;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                f[i][j] = f[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                f[i][j] = <span class="built_in">min</span>(f[i][j], f[i][j<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">                f[i][j] = <span class="built_in">min</span>(f[i][j], f[i<span class="number">-1</span>][j]+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(t[i<span class="number">-1</span>] == a[j<span class="number">-1</span>])&#123;</span><br><span class="line">                    f[i][j] = <span class="built_in">min</span>(f[i][j], f[i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(f[n][m] &lt;= k) ++res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化版</span></span><br></pre></td></tr></table></figure>

<ul>
<li>lint622<ul>
<li>序列+哈希表</li>
<li>初始化 根据题意和需要</li>
<li>坐标就可以用索引  </li>
<li>k的取值范围[1,n-1] 不考虑0，因为不存在这种情况，不可能0步到达下一个点</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误思路 已经确定跳的是k步，k-1,k,k+1,约束的是上一步</span></span><br><span class="line"><span class="comment">// f[i][k] 记录从上一个石头经过k跳是否可以到s[i-1]这块石头</span></span><br><span class="line"><span class="comment">// f[i][k] = f[j][k](s[j-1] == s[i-1] - k) || </span></span><br><span class="line"><span class="comment">//           f[j][k-1] (s[j-1] == s[i-1] - k + 1) ||</span></span><br><span class="line"><span class="comment">//           f[j][k+1] (s[j-1] == s[i-1] - k - 1)      </span></span><br><span class="line"><span class="comment">// 注意k是有上限的  0&lt;=k&lt;=i</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="comment">// f[0][k] = true;</span></span><br><span class="line"><span class="comment">// f[i][0] = false;</span></span><br><span class="line"><span class="comment">// f[0][0] = true;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化 每次确定j都需要遍历s，不如用哈希表记录索引和值的关系,用a记录  即a[i] = j表示 s[j] = i;        </span></span><br><span class="line"><span class="comment">// f[i][k] = f[a[s[i-1] - k] + 1][k](s[i-1] - k &gt;= 0) || </span></span><br><span class="line"><span class="comment">//           f[a[s[i-1] - k + 1] + 1][k-1] (s[i-1] - k + 1 &gt;= 0 &amp;&amp; k-1&gt;=0) ||</span></span><br><span class="line"><span class="comment">//           f[a[s[i-1] - k - 1] + 1][k+1] (s[i-1] - k - 1 &gt;= 0)      </span></span><br><span class="line"><span class="comment">// 注意k是有上限的  0&lt;=k&lt;=i</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改正确思路</span></span><br><span class="line"><span class="comment">// f[i][k] 记录从上一个石头经过k跳是否可以到s[i]这块石头</span></span><br><span class="line"><span class="comment">// f[i][k] = f[j][k]   (s[j] == s[i] - k) || </span></span><br><span class="line"><span class="comment">//           f[j][k-1] (s[j] == s[i] - k) ||</span></span><br><span class="line"><span class="comment">//           f[j][k+1] (s[j] == s[i] - k)      </span></span><br><span class="line"><span class="comment">// 注意k是有上限的  k&lt;n 没多走一个石子，可以夺走一步</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="comment">// f[0][j] = false;  在第一个石子, 从第一个石头只能跳到第二个石头，所需石头的子问题如果落在第一个石头一定不可行</span></span><br><span class="line"><span class="comment">// f[1][1] = true;  f[1][1,,,j] = false;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化 每次确定j都需要遍历s，不如用哈希表记录索引和值的关系,用a记录  即a[i] = j表示 s[j] = i;        </span></span><br><span class="line"><span class="comment">// f[i][k] = f[a[ s[i]-k] ][k]   (s[i] - k &gt;= 0) || </span></span><br><span class="line"><span class="comment">//           f[a[ s[i]-k] ][k-1] (s[i] - k &gt;= 0 &amp;&amp; k-1&gt;0) ||</span></span><br><span class="line"><span class="comment">//           f[a[ s[i]-k] ][k+1] (s[i] - k &gt;= 0 &amp;&amp; k+1&lt;n)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 哈希终极解法，感觉不是动态规划</span></span><br><span class="line"><span class="comment">// 哈希解法 正向思考</span></span><br><span class="line"><span class="comment">// f[s[0]] = &#123;0&#125;</span></span><br><span class="line"><span class="comment">// 0--&gt;1可以调1步  f[s[1]] = &#123;1&#125;</span></span><br><span class="line"><span class="comment">// 1--&gt;2可以跳 0，1，2步， f[s[2]] = &#123;记录跳的步数，从前面的一个石头经过这些步数可以跳到s[2]这个位置&#125;</span></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt; f; <span class="comment">//&lt;石头位置(s[i])，&#123;跳k步可以到s[i]位置的所有k&#125;&gt;  只有有k就说明可达</span></span><br><span class="line"><span class="comment">// 注意用：unordered_set， 而不是vector, 因为vector会翻倍动态扩容</span></span><br><span class="line"><span class="comment">// =======注意：unordered_set可以去重，加入的k可能是重复的=====</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> a: s)&#123;</span><br><span class="line">    f[a] = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">f[s[<span class="number">0</span>]] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> a : s)&#123;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; nexts = f[a];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> next : nexts)&#123;  <span class="comment">// =====遍历的k如果连续则会重复，例如集合中有2，3  取2时考察：1，2，3  取3时考察：2，3，4  有重复所以需要set去重====</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = next<span class="number">-1</span>; k &lt;= next+<span class="number">1</span>; ++k)&#123; </span><br><span class="line">            <span class="keyword">if</span>(f.count(a+k) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                f[a+k].insert(k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f[s[n<span class="number">-1</span>]].<span class="built_in">size</span>() &gt; <span class="number">0</span>; <span class="comment">// 只要最后一个石头集合中有元素就可达</span></span><br></pre></td></tr></table></figure>



<ul>
<li>lint 676</li>
</ul>
<p><img src="/2022/01/26/C++/c++algo/image-20230221094940138.png" alt="image-20230221094940138"></p>
<p><img src="/2022/01/26/C++/c++algo/image-20230221103736840.png" alt="image-20230221103736840"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// f[i]记录s[0,i]数字串的解密方式数 改成  f[i]记录s[0,i-1]数字串的解密方式数 更合适，便于初始化</span></span><br><span class="line"><span class="comment">// f[i] = f[i-1](s[i] != '*') || 9*f[i-1](s[i] == '*') +</span></span><br><span class="line"><span class="comment">//        f[i-2](10&lt;=s[i-1]s[i]&lt;=26) || </span></span><br><span class="line"><span class="comment">//        2*f[i-2](s[i-1] == '*'&amp;&amp; 1&lt;=s[i]&lt;=6) ||   //'*'可以取1，2</span></span><br><span class="line"><span class="comment">//        f[i-2](s[i-1] == '*' &amp;&amp; 7&lt;=s[i]&lt;=9)     //'*'只能取1</span></span><br><span class="line"><span class="comment">//        9*f[i-2](s[i] == '*' &amp;&amp; s[i-1] == 1)</span></span><br><span class="line"><span class="comment">//        6*f[i-2](s[i] == '*' &amp;&amp; s[i-1] == 2)</span></span><br><span class="line"><span class="comment">//        15*f[i-2](s[i-1] == '*' &amp;&amp; s[i] == '*')</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// f[i] = </span></span><br><span class="line"><span class="comment">//        f[i-1] (1&lt;=s[i]&lt;=9) ||</span></span><br><span class="line"><span class="comment">//        9*f[i-1] (s[i] == '*') </span></span><br><span class="line"><span class="comment">//        +</span></span><br><span class="line"><span class="comment">//        f[i-2](10&lt;=s[i-1]s[i]&lt;=26) || </span></span><br><span class="line"><span class="comment">//        2*f[i-2](s[i-1] == '*'&amp;&amp; 1&lt;=s[i]&lt;=6) ||   //'*'可以取1，2</span></span><br><span class="line"><span class="comment">//        f[i-2](s[i-1] == '*' &amp;&amp; 7&lt;=s[i]&lt;=9)     //'*'只能取1</span></span><br><span class="line"><span class="comment">//        9*f[i-2](s[i] == '*' &amp;&amp; s[i-1] == 1)</span></span><br><span class="line"><span class="comment">//        6*f[i-2](s[i] == '*' &amp;&amp; s[i-1] == 2)</span></span><br><span class="line"><span class="comment">//        15*f[i-2](s[i-1] == '*' &amp;&amp; s[i] == '*')</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="comment">// 计算f[0]=1 不使用s中字符的情况</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getOne</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="string">'*'</span>) <span class="keyword">return</span> <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="string">'0'</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// [1,9]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getTwo</span><span class="params">(cahr f, <span class="keyword">char</span> l)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f == <span class="string">'1'</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == <span class="string">'*'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">9</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f == <span class="string">'2'</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == <span class="string">'*'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(l&gt;= <span class="number">0</span> &amp;&amp; l&lt;=<span class="number">6</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f == <span class="string">'*'</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == <span class="string">'*'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">15</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(l&gt;=<span class="number">0</span> &amp;&amp; l &lt;= <span class="number">6</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// [7,9]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">// 没有匹配到[10,26]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(n+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> c = getOne(s[i<span class="number">-1</span>]);</span><br><span class="line">        f[i] += c*f[i<span class="number">-1</span>]; </span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            c = getTwo(s[i<span class="number">-2</span>], s[i<span class="number">-1</span>]);</span><br><span class="line">            f[i] += c*f[i<span class="number">-2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>lint436 最大正方形<ul>
<li>注意<code>f[i][j]</code>记录的内容，<code>f[i][j]可以为0</code></li>
<li>递推公式结合图更好理解，复习</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// f[i][j]记录以m[i][j]为右下角的长方形中正方形最大的边长  f[i][j]可以为0</span></span><br><span class="line"><span class="comment">// f[i][j] = 0 (m[i][j] == 0)</span></span><br><span class="line"><span class="comment">//         = min(f[i-1][j], f[i-1][j-1], f[i][j-1]) + 1 (m[i][j] == 1)</span></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="comment">// f[0][j] = m[0][j]</span></span><br><span class="line"><span class="comment">// f[i][0] = m[i][0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// res = max(f[i][j]^2)</span></span><br></pre></td></tr></table></figure>



<h3 id="L003"><a href="#L003" class="headerlink" title="L003"></a>L003</h3><ul>
<li>记忆化搜索是递归的</li>
<li>动态规划是迭代的  效率更高(不用递归栈，不用重复访问已经计算的结果)</li>
</ul>
<p><img src="/2022/01/26/C++/c++algo/image-20221121101324796.png" alt="image-20221121101324796"></p>
<ul>
<li>斐波拉切数列</li>
</ul>
<p><img src="/2022/01/26/C++/c++algo/image-20221121101506770.png" alt="image-20221121101506770"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//斐波拉切数列</span></span><br><span class="line"><span class="comment">// 动态规划 自底向上</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">memo</span><span class="params">(n+<span class="number">1</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">  memo[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  memo[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">    memo[i] = memo[i<span class="number">-1</span>] + memo[i<span class="number">-2</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> memo[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//记忆化搜索 自顶向下</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; memo;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(memo[n] == <span class="number">-1</span>)&#123;</span><br><span class="line">      memo[n] = fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memo[n];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">fibb</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    memo.resize(n+<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> fib(n);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><ul>
<li>70 <a href="https://leetcode.cn/problems/climbing-stairs/" target="_blank" rel="noopener">爬楼梯</a><ul>
<li>f[n] = f[n-1] + f[n-2]</li>
<li>f[0] = 1 需要使用但不能递推  f[2] = f[1] + f[0] = 2</li>
<li>f[1] = 1 事实</li>
</ul>
</li>
<li>120 <a href="https://leetcode.cn/problems/triangle/" target="_blank" rel="noopener">三角形最小路径和</a><ul>
<li>自己的方案比官答可能更好</li>
<li>f[i,j] = min(f[i+1,j], f[i+1,j+1]) + triangle[i,j]</li>
<li>自底向上，f可以就是triangle节约空间</li>
</ul>
</li>
</ul>
<h4 id="坐标型"><a href="#坐标型" class="headerlink" title="坐标型"></a>坐标型</h4><ul>
<li>62 <a href="https://leetcode.cn/problems/unique-paths/" target="_blank" rel="noopener">不同路径</a><ul>
<li>有数学方法</li>
</ul>
</li>
<li><a href="https://leetcode.cn/problems/unique-paths-ii/" target="_blank" rel="noopener">63. 不同路径 II</a></li>
<li>64 <a href="https://leetcode.cn/problems/minimum-path-sum/" target="_blank" rel="noopener">最小路径和</a></li>
</ul>
<h4 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h4><ul>
<li>198 <a href="https://leetcode.cn/problems/house-robber/" target="_blank" rel="noopener">打家劫舍</a><ul>
<li>经典 复习</li>
<li><code>f[i] = max(f[i-1], f[i-2] + nums[i-1])</code></li>
<li>f[0] = 0 需要使用，但是不能递推</li>
<li>f[1] = nums[0]</li>
<li>可以直接用nums作为f，节省空间</li>
<li><code>nums[i] = max(nums[i-1] , nums[i] + nums[i-2])  i &gt;=2</code></li>
<li>nums[1] = max(nums[0], nums[1])</li>
</ul>
</li>
<li>213  <a href="https://leetcode.cn/problems/house-robber-ii/" target="_blank" rel="noopener"> 打家劫舍 II</a><ul>
<li>可以不用数值记录动态过程，直接用三个值记录并更新即可</li>
<li>分两种情况统计<ul>
<li>nums[0—n-2]  使用0不使用最后一个</li>
<li>nums[1—n-1]  不使用0使用最后一个</li>
<li>最后比较返回这两种情况的中大的那一个</li>
</ul>
</li>
</ul>
</li>
<li>337 <a href="https://leetcode.cn/problems/house-robber-iii/" target="_blank" rel="noopener">打家劫舍 III</a><ul>
<li>看解析， 待复习</li>
<li>关键是构建递推关系</li>
</ul>
</li>
</ul>
<h4 id="零钱类型"><a href="#零钱类型" class="headerlink" title="零钱类型"></a>零钱类型</h4><ul>
<li>322 <a href="https://leetcode.cn/problems/coin-change/" target="_blank" rel="noopener">零钱兑换</a><ul>
<li>记录和为w的最少硬币数</li>
<li>元素可重复</li>
<li>一维数组<ul>
<li>从0—n-1</li>
</ul>
</li>
<li>return f[w]，需要的就是和为w</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// f[j] 记录和为j的最少硬币数</span></span><br><span class="line"><span class="comment">// f[j] = min(f[j-nums[i]]) + 1 ;  0&lt;=i&lt;n;  j &gt;= nums[i]</span></span><br><span class="line"><span class="comment">// f[0] = 0</span></span><br></pre></td></tr></table></figure>

<ul>
<li>377 <a href="https://leetcode.cn/problems/combination-sum-iv/" target="_blank" rel="noopener"> 组合总和 Ⅳ</a><ul>
<li>记录和为w的组合个数</li>
<li>元素可重复</li>
<li>一维数组<ul>
<li>从0—n-1</li>
</ul>
</li>
<li>return f[w]，需要的就是和为w</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* `F[i] = F[i-nums[<span class="number">0</span>]]+ F[i-nums[<span class="number">1</span>]] + ..... + F[i-nums[k]]`</span><br><span class="line">* `F[<span class="number">0</span>] = <span class="number">1</span>`</span><br><span class="line"><span class="comment">// f[j] 记录和为j的组合个数</span></span><br><span class="line"><span class="comment">// f[j] = 和f[j-nums[i]]  0&lt;=i&lt;n</span></span><br><span class="line"><span class="comment">// f[0] = 1</span></span><br><span class="line"><span class="comment">// return f[w]</span></span><br></pre></td></tr></table></figure>



<ul>
<li><p>343 <a href="https://leetcode.cn/problems/integer-break/" target="_blank" rel="noopener"> 整数拆分</a></p>
<ul>
<li>待复习</li>
<li><code>f[i] = max(f[i], max(j*f[i-j], j*(i-j))   1&lt;=j&lt;i</code></li>
<li>f[0]=f[1] = 0</li>
<li>特别注意：调f[i-j]的时候是对i-j的继续拆分，不包括i-j本身  所以需要<code>max(j*f[i-j], j*(i-j)</code></li>
</ul>
</li>
<li><p>279 <a href="https://leetcode.cn/problems/perfect-squares/" target="_blank" rel="noopener"> 完全平方数</a></p>
<ul>
<li>上面学习过，查看以前的记录</li>
<li><code>f[j] = min(f[j-i*i] + 1)  1&lt;=i*i&lt;=j</code></li>
<li>f[0] = 0</li>
</ul>
</li>
<li><p>91 <a href="https://leetcode.cn/problems/decode-ways/" target="_blank" rel="noopener"> 解码方法</a></p>
<ul>
<li>官答更简洁  学习</li>
<li><code>f[i] = f[i-1] + f[i-2]，  s[i-1]-&#39;0&#39; &gt; 0s时可加f[i-1]，  9&lt;(s[i-2]-&#39;0&#39;)*10+(s[i-1]-&#39;0&#39;)&lt;=26时可加f[i-2]</code></li>
<li>f[0] = 1 需要使用，但是不能递推</li>
<li>f[1] = s[0]-‘0’ &gt; 0 ? 1 : 0</li>
</ul>
</li>
<li><p>139 <a href="https://leetcode.cn/problems/word-break/" target="_blank" rel="noopener">单词拆分</a></p>
<ul>
<li><p>记录是否可组合 bool</p>
</li>
<li><p>元素可重复</p>
</li>
<li><p>一维数组</p>
<ul>
<li>从0—n</li>
</ul>
</li>
<li><p>return f[w]</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// f[j]记录是否可以组合成s.substr(0,j)</span></span><br><span class="line"><span class="comment">// f[j] = f[j-w[i].size()]  s.substr(j-w[i].size(), w[i].size()) == w[i]; 0&lt;=i&lt;n    只要满足即可结束循环</span></span><br><span class="line"><span class="comment">// f[0] = true;</span></span><br></pre></td></tr></table></figure>




<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// * 注意i的取值  i可能正好和索引一致从0开始，也可能从索引+1开始</span></span><br><span class="line"><span class="comment">// * 先判断`F[i-wlen]` 因为后面字符串的判断耗时更高   </span></span><br><span class="line">    <span class="comment">// wlen = w.length()  w for wordDict</span></span><br><span class="line">	<span class="comment">// s(i-wlen, wlen) == w   s字符串中[i-wlen,i]是否等于w</span></span><br><span class="line">    <span class="comment">// F[i] = F[i-wlen] &amp;&amp; s(i-wlen, wlen) == w     i-wlen &gt;= 0 i表示从s中取前1-i个数 即[0,i-1]</span></span><br><span class="line">    <span class="comment">// F[0] = true</span></span><br></pre></td></tr></table></figure>







<h4 id="背包问题-1"><a href="#背包问题-1" class="headerlink" title="背包问题"></a><strong>背包问题</strong></h4><blockquote>
<p>问题：</p>
<ul>
<li>背包问题更多变种<ul>
<li>完全背包问题:每个物品可以无限使用</li>
<li>多重背包问题:每个物品不止1个，有num(i)个</li>
<li>多维费用背包问题:要考虑物品的体积和重量两个维度</li>
<li>物品间加入更多约束： 物品间可以互相排斥;也可以互相依赖</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>416 <a href="https://leetcode.cn/problems/partition-equal-subset-sum/" target="_blank" rel="noopener">分割等和子集</a><ul>
<li>记录是否可以  bool</li>
<li>元素不可重复</li>
<li>二维数组  <ul>
<li>从1—n, 0做预处理</li>
</ul>
</li>
<li>return <code>f[n][w]</code>, 最后需要知道的就是n个元素种选若干个是否可以组合成w</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// f[i][j] 记录使用[0,,,i]是否可以和为j  记录为bool</span></span><br><span class="line"><span class="comment">// f[i][j] = f[i-1][j] || f[i-1][j-nums[i-1]]   0&lt;=j&lt;=w;  0&lt;i&lt;=n;  j&gt;=nums[i];</span></span><br><span class="line"><span class="comment">// f[0][0] = true;</span></span><br><span class="line"><span class="comment">// f[0][1---w] = false;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>474 <a href="https://leetcode.cn/problems/ones-and-zeroes/" target="_blank" rel="noopener">一和零</a><ul>
<li>记录最大子集个数</li>
<li>元素不可重复</li>
<li>三维数组，本身限制就是两维<ul>
<li>从1—size，0单独考虑</li>
</ul>
</li>
<li>return <code>f[n][w][k]</code></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从1---size   更便于初始化，更简洁</span></span><br><span class="line">    <span class="comment">// st记录strs中的0，1个数st[i][0]表示strs[i]中0的个数</span></span><br><span class="line">    <span class="comment">// F[i][m][n] = max(F[i-1][m][n], F[i-1][m-st[i-1][0]][n-st[i-1][1]] + 1)  0&lt;i&lt;=n</span></span><br><span class="line">    <span class="comment">// F[0][j][k] = 0 ;  0&lt;=j&lt;=m, 0&lt;=k&lt;=n</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空间优化</span></span><br><span class="line">    <span class="comment">// f[j][k] = max(f[j][k], f[j-st[i-1][0]][k-st[i-1][1]] + 1)    0&lt;i&lt;=n</span></span><br><span class="line">    <span class="comment">// f[j][k] = 0;  0&lt;=j&lt;=m, 0&lt;=k&lt;=n    </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从0---size-1</span></span><br><span class="line">    <span class="comment">// st记录strs中的0，1个数st[i][0]表示strs[i]中0的个数</span></span><br><span class="line">    <span class="comment">// F[i][m][n] = max(F[i-1][m][n], F[i-1][m-st[i][0]][n-st[i][1]] + 1)</span></span><br><span class="line">    <span class="comment">// F[0][j][k] = 1 j &gt;= st[0][0] k&gt;= st[0][1] // 最多j个0  最多k个1</span></span><br><span class="line">    <span class="comment">// F[0][j][k] = 0 j &lt; st[0][0] &lt; st[0][1]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//优化</span></span><br><span class="line">	<span class="comment">// 改为滚动数组</span></span><br><span class="line">    <span class="comment">// 循环提前终止</span></span><br><span class="line">    <span class="comment">// 每个string的0 1个数实时计算，节省空间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// zero: 0的个数  one： 1的个数</span></span><br><span class="line">    <span class="comment">// F[m][n] = max(F[m][n], F[m-zero][n-one] + 1)</span></span><br><span class="line">    <span class="comment">// F[j][k] = 1 j &gt;= zero k&gt;= one // 最多j个0  最多k个1 循环提前终止</span></span><br><span class="line">    <span class="comment">// F[j][k] = 0 j &lt; zero k &lt; one  一开始都初始化为0</span></span><br></pre></td></tr></table></figure>


<ul>
<li>494 <a href="https://leetcode.cn/problems/target-sum/" target="_blank" rel="noopener"> 目标和</a><ul>
<li>自己的方法<ul>
<li>虽然使用了动态规划，但问题过于复杂，没有对问题简化再用动态规划</li>
</ul>
</li>
<li>官方解答<ul>
<li><strong>先将问题简化，再使用动态规划</strong>   这种方式很重要，以后做题要注意</li>
<li><code>记数组的元素和为 sum，添加 - 号的元素之和为 neg，则其余添加 + 的元素之和为 sum-neg，得到的表达式的结果为 (sum - neg) - neg = target, 即neg = (sum - target) / 2,  由于数组 nums 中的元素都是非负整数, neg 也必须是非负整数，所以上式成立的前提是 sum−target 是非负偶数。若不符合该条件可直接返回 0</code><ul>
<li>注意是非负偶数，1非负，2偶数</li>
</ul>
</li>
<li>问题就转化为在数组中选取一些元素，使得和为neg，并记录有多少种这样的选择（将这些元素添加 -  号 就可以满足上式）<ul>
<li>记录和为neg的组合数</li>
<li>元素不可重复</li>
<li>二维数组<ul>
<li>从1—n, 0初始化用</li>
</ul>
</li>
<li>return<code>f[n][neg]</code>, 因为要求的就是和为neg</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// self</span></span><br><span class="line">	<span class="comment">// target += 1000  便于对负数处理</span></span><br><span class="line">    <span class="comment">// F[i][j] = F[i-1][j-nums[i]] + F[i-1][j+nums[i]]    j-nums[i]&gt;=0  j+nums[i]&lt;= 2000   0&lt;=j&lt;=2000</span></span><br><span class="line">    <span class="comment">// 不能空间优化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 官方</span></span><br><span class="line">    <span class="comment">// 从nums种选取若干元素使得和为neg</span></span><br><span class="line">    <span class="comment">// F[i][j] = F[i-1][j] + F[i-1][j-nums[i]]  0&lt;=j&lt;=neg  j&gt;=nums[i]</span></span><br><span class="line">    <span class="comment">// 空间优化</span></span><br><span class="line">    <span class="comment">// F[j] = F[j] + F[j-nums[i]]</span></span><br><span class="line">    <span class="comment">// F[0] = 1;</span></span><br></pre></td></tr></table></figure>

<h4 id="最长子序列LIS"><a href="#最长子序列LIS" class="headerlink" title="最长子序列LIS"></a><strong>最长子序列LIS</strong></h4><blockquote>
<p>最长非连续递增子序列</p>
</blockquote>
<ul>
<li>300 <a href="https://leetcode.cn/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">最长递增子序列</a><ul>
<li>动态规划  O(n*n)<ul>
<li>return 遍历数组</li>
</ul>
</li>
<li>贪心算法  O(nlogn)</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="comment">// F[i] 记录以nums[i]结尾的最长子序列长度</span></span><br><span class="line"><span class="comment">// F[i] = max(F[j]+1  if(nums[j] &lt; nums[i]))   0&lt;= j &lt; i</span></span><br><span class="line"><span class="comment">// 初始化都为1 因为自己本身就为1个</span></span><br><span class="line"><span class="comment">// 注意+1时灵活处理，因为if(nums[j] &lt; nums[i])可能导致进入不了max(F[j]+1) 从而没有+1, 但这个元素本身也是一个子序列 （前面元素都大于等于当前元素的情况）, 一开始初始化都为1则不用考虑这种情况，因为自己本身已经考虑进去了</span></span><br><span class="line"><span class="comment">// 注意最后返回的不是f[n]  而是遍历f找到最大值，因为nums[n-1]不一定在最长序列里</span></span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 贪心</span></span><br><span class="line"><span class="comment">// 从栈的角度理解就清晰了</span></span><br><span class="line"><span class="comment">//f[i]表示长度为 i 的最长上升子序列的末尾元素的最小值</span></span><br><span class="line">以输入序列 [<span class="number">0</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">12</span>,<span class="number">2</span>][<span class="number">0</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">12</span>, <span class="number">2</span>][<span class="number">0</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">12</span>,<span class="number">2</span>] 为例：</span><br><span class="line"></span><br><span class="line">第一步插入 <span class="number">000</span>，d=[<span class="number">0</span>]d = [<span class="number">0</span>]d=[<span class="number">0</span>]；</span><br><span class="line"></span><br><span class="line">第二步插入 <span class="number">888</span>，d=[<span class="number">0</span>,<span class="number">8</span>]d = [<span class="number">0</span>, <span class="number">8</span>]d=[<span class="number">0</span>,<span class="number">8</span>]；</span><br><span class="line"></span><br><span class="line">第三步插入 <span class="number">444</span>，d=[<span class="number">0</span>,<span class="number">4</span>]d = [<span class="number">0</span>, <span class="number">4</span>]d=[<span class="number">0</span>,<span class="number">4</span>]；</span><br><span class="line"></span><br><span class="line">第四步插入 <span class="number">121212</span>，d=[<span class="number">0</span>,<span class="number">4</span>,<span class="number">12</span>]d = [<span class="number">0</span>, <span class="number">4</span>, <span class="number">12</span>]d=[<span class="number">0</span>,<span class="number">4</span>,<span class="number">12</span>]；</span><br><span class="line"></span><br><span class="line">第五步插入 <span class="number">222</span>，d=[<span class="number">0</span>,<span class="number">2</span>,<span class="number">12</span>]d = [<span class="number">0</span>, <span class="number">2</span>, <span class="number">12</span>]d=[<span class="number">0</span>,<span class="number">2</span>,<span class="number">12</span>]。 <span class="comment">// 这里用2替换4,只是更新f[1] = 2, 当考虑长度为2的最长上升子序列时，确实应该是0，2  而不是0，4。在2之后有比12小的且比2大的则直接可以替换12</span></span><br></pre></td></tr></table></figure>



<ul>
<li><p>376 <a href="https://leetcode.cn/problems/wiggle-subsequence/" target="_blank" rel="noopener"> 摆动序列</a></p>
<ul>
<li><p>self  O(n*n)</p>
<ul>
<li>受上面300的影响，思路受限制</li>
</ul>
</li>
<li><p>官方 O(n)</p>
<ul>
<li>只考虑前一个元素</li>
<li>有难度，想不到只考虑前一个元素</li>
<li>关键理解点：<ul>
<li>当 nums[i]≤nums[i−1]\textit{nums}[i] \leq \textit{nums}[i - 1]nums[i]≤nums[i−1] 时，我们无法选出更长的「上升摆动序列」的方案。因为对于任何以 nums[i]\textit{nums}[i]nums[i] 结尾的「上升摆动序列」，我们都可以将 nums[i]\textit{nums}[i]nums[i] 替换为 nums[i−1]\textit{nums}[i - 1]nums[i−1]，使其成为以 nums[i−1]\textit{nums}[i - 1]nums[i−1] 结尾的「上升摆动序列」</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//self</span></span><br><span class="line">    <span class="comment">// F表示当前值减去前面的为正  N表示当前值减去前面的为负</span></span><br><span class="line">    <span class="comment">// F[i] = max(N[j]+1)  nums[i] - nums[j] &gt; 0     0&lt;=j&lt;i</span></span><br><span class="line">    <span class="comment">// N[i] = max(F[j]+1)  nums[i] - nums[j] &lt; 0     0&lt;=j&lt;i</span></span><br><span class="line"><span class="comment">//官方</span></span><br><span class="line">    <span class="comment">// F表示当前值减去前面的为正  N表示当前值减去前面的为负</span></span><br><span class="line">    <span class="comment">// F[i] = max(F[i-1], N[i-1]+1) if(nums[i]&gt;nums[i-1])</span></span><br><span class="line">    <span class="comment">// F[i] = F[i-1] if(nums[i]&lt;=nums[i-1])  本来需要上升，但不符合条件 则记录前一个上升的值</span></span><br><span class="line">    <span class="comment">// N[i] = max(N[i-1], F[i-1]+1)  if(nums[i]&lt;nums[i-1])</span></span><br><span class="line">    <span class="comment">// N[i] = N[i-1] if(nums[i]&gt;=nums[i-1])  本来需要下降（从F[i-1]过来） 但不符合条件 则记录上一个下降的值（N[i-1]）  即忽略nums[i]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空间优化</span></span><br><span class="line">    <span class="comment">// f = max(f, n+1) if(nums[i]&gt;nums[i-1])</span></span><br><span class="line">    <span class="comment">// f = f if(nums[i]&lt;=nums[i-1]) </span></span><br><span class="line">    <span class="comment">// n = max(n, f+1)  if(nums[i]&lt;nums[i-1])</span></span><br><span class="line">    <span class="comment">// n = n if(nums[i]&gt;=nums[i-1]) </span></span><br><span class="line">    <span class="comment">// 初始化 f = 1, n = 1;</span></span><br></pre></td></tr></table></figure>

<h4 id="最长公共子序列-子串"><a href="#最长公共子序列-子串" class="headerlink" title="最长公共子序列/子串"></a>最长公共子序列/子串</h4><ul>
<li><a href="https://leetcode.cn/problems/qJnOS7/description/" target="_blank" rel="noopener">LCR 095. 最长公共子序列</a></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// F[i][j] 记录前i个元素和前j个元素的最长公共子序列</span></span><br><span class="line"><span class="comment">// F[i][j] = F[i-1][j-1] + 1 if(s1[i] == s2[j]) </span></span><br><span class="line"><span class="comment">// F[i][j] = max(F[i-1][j], F[i][j-1]) if(s1[i] != s2[j])</span></span><br></pre></td></tr></table></figure>

<ul>
<li>最长公共子串</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// F[i][j] 记录以i结尾和以j结尾的最长公共子串</span></span><br><span class="line"><span class="comment">// 需要更新res = max(res, F[i][j]) 得到最终结果</span></span><br><span class="line"><span class="comment">// F[i][j] = F[i-1][j-1] + 1 if(s1[i] == s2[j]) </span></span><br><span class="line"><span class="comment">// F[i][j] = 0 if(s1[i] != s2[j])</span></span><br></pre></td></tr></table></figure>



<h4 id="最长回文子序列-子串"><a href="#最长回文子序列-子串" class="headerlink" title="最长回文子序列/子串"></a>最长回文子序列/子串</h4><ul>
<li><a href="https://leetcode.cn/problems/longest-palindromic-substring/description/" target="_blank" rel="noopener">5最长回文子串</a><ul>
<li>动态规划，远不如中心扩展法</li>
<li>中心扩展法, 可以去提前结束循环，所以效率更高</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划   看leetcode笔记</span></span><br><span class="line"><span class="comment">// f[i][j] = f[i+1][j-1]  s[i] == s[j]  </span></span><br><span class="line"><span class="comment">// f[i][j] = false  s[i] != s[j]</span></span><br><span class="line"><span class="comment">// f[i][j] 为true时更新最长子串</span></span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://leetcode.cn/problems/longest-palindromic-subsequence/description/" target="_blank" rel="noopener">516最长回文子序列</a></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// f[i][j] = f[i+1][j-1] + 2  s[i] == s[j]                    注意是+2</span></span><br><span class="line">        <span class="comment">// f[i][j] = max(f[i+1][j], f[i][j-1])  s[i] != s[j]</span></span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="comment">// f[i][i] = 1  其它为0， 因为是+2</span></span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">f</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            f[i][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n- <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == s[j])&#123;</span><br><span class="line">                    f[i][j] = f[i+<span class="number">1</span>][j<span class="number">-1</span>] + <span class="number">2</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    f[i][j] = <span class="built_in">max</span>(f[i+<span class="number">1</span>][j], f[i][j<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">0</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="编辑距离-amp-正则匹配"><a href="#编辑距离-amp-正则匹配" class="headerlink" title="编辑距离&amp;正则匹配"></a>编辑距离&amp;正则匹配</h4><ul>
<li>10<a href="https://leetcode.cn/problems/regular-expression-matching/description/" target="_blank" rel="noopener">正则表达式匹配</a></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// f[i][j] 记录s的前i个元素是否可以用p的前j个元素匹配 bool</span></span><br><span class="line"><span class="comment">// f[i][j] = f[i-1][j-1]  s[i-1] == p[j-1] || p[j-1] == '.'</span></span><br><span class="line"><span class="comment">// f[i][j] = f[i][j-2]  p[j-1] == '*'  不使用*</span></span><br><span class="line"><span class="comment">// f[i][j] = f[i-1][j]  p[j-1] == '*' &amp;&amp; ( p[j-2] == '.' || p[i-2] == s[i-1])</span></span><br><span class="line"><span class="comment">//      使用*，但是.*是可以匹配多个的，所以可能也会给是s[i-2]用，所以等于f[i-1][j]</span></span><br><span class="line"><span class="comment">//      如果s[i-2]也匹配了*,那就是f[i-1][j]， 如果不匹配，那就是对于s[i-2]，*匹配0次，即f[i-1][j] = f[i-1][j-2]</span></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="comment">// f[0][0] = true</span></span><br><span class="line"><span class="comment">// f[1-n][0] = false</span></span><br><span class="line"><span class="comment">// f[0][1-m] = f[0][j-2] &amp;&amp; p[j-1] == '*'</span></span><br></pre></td></tr></table></figure>

<ul>
<li>72<a href="https://leetcode.cn/problems/edit-distance/description/" target="_blank" rel="noopener">编辑距离</a></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// f[i][j] 记录w1转换为w2的最少操作次数</span></span><br><span class="line"><span class="comment">// f[i][j] = f[i-1][j-1]   w1[i-1] == w2[j-1]</span></span><br><span class="line"><span class="comment">// f[i][j] = f[i-1][j-1] + 1  w1[i-1] != w2[j-1] 替换</span></span><br><span class="line"><span class="comment">// f[i][j] = f[i][j-1] + 1  w1[i-1] != w2[j-1] 插入  插入的元素和w2[j-1]匹配，则需要w1[i-1]与w2[j-2]匹配即f[i][j-1]</span></span><br><span class="line"><span class="comment">// f[i][j] = f[i-1][j] + 1  w1[i-1] != w2[j-1] 删除  删除w1[i-1], 则需要w1[i-2]与w2[j-1]匹配即f[i-1][j]</span></span><br><span class="line"><span class="comment">// f[i][j] =  min(f[i-1][j-1] 相等 ,f[i-1][j] +1 删除, f[i-1][j-1]+1 替换, f[i][j-1]+1 插入) </span></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="comment">// f[0][0,,j,,m] = j  插入</span></span><br><span class="line"><span class="comment">// f[0,,i,,n][0] = i  删除</span></span><br></pre></td></tr></table></figure>



<h4 id="股票相关题目"><a href="#股票相关题目" class="headerlink" title="股票相关题目"></a>股票相关题目</h4><ul>
<li><p>309 <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">最佳买卖股票时机含冷冻期</a></p>
<ul>
<li>没有思路，看解析，待复习</li>
</ul>
</li>
<li><p>121  只交易一次</p>
<ul>
<li>动态规划<ul>
<li>方式1：<ul>
<li>从0到N-1枚举j，即第几天卖</li>
<li>时刻保存当前为止(即0~j-1天)的最低价格Pi</li>
<li>最大的Pj-Pi即为答案</li>
</ul>
</li>
<li>方式2：</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 方式2</span><br><span class="line">&#x2F;&#x2F; h: 持有</span><br><span class="line"> &#x2F;&#x2F; n: 不持有</span><br><span class="line"> &#x2F;&#x2F; h[i] &#x3D; max(h[i-1], -prices[i])</span><br><span class="line"> &#x2F;&#x2F; n[i] &#x3D; max(n[i-1], h[i-1]+prices[i])</span><br><span class="line"> &#x2F;&#x2F; h[0] &#x3D; -prices[0]</span><br><span class="line"> &#x2F;&#x2F; n[0] &#x3D; 0</span><br></pre></td></tr></table></figure>



<ul>
<li>122 交易次数不限制<ul>
<li>方法1: 动态规划</li>
<li>方法2：贪心       记录所有递增段 <ul>
<li>只要当前值大于前继值则它们的差值就是获利，累加所有的获利就是最终获利（交易次数不限制）</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">方法1: 动态规划</span><br><span class="line">&#x2F;&#x2F; h: 持有</span><br><span class="line">&#x2F;&#x2F; n: 不持有</span><br><span class="line">&#x2F;&#x2F; h[i] &#x3D; max(h[i-1], n[i-1]-prices[i])</span><br><span class="line">&#x2F;&#x2F; n[i] &#x3D; max(n[i-1], h[i-1]+prices[i])</span><br><span class="line">&#x2F;&#x2F; h[0] &#x3D; -prices[0]</span><br><span class="line">&#x2F;&#x2F; n[0] &#x3D; 0</span><br></pre></td></tr></table></figure>



<ul>
<li>123 限制两次交易<ul>
<li>先写出动态规划递归公式，再对应写出空间优化公式</li>
<li>注意初始化时，不能太在意交易次数</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// F: 持有</span></span><br><span class="line">    <span class="comment">// N: 不持有 </span></span><br><span class="line">    <span class="comment">// i: 天 j: 交易次数  0&lt;=j&lt;=2</span></span><br><span class="line">    <span class="comment">// F[i][2] = max(F[i-1][2], N[i-1][1]-prices[i])  buy2</span></span><br><span class="line">    <span class="comment">// F[i][1] = max(F[i-1][1], N[i-1][0]-prices[i])  buy1     N[i-1][0] == 0 (交易0次)</span></span><br><span class="line">    <span class="comment">// N[i][2] = max(N[i-1][2], F[i-1][2]+prices[i])  sell2</span></span><br><span class="line">    <span class="comment">// N[i][1] = max(N[i-1][1], F[i-1][1]+prices[i])  sell1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// buy2 = max(buy2, sell1 - prices[i])</span></span><br><span class="line">    <span class="comment">// buy1 = max(buy1, -prices[i]);</span></span><br><span class="line">    <span class="comment">// sell2 = max(sell2, buy2+prices[i])</span></span><br><span class="line">    <span class="comment">// sell1 = max(sell1, buy1+prices[i])</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// buy2 = F[0][2] = - prices[0]   虽然不可能0时交易2次，但是表示持有只能是- prices[0]</span></span><br><span class="line">    <span class="comment">// buy1 = F[0][1] = - prices[0]</span></span><br><span class="line">    <span class="comment">// sell2 = N[0][2] = 0   虽然不持有状态不可能0时交易2次  但表示不不持有状态</span></span><br><span class="line">    <span class="comment">// sell1 = N[0][1] = 0   虽然不持有状态不可能0时交易1次  但表示不不持有状态</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> buy2 = -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> buy1 = -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> sell2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sell1 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">      buy2 = <span class="built_in">max</span>(buy2, sell1 - prices[i]);</span><br><span class="line">      buy1 = <span class="built_in">max</span>(buy1, -prices[i]);</span><br><span class="line">      sell2 = <span class="built_in">max</span>(sell2, buy2+prices[i]);</span><br><span class="line">      sell1 = <span class="built_in">max</span>(sell1, buy1+prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(sell1, sell2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<ul>
<li>188  限制k次交易<ul>
<li>当k&gt;=N/2时就等于是不限制交易次数，可以直接用122中的方法<ul>
<li>因为即使不限制交易次数，最多也就交易N/2次</li>
<li>连续买卖可以合并（1买2卖，2买3卖  可以合并为1买3卖）</li>
</ul>
</li>
<li>先写出动态规划递归公式，再对应写出空间优化公式</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// F: 持有</span></span><br><span class="line">    <span class="comment">// N: 不持有 </span></span><br><span class="line">    <span class="comment">// i: 天 j: 交易次数  0&lt;=j&lt;=2</span></span><br><span class="line">    <span class="comment">// F[i][j] = max(F[i-1][j], N[i-1][j-1]-prices[i])  </span></span><br><span class="line">    <span class="comment">// N[i][j] = max(N[i-1][j], F[i-1][j]+prices[i])  </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// F[j] = max(F[j], N[j-1]-prices[i])  </span></span><br><span class="line">    <span class="comment">// N[j] = max(N[j], F[j]+prices[i])  </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//F[j] = -prices[0]    0&lt;= j &lt;=k</span></span><br><span class="line">    <span class="comment">//N[j] = 0             0&lt;= j &lt;=k</span></span><br><span class="line">    <span class="keyword">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(k&gt;= n/<span class="number">2</span>)&#123; <span class="comment">// 直接不用考虑次数限制</span></span><br><span class="line">      <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices[i] &gt; prices[i<span class="number">-1</span>])&#123;</span><br><span class="line">          res += prices[i] - prices[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; F(k+1), N(k+1);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">0</span>; j &lt;=k;++j)&#123;</span><br><span class="line">      F[j] = -prices[<span class="number">0</span>];</span><br><span class="line">      N[j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;  <span class="comment">// i == 0y</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;=k; ++j)&#123;</span><br><span class="line">        F[j] = <span class="built_in">max</span>(F[j], N[j<span class="number">-1</span>]-prices[i]); </span><br><span class="line">        N[j] = <span class="built_in">max</span>(N[j], F[j]+prices[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; a : N)&#123;</span><br><span class="line">      res = <span class="built_in">max</span>(res, a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<ul>
<li>309  含冷冻期<ul>
<li>先写出动态规划递归公式，再对应写出空间优化公式</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// F: 持有</span></span><br><span class="line">    <span class="comment">// N: 不持有 </span></span><br><span class="line">    <span class="comment">// i: 天 j: 交易次数  0&lt;=j&lt;=2</span></span><br><span class="line">    <span class="comment">// F[i] = max(F[i-1], N[i-2]-prices[i])  </span></span><br><span class="line">    <span class="comment">// N[i] = max(N[i-1], F[i-1]+prices[i])  </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// buy = max(buy, profit_freeze - prices[i])  </span></span><br><span class="line">    <span class="comment">// sell = max(sell, buy + prices[i])  </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// buy = -prices[0]</span></span><br><span class="line">    <span class="comment">// sell = 0</span></span><br><span class="line">    <span class="comment">// profit_freeze = 0    N[i-2] 当i-2小于0时N[i-2]就是0 </span></span><br><span class="line">    <span class="keyword">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> buy = -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> sell = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> profit_freeze = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">      <span class="keyword">int</span> temp = sell ;  <span class="comment">// 记录N[i-2]</span></span><br><span class="line">      buy = <span class="built_in">max</span>(buy, profit_freeze - prices[i]);  </span><br><span class="line">      sell = <span class="built_in">max</span>(sell, buy + prices[i]);</span><br><span class="line">      profit_freeze = temp;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sell;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<ul>
<li>714  有交易费<ul>
<li>方法1：记录下所有上升段，上升段差值大于交易非则计入收益</li>
<li>方法2：动态规划<ul>
<li>先写出动态规划递归公式，再对应写出空间优化公式</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// F: 持有</span></span><br><span class="line">    <span class="comment">// N: 不持有 </span></span><br><span class="line">    <span class="comment">// i: 天 j: 交易次数  0&lt;=j&lt;=2</span></span><br><span class="line">    <span class="comment">// F[i] = max(F[i-1], N[i-1]-prices[i]-fee)  </span></span><br><span class="line">    <span class="comment">// N[i] = max(N[i-1], F[i-1]+prices[i])  </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// buy = max(buy, profit_freeze - prices[i] - fee )  </span></span><br><span class="line">    <span class="comment">// sell = max(sell, buy + prices[i]) </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// buy = -prices[0] - fee</span></span><br><span class="line">    <span class="comment">// sell = 0 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> buy = -prices[<span class="number">0</span>] - fee;</span><br><span class="line">    <span class="keyword">int</span> sell = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">      buy = <span class="built_in">max</span>(buy, sell - prices[i] - fee);  </span><br><span class="line">      sell = <span class="built_in">max</span>(sell, buy + prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sell;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C-algorithm/" rel="tag"># C++algorithm</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/01/26/C++/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/" rel="prev" title="C++核心编程">
      <i class="fa fa-chevron-left"></i> C++核心编程
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/01/26/C++/C++interview/" rel="next" title="C++interview">
      C++interview <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#一"><span class="nav-text">一</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#排序算法"><span class="nav-text">排序算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#工具函数"><span class="nav-text">工具函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#桶排序、计数排序、基数排序"><span class="nav-text">桶排序、计数排序、基数排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#选择排序"><span class="nav-text">选择排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#插入排序"><span class="nav-text">插入排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#希尔排序"><span class="nav-text">希尔排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#归并排序"><span class="nav-text">归并排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#归并求解逆序对"><span class="nav-text">归并求解逆序对</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#快速排序"><span class="nav-text">快速排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#快排优化版本"><span class="nav-text">快排优化版本</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#两路快排"><span class="nav-text">两路快排</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三路快排"><span class="nav-text">三路快排</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#快排求解第n大元素"><span class="nav-text">快排求解第n大元素</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#堆排序"><span class="nav-text">堆排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#构建堆"><span class="nav-text">构建堆</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#堆排序-1"><span class="nav-text">堆排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#索引堆"><span class="nav-text">索引堆</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#堆的应用"><span class="nav-text">堆的应用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#排序算法总结"><span class="nav-text">排序算法总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#搜索算法"><span class="nav-text">搜索算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#二分查找法"><span class="nav-text">二分查找法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二分搜索树"><span class="nav-text">二分搜索树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#并查集"><span class="nav-text">并查集</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Quick-Find"><span class="nav-text">Quick Find</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Quick-Union"><span class="nav-text">Quick Union</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Quick-Union的优化"><span class="nav-text">Quick Union的优化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#基于size的优化"><span class="nav-text">基于size的优化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#基于rank的优化"><span class="nav-text">基于rank的优化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#路径压缩"><span class="nav-text">路径压缩</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#图论"><span class="nav-text">图论</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#图论基础"><span class="nav-text">图论基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#邻边迭代器"><span class="nav-text">邻边迭代器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#读取图"><span class="nav-text">读取图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#深度优先遍历"><span class="nav-text">深度优先遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#寻路"><span class="nav-text">寻路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#广度优先遍历"><span class="nav-text">广度优先遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#最小生成树"><span class="nav-text">最小生成树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#有权图"><span class="nav-text">有权图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#边的定义"><span class="nav-text">边的定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#邻接矩阵构建图"><span class="nav-text">邻接矩阵构建图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#邻接表构建矩阵"><span class="nav-text">邻接表构建矩阵</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#读取并构建带权图"><span class="nav-text">读取并构建带权图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#最小堆"><span class="nav-text">最小堆</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#最小索引堆"><span class="nav-text">最小索引堆</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Prim算法"><span class="nav-text">Prim算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#切分定理"><span class="nav-text">切分定理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Lazy-Prim"><span class="nav-text">Lazy Prim</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Prim"><span class="nav-text">Prim</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Kruskal算法"><span class="nav-text">Kruskal算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#最短路径"><span class="nav-text">最短路径</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#dijkstra算法"><span class="nav-text">dijkstra算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bellman-Ford算法"><span class="nav-text">Bellman-Ford算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#拓展"><span class="nav-text">拓展</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字典树（Trie树）"><span class="nav-text">字典树（Trie树）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二"><span class="nav-text">二</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#动态规划"><span class="nav-text">动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#专题"><span class="nav-text">专题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#坐标型动态规划"><span class="nav-text">坐标型动态规划</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#位操作型动态规划"><span class="nav-text">位操作型动态规划</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#序列型动态规划"><span class="nav-text">序列型动态规划</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#划分型动态规划"><span class="nav-text">划分型动态规划</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#博弈型动态规划"><span class="nav-text">博弈型动态规划</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#背包问题"><span class="nav-text">背包问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#区间型动态规划"><span class="nav-text">区间型动态规划</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#双序列型动态规划"><span class="nav-text">双序列型动态规划</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Hard"><span class="nav-text">Hard</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#L003"><span class="nav-text">L003</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基础"><span class="nav-text">基础</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#坐标型"><span class="nav-text">坐标型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#打家劫舍"><span class="nav-text">打家劫舍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#零钱类型"><span class="nav-text">零钱类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#背包问题-1"><span class="nav-text">背包问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#最长子序列LIS"><span class="nav-text">最长子序列LIS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#最长公共子序列-子串"><span class="nav-text">最长公共子序列&#x2F;子串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#最长回文子序列-子串"><span class="nav-text">最长回文子序列&#x2F;子串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#编辑距离-amp-正则匹配"><span class="nav-text">编辑距离&amp;正则匹配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#股票相关题目"><span class="nav-text">股票相关题目</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Chuckie"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Chuckie</p>
  <div class="site-description" itemprop="description">Bright future</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">116</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">57</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">100</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/ChuckieWill" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ChuckieWill" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/codewyj.163.com" title="E-Mail → codewyj.163.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.jianshu.com/u/de627226656c" title="https:&#x2F;&#x2F;www.jianshu.com&#x2F;u&#x2F;de627226656c" rel="noopener" target="_blank">简书</a>
        </li>
    </ul>
  </div>

      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="/images/me.png"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chuckie</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">1.1m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">17:05</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
