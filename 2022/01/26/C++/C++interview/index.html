<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="todo2 对象默认提供哪些方法">
<meta property="og:type" content="article">
<meta property="og:title" content="C++interview">
<meta property="og:url" content="http://yoursite.com/2022/01/26/C++/C++interview/index.html">
<meta property="og:site_name" content="Chuckie&#39;s Blog">
<meta property="og:description" content="todo2 对象默认提供哪些方法">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/C++interview/image-20230309165501713.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/C++interview/image-20230309170205226.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/C++interview/image-20230309171645814.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/C++interview/image-20221230205527599.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/C++interview/image-20221230205605502.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/C++interview/image-20221230205938019.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/C++interview/image-20230105173126413.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/C++interview/image-20230105173147951.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/C++interview/image-20230106145803859.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/C++interview/image-20230106150451923.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/C++interview/image-20230106162000294.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/C++interview/image-20230106162216358.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/C++interview/image-20230106163315995.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/C++interview/image-20230109135327435.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/C++interview/image-20230701153053180.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/C++interview/image-20230701160652026.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/C++interview/image-20230701163820134.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/C++interview/image-20230321194637445.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/C++interview/image-20230322101245842.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/C++interview/image-20230322101607489.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/C++interview/image-20230322102117770.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/C++interview/image-20230420205210767.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/C++interview/image-20230420205013208.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-Wireshark/19.jpg">
<meta property="article:published_time" content="2022-01-26T06:43:17.000Z">
<meta property="article:modified_time" content="2024-09-18T15:06:07.247Z">
<meta property="article:author" content="Chuckie">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2022/01/26/C++/C++interview/image-20230309165501713.png">

<link rel="canonical" href="http://yoursite.com/2022/01/26/C++/C++interview/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>C++interview | Chuckie's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Chuckie's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/01/26/C++/C++interview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Chuckie">
      <meta itemprop="description" content="Bright future">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chuckie's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++interview
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-26 14:43:17" itemprop="dateCreated datePublished" datetime="2022-01-26T14:43:17+08:00">2022-01-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-09-18 23:06:07" itemprop="dateModified" datetime="2024-09-18T23:06:07+08:00">2024-09-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>94k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1:25</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h1><p>2 对象默认提供哪些方法</p>
<ul>
<li>默认构造函数</li>
<li>拷贝构造函数</li>
<li>赋值运算符</li>
<li>析构函数</li>
</ul>
<p>3 C++—全局对象、局部对象、静态对象 ???<br>4 进程同步方式： 信号量，管程，互斥锁</p>
<h1 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h1><h3 id="对象开辟堆区注意事项"><a href="#对象开辟堆区注意事项" class="headerlink" title="对象开辟堆区注意事项"></a>对象开辟堆区注意事项</h3><blockquote>
<p>对象内使用需要开辟堆区空间的对象时最好的解决方案是不要调用默认构造函数，<strong>直接用初始化列表初始化</strong>，不要在构造函数中初始化</p>
</blockquote>
<p><strong>构造函数和析构函数注意事项</strong></p>
<ul>
<li>由于对象需要开辟堆区，在析构时需要释放堆区，但是如果是通过默认构造函数初始化对象，就没有开辟堆区，所以在析构时就会对没有开辟空间的地址执行释放空间的操作，这就会导致程序奔溃<ul>
<li>总结：<strong>对象有堆区，则在默认构造和有参构造等构造函数中一定要将指针初始化(nullptr或实际的值)</strong></li>
<li>如果不赋初始值，指针指向不明确，<strong>指针不会默认是nullptr</strong>，所以在析构函数中不会判断为空，会进行delete，此时delete的地址不明确则会报错</li>
</ul>
</li>
</ul>
<p><strong>拷贝构造函数注意事项</strong></p>
<ul>
<li>对于堆指针的初始化一定要谨慎，要判断原对象是否开辟过堆空间，若开辟过才进行深拷贝，否则也要将指针初始化为NULL<ul>
<li>总结：<strong>拷贝构造函数中也要保证堆指针初始化了</strong></li>
</ul>
</li>
</ul>
<p><strong>对象开辟堆区的情况，最好重载运算符，避免浅拷贝导致的内存访问出错</strong></p>
<ul>
<li>默认构造一个对象，将有参构造的一个临时对象通过等号运算符赋值给默认构造的对象时，由于是浅拷贝，就会导致默认构造函数在析构时析构的时临时对象的堆地址，但临时对象已经释放过堆区了，这就会导致堆区的多次释放，产生错误<ul>
<li>总结：<strong>对象有堆区，一定要自定义拷贝构造和”=”构造，实现深拷贝</strong></li>
</ul>
</li>
</ul>
<p><strong>”=“号运算符重载后不适用于临时对象的赋值</strong></p>
<ul>
<li>因为”=”后面赋值的是一个临时变量(右值), 所以重载”=”传入的参数应该为右值引用</li>
</ul>
<p><strong>对象A作为对象B的成员变量</strong></p>
<ul>
<li>初始化对象成员变量最好用初始化列表，这样只用只用构造一次，下面Test2的方式</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> item&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinHeap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  item* id;</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  MinHeap(<span class="keyword">int</span> n)&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"MinHeap: 有参构造函数..."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">size</span> = n;</span><br><span class="line">    id = <span class="keyword">new</span> item[n];</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  MinHeap(): id(<span class="literal">NULL</span>), <span class="built_in">size</span>(<span class="number">0</span>)&#123;  <span class="comment">// 有指针的情况下，最好初始化为NULL</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"MinHeap: 默认构造函数..."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  MinHeap(<span class="keyword">const</span> MinHeap&amp; mp)&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"MinHeap: 拷贝构造函数..."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">size</span> = mp.<span class="built_in">size</span>;</span><br><span class="line">    <span class="keyword">if</span>(mp.id != <span class="literal">NULL</span>)&#123; <span class="comment">// mp的id有开辟堆空间才需要执行下面操作，否则直接执行下面操作会报错，因为取地址时会报错</span></span><br><span class="line">      id = <span class="keyword">new</span> item[mp.<span class="built_in">size</span>];</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; mp.<span class="built_in">size</span>; ++i)&#123;</span><br><span class="line">        id[i] = mp.id[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      id = <span class="literal">NULL</span>;  <span class="comment">// 若mp的id为NULL,则也要初始化为NULL</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 移动构造</span></span><br><span class="line">  MinHeap(MinHeap&amp;&amp; mp)&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"MinHeap: 移动构造函数..."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">size</span> = mp.<span class="built_in">size</span>;</span><br><span class="line">    id = mp.id;</span><br><span class="line">    mp.id = <span class="literal">NULL</span>; <span class="comment">// 防止析构时重复释放</span></span><br><span class="line">  &#125;</span><br><span class="line">  MinHeap&amp; <span class="keyword">operator</span>=(MinHeap&amp; mp)&#123;  <span class="comment">//  **”=“号运算符重载后不适用于临时对象的赋值**  因为是左值引用，不能匹配右值引用(临时对象)</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"MinHeap: = 运算符重载..., 传入参数左值引用"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">size</span> = mp.<span class="built_in">size</span>;</span><br><span class="line">    <span class="keyword">if</span>(id != <span class="literal">NULL</span>)&#123; <span class="comment">// 本对象已经开辟过堆区</span></span><br><span class="line">      <span class="keyword">delete</span>[] id;  <span class="comment">// 先释放本对象开辟的堆区</span></span><br><span class="line">      <span class="keyword">if</span>(mp.id != <span class="literal">NULL</span>)&#123; <span class="comment">// mp的id有开辟堆空间才需要执行下面操作，否则直接执行下面操作会报错，因为取地址时会报错</span></span><br><span class="line">        id = <span class="keyword">new</span> item[mp.<span class="built_in">size</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; mp.<span class="built_in">size</span>; ++i)&#123;</span><br><span class="line">          id[i] = mp.id[i];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        id = <span class="literal">NULL</span>;  <span class="comment">// 若mp的id为NULL,则也要初始化为NULL</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(mp.id != <span class="literal">NULL</span>)&#123; <span class="comment">// mp的id有开辟堆空间才需要执行下面操作，否则直接执行下面操作会报错，因为取地址时会报错</span></span><br><span class="line">        id = <span class="keyword">new</span> item[mp.<span class="built_in">size</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; mp.<span class="built_in">size</span>; ++i)&#123;</span><br><span class="line">          id[i] = mp.id[i];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  MinHeap&amp; <span class="keyword">operator</span>=(MinHeap&amp;&amp; mp)&#123;  <span class="comment">//  可以匹配右值引用(临时对象)</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"MinHeap: = 运算符重载..., 传入参数右值引用"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">size</span> = mp.<span class="built_in">size</span>;</span><br><span class="line">    <span class="keyword">if</span>(id != <span class="literal">NULL</span>)&#123; <span class="comment">// 本对象已经开辟过堆区</span></span><br><span class="line">      <span class="keyword">delete</span>[] id;  <span class="comment">// 先释放本对象开辟的堆区</span></span><br><span class="line">    &#125;</span><br><span class="line">    id = mp.id;</span><br><span class="line">    mp.id = <span class="literal">NULL</span>; <span class="comment">// 防止析构时重复释放</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ~MinHeap()&#123;</span><br><span class="line">    <span class="keyword">if</span>(id != <span class="literal">NULL</span>)&#123;</span><br><span class="line">      <span class="comment">// cout&lt;&lt;"id != NULL"&lt;&lt;endl;</span></span><br><span class="line">      <span class="keyword">delete</span>[] id;</span><br><span class="line">      id = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"~MinHeap: 析构函数..."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// delete[] id;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接赋值初始化对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  MinHeap&lt;<span class="keyword">int</span>&gt; mp;</span><br><span class="line">  <span class="comment">// MinHeap&lt;int&gt; mp = MinHeap&lt;int&gt;(10); // 这种写法同MinHeap&lt;int&gt; mp;， 只是初始化是有参构造</span></span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Test1(<span class="keyword">int</span> n)&#123;</span><br><span class="line">    <span class="built_in">size</span> = n;</span><br><span class="line">    <span class="comment">// mp(MinHeap&lt;int&gt;(n)); //  报错， 这种方式初始化，只能是在初始化列表中初始化，不能在函数体中初始化</span></span><br><span class="line">    mp = MinHeap&lt;<span class="keyword">int</span>&gt;(n); <span class="comment">// 有参构造并赋值给mp,然后就地销毁     MinHeap&lt;int&gt;(n)匿名对象</span></span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化列表初始化对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// MinHeap&lt;int&gt; mp;</span></span><br><span class="line">  MinHeap&lt;<span class="keyword">int</span>&gt; mp = MinHeap&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Test2(<span class="keyword">int</span> n): mp(MinHeap&lt;<span class="keyword">int</span>&gt;(n))&#123; <span class="comment">// 这里的初始化列表会覆盖MinHeap&lt;int&gt; mp = MinHeap&lt;int&gt;(10);的初始化</span></span><br><span class="line">    <span class="built_in">size</span> = n;</span><br><span class="line">    <span class="comment">// mp = MinHeap&lt;int&gt;(n);</span></span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 注意事项1： 构造和析构注意事项，结合初始化列表和赋值初始化对比理解</span></span><br><span class="line">  <span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line">  <span class="comment">// Test1 t1(n);</span></span><br><span class="line">  <span class="comment">// 打印结果</span></span><br><span class="line">  <span class="comment">// MinHeap: 默认构造函数...   // 对象初始化时，先调用默认构造函数，初始化mp</span></span><br><span class="line">  <span class="comment">// MinHeap: 有参构造函数...   // 临时对象初始化</span></span><br><span class="line">  <span class="comment">// MinHeap: = 运算符重载..., 传入参数右值引用   // 临时对象赋值给mp,然后就地销毁</span></span><br><span class="line">  <span class="comment">// ~MinHeap: 析构函数...      // 临时对象销毁</span></span><br><span class="line">  <span class="comment">// ~MinHeap: 析构函数...      // mp销毁</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Test2 t2(n);</span></span><br><span class="line">  <span class="comment">// 打印结果</span></span><br><span class="line">  <span class="comment">// MinHeap: 有参构造函数...</span></span><br><span class="line">  <span class="comment">// ~MinHeap: 析构函数...</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 注意事项2： 拷贝构造函数注意事项</span></span><br><span class="line">  <span class="comment">// MinHeap&lt;int&gt; mp(n);</span></span><br><span class="line">  <span class="comment">// MinHeap&lt;int&gt; mp1(mp);  // 调用拷贝构造函数初始化</span></span><br><span class="line">  <span class="comment">// MinHeap&lt;int&gt; mp2 = mp; // 调用拷贝构造函数初始化</span></span><br><span class="line">  <span class="comment">// 打印结果</span></span><br><span class="line">  <span class="comment">// MinHeap: 有参构造函数...</span></span><br><span class="line">  <span class="comment">// MinHeap: 拷贝构造函数...</span></span><br><span class="line">  <span class="comment">// MinHeap: 拷贝构造函数...</span></span><br><span class="line">  <span class="comment">// ~MinHeap: 析构函数...</span></span><br><span class="line">  <span class="comment">// ~MinHeap: 析构函数...</span></span><br><span class="line">  <span class="comment">// ~MinHeap: 析构函数...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注意事项3： 操作符的重载，下面的情况是操作符没重载的情况, =======而且需要没有写移动构造函数，否则默认"="不能用</span></span><br><span class="line">  <span class="comment">// MinHeap&lt;int&gt; m3;  // 默认构造</span></span><br><span class="line">  <span class="comment">// m3 = MinHeap&lt;int&gt;(n);  // 不会调用拷贝构成初始化，而是”=“的赋值操作， 区别于上面的等号拷贝构造的初始化</span></span><br><span class="line">  <span class="comment">// 打印结果</span></span><br><span class="line">  <span class="comment">// Test: 默认构造函数...</span></span><br><span class="line">  <span class="comment">// Test: 有参构造函数...</span></span><br><span class="line">  <span class="comment">// Test: 析构函数...</span></span><br><span class="line">  <span class="comment">// Test: 析构函数...</span></span><br><span class="line">  <span class="comment">// free(): double free detected in tcache 2   // 析构两次报错</span></span><br><span class="line">  <span class="comment">// Aborted (core dumped)</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 注意事项4：运算符重载</span></span><br><span class="line">  MinHeap&lt;<span class="keyword">int</span>&gt; mp4;</span><br><span class="line">  <span class="function">MinHeap&lt;<span class="keyword">int</span>&gt; <span class="title">mp5</span><span class="params">(n)</span></span>;  </span><br><span class="line">  mp4 = MinHeap&lt;<span class="keyword">int</span>&gt;(n); <span class="comment">// 编译报错</span></span><br><span class="line">  mp4 = mp5;  <span class="comment">// 编译成功，调用的自己重载的=</span></span><br><span class="line">  <span class="comment">// 打印结果</span></span><br><span class="line">  <span class="comment">// MinHeap: 默认构造函数...</span></span><br><span class="line">  <span class="comment">// MinHeap: 有参构造函数...</span></span><br><span class="line">  <span class="comment">// MinHeap: 有参构造函数...</span></span><br><span class="line">  <span class="comment">// MinHeap: = 运算符重载..., 传入参数右值引用</span></span><br><span class="line">  <span class="comment">// ~MinHeap: 析构函数...</span></span><br><span class="line">  <span class="comment">// MinHeap: = 运算符重载..., 传入参数左值引用</span></span><br><span class="line">  <span class="comment">// ~MinHeap: 析构函数...</span></span><br><span class="line">  <span class="comment">// ~MinHeap: 析构函数...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="移动构造函数导致默认”-”构造不能用"><a href="#移动构造函数导致默认”-”构造不能用" class="headerlink" title="移动构造函数导致默认”=”构造不能用"></a>移动构造函数导致默认”=”构造不能用</h3><ul>
<li>自定义了拷贝函数，就不会自动生成赋值函数了</li>
<li>自定义了移动拷贝函数，就不会自动生成移动赋值函数了</li>
<li>临时对象的赋值优先调用移动赋值函数，没有移动赋值函数的情况下，会调用赋值函数  </li>
<li>定义了移动拷贝函数，则移动赋值函数默认不提供，=后为临时对象时，就会发现找不到移动赋值函数，从而报错</li>
<li>定义了移动拷贝函数，拷贝函数，拷贝赋值函数都不会默认提供</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> item&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  item* id;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Test(): id(<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Test: 默认构造函数..."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Test(item n): id(<span class="keyword">new</span> item(n))&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Test: 有参构造函数..."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 拷贝构造函数</span></span><br><span class="line">  Test(<span class="keyword">const</span> Test&amp; t)&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Test: 拷贝构造函数..."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span>(t.id != <span class="literal">NULL</span>)&#123;</span><br><span class="line">      id = <span class="keyword">new</span> item(*t.id);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      id = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 赋值函数</span></span><br><span class="line">  <span class="comment">// Test&amp; operator=(const Test&amp; t)&#123;</span></span><br><span class="line">  <span class="comment">//   cout&lt;&lt;"Test: 拷贝赋值函数..."&lt;&lt;endl;</span></span><br><span class="line">  <span class="comment">//   if(this != &amp;t)&#123;</span></span><br><span class="line">  <span class="comment">//     if(id != NULL)&#123;</span></span><br><span class="line">  <span class="comment">//       delete id;</span></span><br><span class="line">  <span class="comment">//       id = NULL;</span></span><br><span class="line">  <span class="comment">//     &#125;</span></span><br><span class="line">  <span class="comment">//     if(t.id != NULL)&#123;</span></span><br><span class="line">  <span class="comment">//       id = new item(*t.id);</span></span><br><span class="line">  <span class="comment">//     &#125;</span></span><br><span class="line">  <span class="comment">//   &#125;</span></span><br><span class="line">  <span class="comment">//   return *this;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移动构造函数</span></span><br><span class="line">  Test(Test&amp;&amp; t)&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Test: 移动构造函数..."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    id = t.id;</span><br><span class="line">    t.id = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移动赋值函数</span></span><br><span class="line">  <span class="comment">// Test&amp; operator=(Test&amp;&amp; t)&#123;</span></span><br><span class="line">  <span class="comment">//   cout&lt;&lt;"Test: 移动赋值函数..."&lt;&lt;endl;</span></span><br><span class="line">  <span class="comment">//   if(this != &amp;t)&#123;</span></span><br><span class="line">  <span class="comment">//     if(id != NULL)&#123;</span></span><br><span class="line">  <span class="comment">//       delete id;</span></span><br><span class="line">  <span class="comment">//       id = NULL;</span></span><br><span class="line">  <span class="comment">//     &#125;</span></span><br><span class="line">  <span class="comment">//     id = t.id;</span></span><br><span class="line">  <span class="comment">//     t.id = NULL;</span></span><br><span class="line">  <span class="comment">//   &#125;</span></span><br><span class="line">  <span class="comment">//   return *this;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 析构函数</span></span><br><span class="line">  ~Test()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Test: 析构函数..."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span>(id != <span class="literal">NULL</span>)&#123;</span><br><span class="line">      <span class="keyword">delete</span> id;</span><br><span class="line">      id = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Test&lt;<span class="keyword">int</span>&gt; t1;</span><br><span class="line">  <span class="comment">// 删除自定义的移动构造函数后就可以正常使用了，因为编译器会自动生成一个移动构造函数，但如果自定义了移动构造函数，编译器就不会自动生成移动赋值函数了</span></span><br><span class="line">  <span class="comment">// 或则同时自定义移动构造函数和移动赋值函数</span></span><br><span class="line">  <span class="comment">// 在有自定义移动赋值函数和赋值函数的情况下，临时对象的赋值调用的是移动赋值</span></span><br><span class="line">  <span class="comment">// 在没有自定义移动赋值，有自定义赋值函数的情况下，临时对象的赋值调用的是赋值函数</span></span><br><span class="line">  <span class="comment">// 在没有自定义移动赋值和赋值函数，但有自定义拷贝函数或者移动拷贝函数的情况下，则会报错，因为有了拷贝函数，编译器就不会自动生成赋值哈函数，有了移动拷贝函数，编译器就不会自动生成移动赋值函数</span></span><br><span class="line">  t1 = Test&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>); <span class="comment">// 报错 无法引用 函数 "Test&lt;item&gt;::operator=(const Test&lt;int&gt; &amp;) [其中 item=int]" (已隐式声明) -- 它是已删除的函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="返回值const引用-待解决"><a href="#返回值const引用-待解决" class="headerlink" title="返回值const引用  待解决"></a>返回值const引用  待解决</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">NestedInteger</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="comment">// Return true if this NestedInteger holds a single integer, rather than a nested list.</span></span><br><span class="line">      <span class="function"><span class="keyword">bool</span> <span class="title">isInteger</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// Return the single integer that this NestedInteger holds, if it holds a single integer</span></span><br><span class="line">      <span class="comment">// The result is undefined if this NestedInteger holds a nested list</span></span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getInteger</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// Return the nested list that this NestedInteger holds, if it holds a nested list</span></span><br><span class="line">      <span class="comment">// The result is undefined if this NestedInteger holds a single integer</span></span><br><span class="line">      <span class="function"><span class="keyword">const</span> <span class="built_in">vector</span>&lt;NestedInteger&gt; &amp;<span class="title">getList</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedIterator</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">stack</span>&lt;pair&lt;<span class="built_in">vector</span>&lt;NestedInteger&gt;::iterator, <span class="built_in">vector</span>&lt;NestedInteger&gt;::iterator&gt;&gt; st; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NestedIterator(<span class="built_in">vector</span>&lt;NestedInteger&gt; &amp;nestedList) &#123;</span><br><span class="line">      <span class="comment">// st.push(&#123;nestedList.begin(), nestedList.end()&#125;);</span></span><br><span class="line">        st.emplace(nestedList.<span class="built_in">begin</span>(), nestedList.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> st.top().first++-&gt;getInteger();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (!st.empty())</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; p = st.top();</span><br><span class="line">        <span class="keyword">if</span>(p.first == p.second)&#123;</span><br><span class="line">          st.pop();</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p.first-&gt;isInteger())&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span>&amp; ft = p.first++-&gt;getList();</span><br><span class="line">        <span class="comment">// st.push(&#123;ft.begin(), ft.end()&#125;);  返回的vector引用是const   // 不可行--------------------------</span></span><br><span class="line">        st.emplace(ft.<span class="built_in">begin</span>(), ft.<span class="built_in">end</span>());    <span class="comment">//  可行</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="八股文"><a href="#八股文" class="headerlink" title="八股文"></a>八股文</h1><h2 id="面试宝典"><a href="#面试宝典" class="headerlink" title="面试宝典"></a>面试宝典</h2><p>说说内联函数和宏函数的区别</p>
<p>简述C+＋从代码到可执行二进制文件的过程</p>
<p>简述一下atomic (原子操作)内存顺序</p>
<blockquote>
<p><a href="https://blog.csdn.net/WilliamCode/article/details/126139289" target="_blank" rel="noopener">https://blog.csdn.net/WilliamCode/article/details/126139289</a></p>
</blockquote>
<p>内存对齐</p>
<blockquote>
<p>案例1：<a href="https://blog.csdn.net/weixin_40775703/article/details/104941508" target="_blank" rel="noopener">https://blog.csdn.net/weixin_40775703/article/details/104941508</a>  <strong>重要</strong></p>
<p>案例2：<a href="https://blog.csdn.net/qq_39397165/article/details/119745975" target="_blank" rel="noopener">https://blog.csdn.net/qq_39397165/article/details/119745975</a></p>
</blockquote>
<ul>
<li>编译器默认对齐数<ul>
<li>64位  对齐数：8</li>
<li>32位  对齐数：4</li>
</ul>
</li>
<li>内存对齐规则<ul>
<li>结构体成员对齐规则，对齐数= min(编译器默认对齐数，结构体当前成员变量大小)</li>
<li>结构体本身对齐规则，对齐数= min(编译器默认对齐数,   结构体成员中最长类型变量大小)</li>
<li>嵌套结构体对齐规则，把嵌套结构体视为成员变量即可，大小即为结构体大小</li>
</ul>
</li>
<li>对于类的某个实例（对象）而言，<strong>成员函数、静态变量</strong>都不会占空间，只有<strong>成员变量占空间</strong>，而只考虑成员变量的类相当于一个结构体</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结构体成员对齐案例</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> c1;</span><br><span class="line">	<span class="keyword">char</span> c2;</span><br><span class="line">	<span class="keyword">int</span> i1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">char</span> c1;  <span class="comment">// min&#123;编译器默认对齐数，该成员变量大小&#125; = min(8, 1) = 1   存在[0]位置</span></span><br><span class="line">  <span class="keyword">int</span> i1;   <span class="comment">// min&#123;编译器默认对齐数，该成员变量大小&#125; = min(8, 4) = 4   存在[4,7]位置  因为int要对齐4的倍数，所以[1,3]空</span></span><br><span class="line">  <span class="keyword">char</span> c2;  <span class="comment">// min&#123;编译器默认对齐数，该成员变量大小&#125; = min(8, 1) = 1   存在[8]位置</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 原数据占用空间为9， 但s2最大对齐数为4 所以[9,11]空   总大小为12   9补齐为4的倍数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> c1;  <span class="comment">// min&#123;编译器默认对齐数，该成员变量大小&#125; = min(8, 1) = 1   存在[0]位置</span></span><br><span class="line">  <span class="keyword">double</span> d1;  <span class="comment">// min&#123;编译器默认对齐数，该成员变量大小&#125; = min(8, 8) = 8   存在[8,15]位置  因为double要对齐8的倍数，所以[1,7]空</span></span><br><span class="line">	<span class="keyword">int</span> i1;  <span class="comment">// min&#123;编译器默认对齐数，该成员变量大小&#125; = min(8, 4) = 4   存在[16,19]位置</span></span><br><span class="line">	<span class="keyword">char</span> c2; <span class="comment">// min&#123;编译器默认对齐数，该成员变量大小&#125; = min(8, 1) = 1   存在[20]位置</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 原数据占用空间为21， 但s3最大对齐数为8 所以[21,23]空   总大小为24   21补齐为8的倍数</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S4</span> &#123;</span> </span><br><span class="line">  <span class="keyword">int</span> a[<span class="number">5</span>]; <span class="comment">// 20</span></span><br><span class="line">  <span class="keyword">char</span> b;  <span class="comment">// 21</span></span><br><span class="line">  <span class="keyword">double</span> c; <span class="comment">// 对齐数为8 所以[22,23]空，填充[24,31]</span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// 原数据占用空间为32</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;<span class="string">"sizeof(S1)"</span>&lt;&lt; <span class="keyword">sizeof</span>(S1)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 8</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(S2)"</span>&lt;&lt;<span class="keyword">sizeof</span>(S2)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 12</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(S3)"</span>&lt;&lt;<span class="keyword">sizeof</span>(S3)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 24</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(S4)"</span>&lt;&lt;<span class="keyword">sizeof</span>(S4)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 32</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 嵌套结构体</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S0</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> i1;</span><br><span class="line">  <span class="keyword">int</span> i2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">double</span> d1;</span><br><span class="line">	<span class="keyword">double</span> d2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> c1; <span class="comment">// min(8, 1) = 1   [0]</span></span><br><span class="line">	S1 s1; <span class="comment">// min(8, 8) = 8  [8,23]  结构体的对齐数为min(编译器默认对齐数,   结构体成员中最长类型变量大小)</span></span><br><span class="line">	<span class="keyword">char</span> c2; <span class="comment">// min(8, 1) = 1  [24]</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S4</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">char</span> c1; <span class="comment">// min(8, 1) = 1   [0]</span></span><br><span class="line">	S0 s0; <span class="comment">// min(8, 4) = 4  [4, 11] 结构体的对齐数为min(编译器默认对齐数,   结构体成员中最长类型变量大小)</span></span><br><span class="line">	<span class="keyword">char</span> c2; <span class="comment">// min(8, 1) = 1  [12]</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 本身大小13 最大对齐数为4  补齐[14, 15]  13 --&gt; 16</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(S0):"</span>&lt;&lt;<span class="keyword">sizeof</span>(S0)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 8</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;<span class="string">"sizeof(S1):"</span>&lt;&lt; <span class="keyword">sizeof</span>(S1)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 16</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(S2):"</span>&lt;&lt;<span class="keyword">sizeof</span>(S2)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 32</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(S4):"</span>&lt;&lt;<span class="keyword">sizeof</span>(S4)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 16</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>说说C 如何 实现C+ 语言中的重载</p>
<p> 简述下向上转 和向下转型 对象</p>
<p>移动构造函数</p>
<blockquote>
<p><a href="https://blog.csdn.net/weixin_44788542/article/details/126284429" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44788542/article/details/126284429</a></p>
</blockquote>
<p>虚析构函数</p>
<blockquote>
<p><a href="https://blog.csdn.net/qq_15821883/article/details/105540175" target="_blank" rel="noopener">https://blog.csdn.net/qq_15821883/article/details/105540175</a></p>
</blockquote>
<ul>
<li><p>一个对象在析构时会先调用自己的析构函数，然后再调用父类的析构函数。逻辑同构造函数 ，一个对象先调用父类的构造函数，然后调用自己的构造函数</p>
<ul>
<li>但是在多态情况下，一个对象指向其子类，在析构时其只能调用自己和父类的析构函数，不能调用子类的析构函数，所以需要将自己的析构函数设置为虚析构，这样就可以先调用子类的析构函数，再调用自己和父类的析构函数</li>
</ul>
</li>
<li><p>使得基类指针可以调用派生类的析构函数</p>
</li>
<li><p>如果基类析构函数不是虚析构函数，在基类指针delete的时候只会调用基类的析构函数，不会调用派生类的析构函数，就会导致派生类的内存泄露</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	BaseClass() &#123;&#125;</span><br><span class="line">	~BaseClass() </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"delete BaseClass"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildClassA</span> :</span> <span class="keyword">public</span> BaseClass</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	ChildClassA() &#123;&#125;</span><br><span class="line">	~ChildClassA() </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ChildClassA Delete"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildClassB</span> :</span> <span class="keyword">public</span> ChildClassA</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	ChildClassB() &#123;&#125;</span><br><span class="line">	~ChildClassB()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ChildClassB Delete"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 测试案例</span></span><br><span class="line">  BaseClass *a = <span class="keyword">new</span> ChildClassA();</span><br><span class="line">	BaseClass *b = <span class="keyword">new</span> ChildClassB();</span><br><span class="line">	ChildClassA *c = <span class="keyword">new</span> ChildClassB();  </span><br><span class="line"> </span><br><span class="line">	<span class="keyword">delete</span> a;</span><br><span class="line">	a = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">delete</span> b;</span><br><span class="line">	b = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">delete</span> c;</span><br><span class="line">	c = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">Hello World</span><br><span class="line"><span class="keyword">delete</span> BaseClass</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> BaseClass</span><br><span class="line"></span><br><span class="line">ChildClassA Delete  </span><br><span class="line"><span class="keyword">delete</span> BaseClass     <span class="comment">// 子类会自动调用父类的析构函数  即使不是虚函数</span></span><br></pre></td></tr></table></figure>

<p>1.3.33仿函数</p>
<blockquote>
<p>C++ 仿函数为何而生:<a href="https://zhuanlan.zhihu.com/p/362323211" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/362323211</a> </p>
</blockquote>
<blockquote>
<p>C++中的explicit详解: <a href="https://blog.csdn.net/k6604125/article/details/126524992" target="_blank" rel="noopener">https://blog.csdn.net/k6604125/article/details/126524992</a></p>
</blockquote>
<p>友元函数</p>
<blockquote>
<p> C++友元函数: <a href="https://blog.csdn.net/weixin_59179454/article/details/127574320" target="_blank" rel="noopener">https://blog.csdn.net/weixin_59179454/article/details/127574320</a></p>
</blockquote>
<p>1.3.36 虚函数表里存放的内容是什么时候写进去的？</p>
<blockquote>
<p><a href="https://www.bilibili.com/read/cv12864050/" target="_blank" rel="noopener">https://www.bilibili.com/read/cv12864050/</a></p>
</blockquote>
<p>1.4.10 STL 容器动态链接可能产生的问题</p>
<p>右值引用和move</p>
<blockquote>
<p><a href="https://blog.csdn.net/qq_40637903/article/details/1080519586" target="_blank" rel="noopener">https://blog.csdn.net/qq_40637903/article/details/1080519586</a></p>
</blockquote>
<p>1.5.11 C+＋中四种类型转换分别为const_cast static_cast dynamic_cast reinterpret_cast,</p>
<blockquote>
<p><a href="https://blog.csdn.net/Awesomewan/article/details/117112781" target="_blank" rel="noopener">https://blog.csdn.net/Awesomewan/article/details/117112781</a></p>
<p><a href="https://www.cnblogs.com/overxus/p/17991592" target="_blank" rel="noopener">博客园：static_cast, dynamic_cast与reinterpret_cast的区别 </a></p>
</blockquote>
<ul>
<li>const_cast<ul>
<li>用于将const变量转为非const<ul>
<li>非const转const也可 但没必要</li>
</ul>
</li>
<li>目标类型必须是一个指向对象、数据成员或引用类型的<strong>指针或引用</strong><ul>
<li>注意目标类型必须是*<em>指针或引用 *</em></li>
</ul>
</li>
<li>不同类型的转换会报错（类a指针转换会类b指针）</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">float</span>* aa = <span class="keyword">new</span> <span class="keyword">float</span>(<span class="number">10.5</span>);</span><br><span class="line">  *aa = <span class="number">11.6</span>;</span><br><span class="line"><span class="comment">//   const float* bb = const_cast&lt;const float* &gt;(aa);  // 和 const float* bb = aa; 等价</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">float</span>* bb = aa;</span><br><span class="line"></span><br><span class="line"><span class="comment">//   *bb = 12.6;  提示错误  不能修改值</span></span><br><span class="line">  *aa = <span class="number">11.6</span>;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt; <span class="string">"aa: "</span> &lt;&lt; *aa&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 输出11.6  *aa还是可以修改</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"bb: "</span> &lt;&lt; *bb &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 输出11.6</span></span><br></pre></td></tr></table></figure>



<ul>
<li>static_cast<ul>
<li>静态类型转换 在编译阶段就可以确定的转换</li>
<li>也可用于动态类型转换 但是如果转换有问题会直接报错 而不是像dynamic_cast返回nullptr可用作判断</li>
<li>不能用于const变量转为非const  会编辑器提示错误</li>
</ul>
</li>
<li>dynamic_cast<ul>
<li>动态类型转换 在运行期间才能确定的转换 主要用于父子类直接的转换</li>
<li>如果转换失败且转换的目标类型是指针，则返回一个空指针；</li>
<li>如果转换失败且转换的目标类型是引用，则会抛出<code>std::bad_cast</code>异常；</li>
<li><code>dynamic_cast</code>的目标类型必须是一个已定义的<strong>类的引用或指针类型</strong>, 否则编辑器提示错误<ul>
<li>注意是<strong>类</strong>的<strong>引用或指针类型</strong><ul>
<li>如果不是类，是基本数据类型的指针或引用，编辑器也会提示错误</li>
</ul>
</li>
</ul>
</li>
<li>动态类型转换与C++的多态有关，常用于基类与子类指针或引用的转换，且<strong>基类中至少要有一个虚函数</strong>。<ul>
<li>如果基类没有虚函数 则编辑器会直接提示错误：<code>&#39;Base&#39; is not polymorphicclang(bad_dynamic_cast_not_polymorphic)</code>   根本就不能编译</li>
</ul>
</li>
<li>不能用于const变量转为非const  会编辑器提示错误</li>
</ul>
</li>
<li>reinterpret_cast<ul>
<li>reinterpret的意思是“重新解释”，它不会改变任何底层的数据，而是告诉编译器应该把当前数据当作哪种类型。</li>
<li>常见使用场景：一个类指针在传递时为void*类型 拿到后需要转回原来的类的类型  （原类型是确定的）</li>
<li>reinterpret和强制类型转换有点类似</li>
<li>不能用于const变量转为非const  会编辑器提示错误</li>
</ul>
</li>
</ul>
<p>1.5.13  简述一下 C++ll 中的可变参数模板新特性</p>
<blockquote>
<p><a href="https://blog.csdn.net/unity3d_xyz/article/details/108450820" target="_blank" rel="noopener">https://blog.csdn.net/unity3d_xyz/article/details/108450820</a></p>
</blockquote>
<p>2.2文件权限修改</p>
<blockquote>
<p><a href="http://m.biancheng.net/view/752.html" target="_blank" rel="noopener">http://m.biancheng.net/view/752.html</a></p>
<p><a href="https://blog.csdn.net/qq_36501591/article/details/87273384" target="_blank" rel="noopener">https://blog.csdn.net/qq_36501591/article/details/87273384</a></p>
<p><a href="https://www.cnblogs.com/devgis/p/16382356.html" target="_blank" rel="noopener">https://www.cnblogs.com/devgis/p/16382356.html</a></p>
</blockquote>
<p>2.5 说软链接和硬链接的区别</p>
<blockquote>
<p><a href="https://www.cnblogs.com/oceanftd/p/13475643.html" target="_blank" rel="noopener">https://www.cnblogs.com/oceanftd/p/13475643.html</a></p>
</blockquote>
<p>2.6 说说静态库和动态库怎么制作及如何使用，区别是什么</p>
<blockquote>
<p><a href="https://blog.csdn.net/fightingtingting/article/details/125437706" target="_blank" rel="noopener">https://blog.csdn.net/fightingtingting/article/details/125437706</a></p>
<p>c++: <a href="https://blog.csdn.net/mzc_love/article/details/128158943" target="_blank" rel="noopener">https://blog.csdn.net/mzc_love/article/details/128158943</a></p>
</blockquote>
<p>2.8 说说什么是大端小端，如何判断大端小端</p>
<blockquote>
<p><a href="https://blog.csdn.net/m0_58250087/article/details/126453463" target="_blank" rel="noopener">https://blog.csdn.net/m0_58250087/article/details/126453463</a></p>
<p>union: <a href="https://blog.csdn.net/std7879/article/details/125001689" target="_blank" rel="noopener">https://blog.csdn.net/std7879/article/details/125001689</a></p>
</blockquote>
<p>2.26 请你说说什么是孤儿进程，什么是僵尸进程，如何解决僵尸进程</p>
<blockquote>
<p>危害： <a href="https://blog.csdn.net/a745233700/article/details/120715371" target="_blank" rel="noopener">https://blog.csdn.net/a745233700/article/details/120715371</a></p>
</blockquote>
<p>2.27 说说什么是守护进程，如何实现</p>
<blockquote>
<p>待学习</p>
</blockquote>
<p>2.44 说说什 是信号量， 有什 作用</p>
<blockquote>
<p><a href="https://blog.csdn.net/weixin_43914272/article/details/108317212" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43914272/article/details/108317212</a></p>
</blockquote>
<p>2.52  简述Linux零拷贝的原理</p>
<blockquote>
<p>深度原理：<a href="https://www.cnblogs.com/yrxing/p/16684064.html" target="_blank" rel="noopener">https://www.cnblogs.com/yrxing/p/16684064.html</a></p>
<p>简单原理：<a href="https://www.elecfans.com/consume/1171431.html" target="_blank" rel="noopener">https://www.elecfans.com/consume/1171431.html</a></p>
<ul>
<li>传统I/O方式与零拷贝方式对比即图示</li>
</ul>
</blockquote>
<ul>
<li>DMA技术<ul>
<li>不需要CPU</li>
<li>从磁盘拷贝到内核缓存区</li>
<li>从内核缓存区拷贝到协议引擎中（传输到网络中）</li>
</ul>
</li>
</ul>
<p>2.53 简述epoll select 的区别， epoll为什么高效</p>
<blockquote>
<p>简单解释：<a href="https://www.jianshu.com/p/c9190109c7d8" target="_blank" rel="noopener">https://www.jianshu.com/p/c9190109c7d8</a></p>
<p>系统解释：<a href="https://blog.csdn.net/www_dong/article/details/113532077" target="_blank" rel="noopener">https://blog.csdn.net/www_dong/article/details/113532077</a></p>
<p>视频教程：<a href="https://www.bilibili.com/video/BV1qJ411w7du/?spm_id_from=333.337.search-card.all.click&amp;vd_source=7230a052308bbb41976f248d2c778e3a" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1qJ411w7du/?spm_id_from=333.337.search-card.all.click&amp;vd_source=7230a052308bbb41976f248d2c778e3a</a></p>
<p>seclect、poll 阻塞函数</p>
<p>redis、nginx、java(N2O)都是使用epoll</p>
</blockquote>
<p>select</p>
<ul>
<li>优点(相较于自己实现)：<ul>
<li>所有任务一次传给内核态，如果是自己实现，需要一个个判断，每个判断是否有数据传来都要切换到内核态</li>
</ul>
</li>
<li>缺点：<ul>
<li>1 由于bitmap数据结构的特性，最多只能支持1024个请求</li>
<li>2 rset不能重用，没有都要遍历重置</li>
<li>3 仍然有用户态内核态的切换</li>
<li>4 内核态返回，需要O(n)时间复杂度找到有数据的请求是哪个</li>
</ul>
</li>
</ul>
<p><img src="/2022/01/26/C++/C++interview/image-20230309165501713.png" alt="image-20230309165501713"></p>
<p>poll</p>
<ul>
<li>优点(相较于select):<ul>
<li>支持更多请求，因为pollfds数组是没有上限的</li>
<li>不用重置pollfds，只用每次修改revent即可</li>
</ul>
</li>
<li>缺点：<ul>
<li>仍然没有解决select中提到的3，4缺点</li>
</ul>
</li>
</ul>
<p><img src="/2022/01/26/C++/C++interview/image-20230309170205226.png" alt="image-20230309170205226"></p>
<p>epoll</p>
<ul>
<li>优点：<ul>
<li>epfd是用户态和内核态共享的，所以解决了用户态和内核态切换的开销</li>
<li>内核态在轮询的时候，会对有数据的请求进行重排，即有数据的请求放到epfd前面，并且有返回值，返回值为有数据的请求个数，这样就可以只用遍历有数据的请求了，解决了O(N)复杂度的遍历</li>
</ul>
</li>
</ul>
<p><img src="/2022/01/26/C++/C++interview/image-20230309171645814.png" alt="image-20230309171645814"></p>
<p>2.54 说说多路IO复用技术有哪些，区别是什么</p>
<blockquote>
<ul>
<li>IO多路复用：I/O是指网络I/O,多路指多个TCP连接(即socket或者channel）,复用指复用一个或几个线程。意思说一个或一组线程处理多个TCP连接。最大优势是减少系统开销小，不必创建过多的进程/线程，也不必维护这些进程/线程。</li>
<li>IO多路复用使用两个系统调用(select/poll/epoll和recvfrom)，blocking IO只调用了recvfrom；select/poll/epoll 核心是可以同时处理多个connection，而不是更快，所以连接数不高的话，性能不一定比多线程+阻塞IO好,多路复用模型中，每一个socket，设置为non-blocking,阻塞是被select这个函数block，而不是被socket阻塞的</li>
</ul>
<p><a href="https://www.shuzhiduo.com/A/MyJx7qXXzn/" target="_blank" rel="noopener">https://www.shuzhiduo.com/A/MyJx7qXXzn/</a></p>
<p><a href="https://blog.csdn.net/liyaomeng/article/details/107891133" target="_blank" rel="noopener">https://blog.csdn.net/liyaomeng/article/details/107891133</a></p>
</blockquote>
<p>2.57 简述同步与异步的区别，阻塞与非阻塞的区别</p>
<blockquote>
<p><a href="https://blog.csdn.net/liyaomeng/article/details/107891133" target="_blank" rel="noopener">https://blog.csdn.net/liyaomeng/article/details/107891133</a></p>
</blockquote>
<ul>
<li>阻塞与非阻塞指的是用户态的程序执行是否阻塞</li>
<li>同步与异步指的是同时是否能处理多个任务，同步只能处理一个，异步可以处理多个<ul>
<li>多路IO复用技术(select、poll、epoll)就是异步阻塞的，阻塞是因为select、poll、epoll调用的时候代码是阻塞的，得等待系统态返回，异步是指可以同时处理多个任务</li>
</ul>
</li>
</ul>
<p>2.58 BIO NIO有什么区别</p>
<blockquote>
<p><a href="https://blog.csdn.net/lzb348110175/article/details/98941378" target="_blank" rel="noopener">https://blog.csdn.net/lzb348110175/article/details/98941378</a></p>
</blockquote>
<p>3.3 简述域名解析过程，本机如何干预域名解析</p>
<blockquote>
<p>有图：<a href="https://baijiahao.baidu.com/s?id=1754073275573332761&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1754073275573332761&amp;wfr=spider&amp;for=pc</a></p>
</blockquote>
<p>3.5 简述网关的作用是什么，同一网段的主机如何通信</p>
<blockquote>
<p>子网掩码的使用：<a href="https://blog.csdn.net/m0_51292856/article/details/128557189" target="_blank" rel="noopener">https://blog.csdn.net/m0_51292856/article/details/128557189</a></p>
<p><a href="https://blog.csdn.net/AutumnGingkgo/article/details/122392220" target="_blank" rel="noopener">https://blog.csdn.net/AutumnGingkgo/article/details/122392220</a></p>
<p><a href="https://blog.csdn.net/xuhao0258/article/details/118051122?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-118051122-blog-122392220.pc_relevant_landingrelevant&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3" target="_blank" rel="noopener">https://blog.csdn.net/xuhao0258/article/details/118051122?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-118051122-blog-122392220.pc_relevant_landingrelevant&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3</a></p>
</blockquote>
<p>3.6 简述CSRF攻击的思想以及解决方法</p>
<blockquote>
<p><a href="https://blog.csdn.net/weixin_44052462/article/details/122988438" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44052462/article/details/122988438</a></p>
<p>为什么token可以防止CSRF，但cookie不行：<a href="https://blog.csdn.net/JinYJ2014/article/details/122931481" target="_blank" rel="noopener">https://blog.csdn.net/JinYJ2014/article/details/122931481</a></p>
<ul>
<li>cookie是自动携带的，但是token是需要手动设置每次访问都携带的</li>
</ul>
<p>Cookie、session和token的区别：<a href="https://blog.csdn.net/inthat/article/details/103967592" target="_blank" rel="noopener">https://blog.csdn.net/inthat/article/details/103967592</a></p>
</blockquote>
<p>3.28 简述 TCP 协议的延迟 ACK 和累计应答</p>
<blockquote>
<p><strong>累计应答：</strong> 对应发送的包都要进行应答，但不是一个个应答，而是会<strong>应答某个之前的ID</strong>,这个ID前边的已经接收完毕。</p>
<p><a href="https://blog.csdn.net/q473203506/article/details/122908332" target="_blank" rel="noopener">https://blog.csdn.net/q473203506/article/details/122908332</a></p>
</blockquote>
<p>3.31 说说端到端，点到点的区别</p>
<blockquote>
<p><a href="https://blog.csdn.net/weixin_46437478/article/details/107089472" target="_blank" rel="noopener">https://blog.csdn.net/weixin_46437478/article/details/107089472</a></p>
</blockquote>
<p>3.40 简述 HTTPS 的加密与认证过程</p>
<blockquote>
<p>流程：<a href="https://blog.csdn.net/m0_52256357/article/details/126910921" target="_blank" rel="noopener">https://blog.csdn.net/m0_52256357/article/details/126910921</a></p>
<p>解释：<a href="https://blog.csdn.net/lamperouge_conan/article/details/109575631" target="_blank" rel="noopener">https://blog.csdn.net/lamperouge_conan/article/details/109575631</a></p>
</blockquote>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="prelearn"><a href="#prelearn" class="headerlink" title="prelearn"></a>prelearn</h2><blockquote>
<p><a href="https://www.zhihu.com/question/25142664" target="_blank" rel="noopener">局部性原理</a></p>
<p>L1d cache:           32K<br>L1i cache:           32K<br>L2 cache:            1024K<br>L3 cache:            19712K</p>
<p>adj_index</p>
<p>adj: 入度个数，出度个数，入度id1，入度id1属性，入度id2，入度id2属性，出度id1，出度id1属性，出度id2，出度id2属性</p>
<p>一次cache切换</p>
<p>原始：正逆向索引2次，出入度查询2次，邻接点每次属性查询都要cache查询</p>
</blockquote>
<p><strong>进程与线程</strong></p>
<p>进程是系统进行资源分配和调度的基本单位</p>
<p>线程是操作系统进行运行调度的最小单位<br>包含在进程之中，是进程中实际运行工作的单位<br>一个进程可以并发多个线程，每个线程执行不同的任务</p>
<p><strong>计算密集型和内存密集型</strong></p>
<p>计算密集型就是CPU密集型</p>
<p>内存密集型就是IO密集型，例如读写网络和磁盘，适用于超线程</p>
<p><strong>局部性原理</strong></p>
<p>局部性原理是指CPU访问存储器时，无论是存取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中。</p>
<p><strong>页式存储管理和段式存储管理</strong></p>
<p>页式存储管理</p>
<ul>
<li><p>将进程逻辑空间等分成若干大小的页面</p>
</li>
<li><p>相应的把物理内存空间分成与页面大小的物理块</p>
</li>
<li><p>以页面为单位把进程空间装进物理内存中分散的物理块</p>
</li>
<li><p><em>有一段连续的逻辑分布在多个页面中，将大犬降低执行效率</em></p>
</li>
</ul>
<p>段式存储管理</p>
<ul>
<li>将进程逻辑空间划分成若干段（非等分)</li>
<li>段的长度由连续逻辑的长度决定</li>
<li><em>段式存储管理相比页式存储管理更加灵活</em></li>
</ul>
<p>段页式存储管理</p>
<ul>
<li>先将逻辑空间按段式管理分成若干段</li>
<li>再把段内空间按页式管理等分成若干页</li>
</ul>
<p><strong>页面置换算法LRU、LFU</strong></p>
<p>缓存置换算法</p>
<ul>
<li>先进先出算法(FIFO)</li>
<li>最近最少使用算法(LRU)</li>
<li>最不经常使用算法(LFU)</li>
</ul>
<p><strong>磁盘冗余阵列详解</strong></p>
<ul>
<li><p>RAID是什么?</p>
<ul>
<li>RAID(Redundant Array of Independent Disks):磁盘冗余阵列</li>
<li>磁盘冗余阵列:利用虚拟化存储技术把多个硬盘组合起来，成为一个或多个硬盘阵列组，目的为提升性能或减少冗余,或是两者同时提升。</li>
</ul>
</li>
<li><p>RAID 0</p>
<ul>
<li>性能:单块磁盘的N倍</li>
<li>不提供数据校验和数据冗余</li>
<li>某块磁盘损坏，数据直接丢失且无法恢复</li>
</ul>
</li>
<li><p>RAID 1</p>
<ul>
<li>数据无差别双写工作磁盘和镜像磁盘</li>
<li>性能:单块磁盘的N/2倍</li>
<li>数据可靠性强，只要不是同时损坏，都可以恢复</li>
</ul>
</li>
<li><p>RAID 5</p>
<ul>
<li>数据中心最常见的RAID等级</li>
<li>提供纠错海明码实现数据冗余校验</li>
<li>分散校验盘，提高写性能，降低校验盘出错概率</li>
</ul>
</li>
</ul>
<p><img src="/2022/01/26/C++/C++interview/image-20221230205527599.png" alt="image-20221230205527599"></p>
<ul>
<li>RAID 10<ul>
<li>RAID0+RAID1</li>
<li>既保证了数据冗余又保证了读写效率</li>
<li>磁盘空间存储冗余，浪费严重</li>
</ul>
</li>
</ul>
<p><img src="/2022/01/26/C++/C++interview/image-20221230205605502.png" alt="image-20221230205605502"></p>
<p><img src="/2022/01/26/C++/C++interview/image-20221230205938019.png" alt="image-20221230205938019"></p>
<p><strong>同步问题三大经典案例</strong></p>
<ul>
<li><p>生产者-消费者问题</p>
<ul>
<li>一组生产者进程、一组消费者进程、一个缓冲区</li>
<li>生产者在缓冲区溢出前，不断往缓冲区生产数据</li>
<li>消费者在缓冲区为空前，不断从缓冲区消费数据</li>
<li>生产者-消费者通过缓冲区存在同步关系<ul>
<li>当缓冲区满时，生产者必须等待消费者消费数据</li>
<li>当缓冲区空时，消费者必须等待生产者生产数据</li>
</ul>
</li>
<li>生产者-消费者、生产者之间、消费者之间存在互斥关系<ul>
<li>对缓冲区数据进行存取操作时，必须互斥进行</li>
</ul>
</li>
</ul>
</li>
<li><p>读者-写者问题</p>
<ul>
<li>读-写操作之间存在同步关系</li>
<li>多个写操作应该串行完成</li>
</ul>
</li>
<li><p>哲学家进餐问题</p>
<ul>
<li>有五个哲学家，他们的生活方式是交替地进行思考和进餐，哲学家们共同使用一张圆桌，分别坐在周围的五张椅子上，在圆桌上有五个碗和五支筷子。平时哲学家们只进行思考，饥饿时则试图取靠近他们的左、右两支筷子，只有两支筷子都被他拿到的时候就能进餐，进餐完毕之后，放下左右筷子继续思考。</li>
</ul>
</li>
</ul>
<p><strong>锁的种类详解</strong></p>
<ul>
<li><p>乐观锁/悲观锁</p>
<ul>
<li>悲观锁每次操作都加锁、乐观锁默认不添加锁</li>
<li>悲观锁适合写操作的场景</li>
<li>乐观锁适合读操作的场景（获得资源后直接操作，再写回时判断原数据是否修改过）</li>
</ul>
</li>
<li><p>无锁/偏向锁/轻量级锁/重量级锁</p>
<ul>
<li>无锁:不锁资源，多个线程只一个线程修改成功，其他线程会重试</li>
<li>偏向锁:同一个线程执行临界资源会自动获取资源</li>
<li>轻量级锁:多个线程竞争同步资源时，没有获得资源的线程自旋等待锁释放<ul>
<li>自旋是指一直占用CPU，不会发生上下文切换</li>
</ul>
</li>
<li>重量级锁:多个线程竞争同步资源时，没有获得资源的线程阻塞等待唤醒<ul>
<li>阻塞是指会让出CPU，发生上下文切换</li>
</ul>
</li>
</ul>
</li>
<li><p>公平锁/非公平锁</p>
<ul>
<li>公平锁：所有等待资源的线程都按先后顺序加入等待队列，当资源释放时，这些线程都被唤醒，开始竞争资源</li>
<li>非公平锁：后来的线程可以直接插队获取资源，如果获取成功就不用调出CPU可以直接继续执行，如果没有获取成功则需要加入队列尾部，等资源释放后公平竞争资源</li>
<li>公平锁的优点:等待锁的线程不会饥饿等待（都是公平竞争的）</li>
<li>公平锁的缺点:整体吞吐效率相对非公平锁要低（资源释放时需要唤醒所有等待的线程进行资源竞争）</li>
<li>非公平锁的优缺点:整体的吞吐效率高，CPU不必唤醒所有线程<ul>
<li>如果插队成功，对于插队的线程不用调出CPU可以直接继续执行，且不用唤醒队列中的等待的线程</li>
</ul>
</li>
</ul>
</li>
<li><p>可重入锁/非可重入锁</p>
<ul>
<li>可重入锁又名递归锁， 是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方<br>法会自动获取锁，不会因为之前已经获取过还没释放而阻塞。</li>
<li>不可重入锁， 当前线程再次获取当前线程已经获得的锁时，如果该锁仍被当前线程所持有,<br>未被释放，那么将会出现死锁。</li>
</ul>
</li>
<li><p>共享锁/排他锁</p>
<ul>
<li>排他锁(互斥锁)是指该锁一次只能被一个线程所持有</li>
<li>共享锁是指该锁可被多个线程所持有</li>
<li>获得共享锁的线程只能读数据，不能修改数据</li>
</ul>
</li>
</ul>
<p><strong>线程间通信</strong></p>
<ul>
<li><p>互斥锁(mutex)</p>
<ul>
<li>互斥量是 最简单的线程同步的方法</li>
<li>互斥量(互斥锁)，处于两态之-的变量:解锁和加锁</li>
<li>两个状态可以保证资源访问的串行</li>
</ul>
</li>
<li><p>自旋锁(spin_ lock)</p>
<ul>
<li>自旋锁也是一种多线程同步的变量</li>
<li>使用自旋锁的线程会反复检查锁变量是否可用</li>
<li>自旋锁不会让出CPU，是一种忙等待状态（忙等待就是等待时一直占用CPU）</li>
<li>自旋锁避免了进程或线程.上下文切换的开销</li>
<li>操作系统内部很多地方使用的是自旋锁</li>
<li>自旋锁不适合在单核CPU使用</li>
</ul>
</li>
<li><p>读写锁(rwlock)</p>
<ul>
<li>读写锁是一种特殊的自旋锁</li>
<li>允许多个读者同时访问资源以提高读性能，但写的时候还是互斥的</li>
</ul>
</li>
<li><p>条件变量</p>
<ul>
<li>条件变量是一种相对复杂的线程同步方法</li>
<li>条件变量允许线程睡眠，直到满足某种条件</li>
<li>当满足条件时，可以向该线程信号,通知唤醒</li>
</ul>
</li>
</ul>
<p><strong>进程间通信</strong></p>
<ul>
<li><p>进程VS线程</p>
<ul>
<li>线程是系统进行运行调度的最小单位<ul>
<li>线程是共享进程资源的</li>
</ul>
</li>
<li>进程是系统进行资源分配和调度的基本单位<ul>
<li>进程之间的资源是独立的</li>
</ul>
</li>
</ul>
</li>
<li><p>管道(pipe)</p>
<ul>
<li>不可跨机器</li>
<li>这里的”I” 实际上就是管道的意思，”I” 前面部分作为”I” 后面的输入。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">netstat -anlp | grep 8080</span><br><span class="line">cat server.log | grep ERROR | grep Thread</span><br><span class="line">man netstat | more</span><br></pre></td></tr></table></figure>

<ul>
<li>消息队列<ul>
<li>可跨机器进行进程间通信</li>
<li>相对管道，传输的数据可以序列化（封装）</li>
</ul>
</li>
</ul>
<p><img src="/2022/01/26/C++/C++interview/image-20230105173126413.png" alt="image-20230105173126413"></p>
<ul>
<li>共享内存<ul>
<li>不可跨机器</li>
</ul>
</li>
</ul>
<p><img src="/2022/01/26/C++/C++interview/image-20230105173147951.png" alt="image-20230105173147951"></p>
<ul>
<li><p>信号</p>
<ul>
<li>不可跨机器</li>
<li>传输的信息是有限的，且是固定的，就是固定数字代表固定指令</li>
</ul>
</li>
<li><p>套接字</p>
<ul>
<li>网络套接字（跨机进程间通信）<ul>
<li>网络层:提供主机之间的通信</li>
<li>传输层:提供主机不同进程之间的通信</li>
<li>应用层:提供不同应用之间的通信</li>
</ul>
</li>
<li>域套接字（本机进程间通信）<ul>
<li>套接字(socket)原是网络通信中使用的术语</li>
<li>域套接字是一种高级的进程间通信的方法</li>
<li>Unix域套接字可以用于同一机器进程间通信</li>
<li>Unix系统提供的域套接字提供了网络套接字类似的功能</li>
<li>Unix域套接字通信无需经过完整的网络协议栈</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>CAS原理与无锁技术详解</strong></p>
<ul>
<li><p>大量使用锁的弊端</p>
<ul>
<li>开发难度:并行系统访问临界资源必须考虑加锁</li>
<li>墨菲定律:只要存在的一定会发生，死锁</li>
<li>调度问题:低优先级线程持有锁导致高优先级线程无法执行</li>
<li>性能问题:满足一致性要求的前提下需要串行访问</li>
<li>锁粒度:锁粒度过小/过大，设计不当</li>
</ul>
</li>
<li><p>基石: CAS技术</p>
<ul>
<li>原子性:原子性是指一系列操作不可被中断的特性;这一系列操作要么全部执行完成，要么全部没有执行，不存在部分执行，部分未执行的情况。</li>
<li>CAS一Compare &amp; Set,或是Compare &amp; Swap,现在几乎所有的CPU指令都支持CAS的原子操作，X86下对应的是CMPXCHG汇编指令。</li>
</ul>
</li>
<li><p>CAS与ABA问题</p>
<ul>
<li>ABA问题是指CAS交换数据在多次操作后恢复原值而线程无法感知的问题。例如：线程1对原值8修改为9，然后又修改回8，线程2在原值为8时同步线程1开始执行，线程2计算结束后，发现原值开始8，但其实已经被线程修改2次了</li>
<li>解决以上问题的方法：对数据加本版号，就可以确保唯一性</li>
</ul>
</li>
</ul>
<p><strong>分布式锁</strong></p>
<ul>
<li><p>分布式锁使用场景</p>
<ul>
<li>订单系统、秒杀系统</li>
<li>积分系统、消费系统</li>
<li>消息中间件、服务中间件、数据发布-订阅</li>
<li>分布式部署:集群、微服务</li>
<li>服务节点之间需要通信</li>
<li>数据强一致性要求、性能要求、并发量要求</li>
</ul>
</li>
<li><p>方案</p>
<ul>
<li>Redis<ul>
<li>Redis单节点<ul>
<li>Redis:性能优异的k-v数据库</li>
<li><code>setnx &lt;key&gt; &lt;value&gt;</code>  键值对获取资源</li>
<li><code>del &lt;key&gt;</code>   释放资源</li>
<li>单点问题、雪崩效应</li>
</ul>
</li>
<li>Redis集群<ul>
<li>避免单点问题</li>
<li>节点一致性由集群保证</li>
<li>集群如何保证一致性的?  Redis集群原理</li>
</ul>
</li>
</ul>
</li>
<li>Zookeeper<ul>
<li>ZooKeeper是一个分布式的， 开放源码的分布式应用程序协调服务,是Google的Chubby-个开源的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件,提供的功能包括:配置维护、域名服务、分布式同步、组服务等</li>
<li>原理<ul>
<li>Zookeeper数据节点: znode</li>
<li>服务1在Zookeeper创建znode1.</li>
<li>服务2在Zookeeper创建znode1失败</li>
<li>服务1释放znode,服务2创建成功</li>
<li>临时节点:临时节点由某个客户端创建，当客户端与ZK集群断开连接，则该节点自动被删除</li>
</ul>
</li>
</ul>
</li>
<li>基于传统数据库: MySQL<ul>
<li>MySQL提供一致性服务:事务、表级锁、行级锁</li>
<li>UNIQUE KEY:表级唯一, 不能重复插入</li>
<li>通过MySQL保证同一-个KEY只有一个节点能插入成功</li>
<li>通过删除记录释放锁</li>
<li>把锁竞争的压力交给了MySQL,且MySQL同样存在单点问题，需要集群解决</li>
</ul>
</li>
</ul>
</li>
<li><p>分布式锁框架</p>
<ul>
<li>京东: SharkLock</li>
<li>Netflix: Curator</li>
<li>Google: Chubby</li>
<li>ETCD</li>
<li>Redisson</li>
<li>consul</li>
</ul>
</li>
</ul>
<p><strong>字节码、程序编译与程序解释</strong></p>
<ul>
<li>编译是将高级语言整体翻译为底层语言在机器上执行，编译是将高级语言翻译成和高级语言逻辑完全一致的低级语言</li>
<li>解释是将高级语言作为输入，一句一转换的转换为底层指令在机器上执行</li>
</ul>
<p><img src="/2022/01/26/C++/C++interview/image-20230106145803859.png" alt="image-20230106145803859"></p>
<ul>
<li><p>编译型语言: C/C+＋、Object-C、Golang</p>
</li>
<li><p>解释型语言：Python、Php、Javascript</p>
</li>
<li><p>java虚拟机</p>
<ul>
<li>Java是一种编译+解释的语言<ul>
<li>java程序  编译成  JVM字节码 </li>
<li>JVM字节码 解释成  机器码</li>
<li>字节码(英语:Bytecode)通常指的是已经经过编译，但与特定机器代码无关，需要解释器转译后才能成为机器代码的中间代码。字节码通常不像源码一样可以让人阅读，而是编码后的数值常量、引用、指令等构成的序列。</li>
</ul>
</li>
<li>Java程序 –&gt; Java字节码 –&gt; Java虚拟机 –&gt; 操作系统</li>
<li>没有虚拟机的问题<ul>
<li>不同平台不同的编译器</li>
<li>不同平台部署需要重新编译</li>
<li>编译结果不复用</li>
</ul>
</li>
<li>有了Java虚拟机，一次编译，随处运行</li>
</ul>
</li>
</ul>
<p><img src="/2022/01/26/C++/C++interview/image-20230106150451923.png" alt="image-20230106150451923"></p>
<p><strong>编译器工作原理</strong></p>
<p>词法分析、语法分析、语义分析、中间代码生成、优化分析、代码生成</p>
<ul>
<li>词法分析</li>
</ul>
<p><img src="/2022/01/26/C++/C++interview/image-20230106162000294.png" alt="image-20230106162000294"></p>
<ul>
<li>语法分析</li>
</ul>
<p><img src="/2022/01/26/C++/C++interview/image-20230106162216358.png" alt="image-20230106162216358"></p>
<ul>
<li><p>语义分析</p>
<ul>
<li>构建语义树</li>
<li>检查类型</li>
</ul>
</li>
<li><p>中间代码生成</p>
<ul>
<li>临时变量的生成</li>
</ul>
</li>
<li><p>优化分析</p>
<ul>
<li>合并可合并的代码</li>
</ul>
</li>
<li><p>代码生成</p>
<ul>
<li>生成机器码</li>
</ul>
</li>
</ul>
<p><strong>程序运行流程</strong></p>
<p>预编译、编译、汇编、链接、装载、运行</p>
<ul>
<li><p>预编译</p>
<ul>
<li>预编译主要是做一些代码文本的替换工作</li>
<li>#define、#include、 条件编译</li>
<li>代码注释</li>
</ul>
</li>
<li><p>编译</p>
<ul>
<li><code>g++ -c test.cpp -o test.o</code>  生成<code>.o</code>的文件   <code>test.cpp ----&gt;  test.o</code></li>
</ul>
</li>
<li><p>汇编</p>
<ul>
<li>将代码转换为机器码</li>
</ul>
</li>
<li><p>链接</p>
<ul>
<li>目标文件仅仅是当前的源码文件编译成的二进制文件</li>
<li>并没有经过链接过程，是不能够执行的</li>
</ul>
</li>
</ul>
<p><img src="/2022/01/26/C++/C++interview/image-20230106163315995.png" alt="image-20230106163315995"></p>
<ul>
<li>装载<ul>
<li>可执行文件加载到内存运行</li>
</ul>
</li>
</ul>
<p><strong>JIT技术</strong></p>
<ul>
<li>JIT技术(Just In Time):通常对于存在中间代码的运行系统(Java、Python等), 解释执行过程的效率不如传统本地代码的执行效率，在实现JIT的系统中JIT可以在运行过程动态将中间字节码编译成本地代码，从而加快运行速度。</li>
<li>就是将部分源码直接编译成机器码，跳过编译成字节码再解释成机器码的过程</li>
<li>使用前提：性能优化收益大于编译消耗（JIT编译的过程是动态的，不是先编译成可执行文件再执行）</li>
</ul>
<p><strong>分层存储体系</strong></p>
<ul>
<li>1cycle是纳秒级别（10的负九次方）</li>
<li>cycle是CPU的执行周期</li>
<li>HD: 是硬盘，读写速度要10-50百万（m）个cycle, SSD比以前的HD快一些</li>
<li>L1，L2, L3是缓存，一般常量会存在这里，频繁访问的数据也存在这里，这样就可以提升访问效率，但是进程切换就会改变缓存中存储的内容，所以要减少进程的切换</li>
</ul>
<p><img src="/2022/01/26/C++/C++interview/image-20230109135327435.png" alt="image-20230109135327435"></p>
<p><strong>文件系统</strong></p>
<h2 id="马士兵操作系统"><a href="#马士兵操作系统" class="headerlink" title="马士兵操作系统"></a>马士兵操作系统</h2><blockquote>
<p>操作系统：进程管理，内存管理，文件管理，输入输出（设备管理）</p>
</blockquote>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>快慢表</p>
<ul>
<li>通过慢表修改数据，需要访问内存两次<ul>
<li>访问慢表，拿到块号</li>
<li>通过块号计算出物理地址，访问物理地址</li>
</ul>
</li>
<li>快表存储在高速缓存区<ul>
<li>只用一次访问内存</li>
</ul>
</li>
</ul>
<p>二级页表</p>
<p><img src="/2022/01/26/C++/C++interview/image-20230701153053180.png" alt="image-20230701153053180"></p>
<p>块表和二级页表解决的问题</p>
<ul>
<li>块表的解决多次访问内存的问题，本质还是解决页表访问慢的问题</li>
<li>页表太大，访问速度太慢，所以需要用二级页表</li>
<li>二级页表同时解决动态装载的问题，需要时才构建相应的二级页表</li>
</ul>
<p>段页式存储</p>
<p><img src="/2022/01/26/C++/C++interview/image-20230701160652026.png" alt="image-20230701160652026"></p>
<p>内中断与外中断</p>
<ul>
<li>内中断<ul>
<li>cup产生的中断，如缺页终端，是符合时钟周期的</li>
<li>非cpu产生的中断，如I/O中断请求，人工干预等，是不符合时钟周期的，cpu不可预测</li>
</ul>
</li>
</ul>
<p>虚拟内存</p>
<blockquote>
<p>核心是将除CPU外的存储设备都视为内存，通过页面置换算法，页面分配策略等实现在有限的内存空间按需<strong>动态加载</strong>数据保证程序正常运行</p>
</blockquote>
<p><img src="/2022/01/26/C++/C++interview/image-20230701163820134.png" alt="image-20230701163820134"></p>
<h1 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h1><p>Hadoop</p>
<blockquote>
<p><a href="https://blog.csdn.net/m0_46914845/article/details/125762491" target="_blank" rel="noopener">https://blog.csdn.net/m0_46914845/article/details/125762491</a></p>
</blockquote>
<p>Spark</p>
<blockquote>
<p><a href="https://blog.csdn.net/qinlingheshang/article/details/123232539" target="_blank" rel="noopener">https://blog.csdn.net/qinlingheshang/article/details/123232539</a></p>
</blockquote>
<p>Hadoop和Spark的对比</p>
<blockquote>
<p><a href="https://blog.csdn.net/Swofford/article/details/125305625" target="_blank" rel="noopener">https://blog.csdn.net/Swofford/article/details/125305625</a></p>
</blockquote>
<h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><blockquote>
<p><a href="https://blog.csdn.net/C0631xjn_/article/details/128616275" target="_blank" rel="noopener">STL六大组件之一——适配器（adapters）</a></p>
</blockquote>
<h3 id="六大部件"><a href="#六大部件" class="headerlink" title="六大部件"></a>六大部件</h3><p>容器</p>
<p>算法</p>
<p>分配器</p>
<p>迭代器 iterator</p>
<p>仿函数</p>
<ul>
<li>本质是类，只是使用形式类似函数，在类内部重载了函数执行运算符</li>
</ul>
<p>适配器</p>
<ul>
<li><p>容器适配器</p>
<ul>
<li>stack、queue 、priority_queue 都不是容器，而是deque容器的适配器</li>
</ul>
</li>
<li><p>迭代器适配器</p>
</li>
<li><p>仿函数适配器</p>
<ul>
<li>bind2nd  绑定第二个参数</li>
<li>not1 取反</li>
</ul>
</li>
</ul>
<p>迭代器begin和cbegin的区别</p>
<p><a href="https://blog.csdn.net/u010987458/article/details/70949112" target="_blank" rel="noopener">https://blog.csdn.net/u010987458/article/details/70949112</a></p>
<p><code>greater&lt;int&gt;()和less&lt;int&gt;()的使用</code></p>
<p><a href="https://blog.csdn.net/qq_21997625/article/details/76662113" target="_blank" rel="noopener">https://blog.csdn.net/qq_21997625/article/details/76662113</a></p>
<p>bind2nd</p>
<p><a href="https://www.jianshu.com/p/12860aea987b" target="_blank" rel="noopener">https://www.jianshu.com/p/12860aea987b</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = &#123;<span class="number">12</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">632</span>,<span class="number">5</span>,<span class="number">689</span>,<span class="number">34</span>,<span class="number">67</span>,<span class="number">89</span>&#125;;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;count_if(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), not1(bind2nd(less&lt;<span class="keyword">int</span>&gt;(), <span class="number">40</span>)))&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>





<ul>
<li>用下面的方式替代迭代器的使用</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(atuo a : res)</span><br><span class="line"><span class="keyword">for</span>(atuo&amp; a : res)</span><br></pre></td></tr></table></figure>



<ul>
<li>容器自带的算法就只能用自带的<ul>
<li>list自带sort就只能用自带的，不能用全局算法中的sort</li>
<li>全局算法中的sort依赖于数组形式的结构，但list是链表形式的结构，所以list不能用，只能用自带的sort</li>
</ul>
</li>
<li>使用分配器</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>,_gnu_cxx::__pool_alloc&lt;<span class="built_in">string</span>&gt;&gt; vec;</span><br></pre></td></tr></table></figure>

<ul>
<li>容器sizeof<ul>
<li>queue 和 stack内置的是一个deque， 所以大小和deque一样</li>
<li>set和map内置红黑树，大小即红黑树的大小</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 10&gt; a; <span class="comment">// 40  元素个数*元素大小</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(a)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 40</span></span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 8&gt; a; <span class="comment">// 32</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(a)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 32</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;  <span class="comment">// 24  头指针  尾指针  容量尾指针  3*8 = 24</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(vec)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; lis;  <span class="comment">// 24</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(lis)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">forward_list&lt;<span class="keyword">double</span>&gt; flist;  <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(flist)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; deq; <span class="comment">// 80 两个迭代器，每个迭代器有3个标志位和一个指针 2*4  本身有一个控制指针和控制容量 （2*4+2）*8 = 80</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(deq)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 80</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q; <span class="comment">// 80</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(q)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 80</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s; <span class="comment">// 80</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(s)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 80</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">double</span>&gt; <span class="built_in">set</span>; <span class="comment">// 48  红黑树 左指针 右指针 父指针 节点颜色</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(<span class="built_in">set</span>)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 48</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>; <span class="comment">// 48</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(<span class="built_in">map</span>)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 48</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;R_ID&gt;&gt;  mp; <span class="comment">// 48</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;R_ID&gt;&gt;  mp; <span class="comment">//56</span></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; umap; <span class="comment">// 56</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(umap)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 56</span></span><br></pre></td></tr></table></figure>

<h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><blockquote>
<p>array不同于其它容器，其它容器是类，有构造函数，array是结构体</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 100&gt; arr;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(arr)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>

<p><strong>元素访问</strong></p>
<table>
<thead>
<tr>
<th><a href="https://zh.cppreference.com/w/cpp/container/array/at" target="_blank" rel="noopener">at</a>(C++11)</th>
<th>访问指定的元素，同时进行越界检查 (公开成员函数)</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://zh.cppreference.com/w/cpp/container/array/operator_at" target="_blank" rel="noopener">operator[]</a>(C++11)</td>
<td>访问指定的元素 (公开成员函数)</td>
</tr>
<tr>
<td><a href="https://zh.cppreference.com/w/cpp/container/array/front" target="_blank" rel="noopener">front</a>(C++11)</td>
<td>访问第一个元素 (公开成员函数)</td>
</tr>
<tr>
<td><a href="https://zh.cppreference.com/w/cpp/container/array/back" target="_blank" rel="noopener">back</a>(C++11)</td>
<td>访问最后一个元素 (公开成员函数)</td>
</tr>
<tr>
<td><a href="https://zh.cppreference.com/w/cpp/container/array/data" target="_blank" rel="noopener">data</a>(C++11)</td>
<td>直接访问底层数组 (公开成员函数)</td>
</tr>
</tbody></table>
<p>data</p>
<ul>
<li>返回底层数组首地址，不是begin，begin是迭代器，是对首地址封装，概念不同</li>
<li>但实质上是data和begin是一样的，在vector和array中迭代器的性质和直接返回的底层数组首地址一样</li>
<li><a href="https://www.bbsmax.com/A/KE5QybbZ5L/" target="_blank" rel="noopener">https://www.bbsmax.com/A/KE5QybbZ5L/</a></li>
<li><a href="https://www.5axxw.com/questions/content/zaxg8g" target="_blank" rel="noopener">https://www.5axxw.com/questions/content/zaxg8g</a></li>
</ul>
<p><strong>迭代器</strong></p>
<table>
<thead>
<tr>
<th><a href="https://zh.cppreference.com/w/cpp/container/array/begin" target="_blank" rel="noopener">begincbegin</a>(C++11)</th>
<th>返回指向起始的迭代器 (公开成员函数)</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://zh.cppreference.com/w/cpp/container/array/end" target="_blank" rel="noopener">endcend</a>(C++11)</td>
<td>返回指向末尾的迭代器 (公开成员函数)</td>
</tr>
<tr>
<td><a href="https://zh.cppreference.com/w/cpp/container/array/rbegin" target="_blank" rel="noopener">rbegincrbegin</a>(C++11)</td>
<td>返回指向起始的逆向迭代器 (公开成员函数)</td>
</tr>
<tr>
<td><a href="https://zh.cppreference.com/w/cpp/container/array/rend" target="_blank" rel="noopener">rendcrend</a>(C++11)</td>
<td>返回指向末尾的逆向迭代器 (公开成员函数)</td>
</tr>
</tbody></table>
<p><strong>容量</strong></p>
<table>
<thead>
<tr>
<th><a href="https://zh.cppreference.com/w/cpp/container/array/empty" target="_blank" rel="noopener">empty</a>(C++11)</th>
<th>检查容器是否为空 (公开成员函数)</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://zh.cppreference.com/w/cpp/container/array/size" target="_blank" rel="noopener">size</a>(C++11)</td>
<td>返回容纳的元素数 (公开成员函数)</td>
</tr>
<tr>
<td><a href="https://zh.cppreference.com/w/cpp/container/array/max_size" target="_blank" rel="noopener">max_size</a>(C++11)</td>
<td>返回可容纳的最大元素数 (公开成员函数)</td>
</tr>
</tbody></table>
<p>size=max_size</p>
<ul>
<li>max_size官网有解释：因为每个 <code>std::array&lt;T, N&gt;</code> 都是固定大小容器，故 <code>max_size</code> 返回的值等于 <code>N</code> （亦为 <a href="https://zh.cppreference.com/w/cpp/container/array/size" target="_blank" rel="noopener">size</a> 所返回的值）</li>
</ul>
<p><strong>操作</strong></p>
<table>
<thead>
<tr>
<th><a href="https://zh.cppreference.com/w/cpp/container/array/fill" target="_blank" rel="noopener">fill</a>(C++11)</th>
<th>以指定值填充容器 (公开成员函数)</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://zh.cppreference.com/w/cpp/container/array/swap" target="_blank" rel="noopener">swap</a>(C++11)</td>
<td>交换内容 (公开成员函数)</td>
</tr>
</tbody></table>
<p>fill</p>
<ul>
<li>填充数组中的每个元素为指定的值： <code>arr.fill(10)  数组中每个元素都变为10</code></li>
<li><a href="http://www.manongjc.com/detail/31-ektcxzoezjrjuag.html" target="_blank" rel="noopener">http://www.manongjc.com/detail/31-ektcxzoezjrjuag.html</a></li>
</ul>
<h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>size、max_size、capacity</p>
<ul>
<li>size: 当前容器中的元素个数</li>
<li>capacity： 当前已经分配的空间大小，因为vector是动态扩容的</li>
<li>max_size： 理论上可以容纳的元素个数，即内存分配有关</li>
<li>size&lt;=capacity&lt;=max_size</li>
</ul>
<blockquote>
<p><a href="https://blog.csdn.net/ganfanren00001/article/details/122024121" target="_blank" rel="noopener">解决vector.capacity() &gt; vector.size()导致内存空间浪费的问题</a></p>
<ul>
<li>存在这个问题的原因：vector的动态增长是倍数增长，压入1时开辟2，压入2时开辟4，压入3不开辟，压入4开辟8，，，<ul>
<li>vector相对array存储相同的元素<strong>内存空间会更大</strong>，因为vector.capacity() &gt; vector.size(), vector会开辟更多空间，用于动态添加元素</li>
<li>vector每次动态扩容，都会拷贝构造和析构，<strong>开销也会很大</strong></li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>解决vector.capacity() &gt; vector.size()导致内存空间浪费的问题<ul>
<li>这里使用vector(vec1)构造了一个临时对象，前面讲过，构造函数可以时新构造的容器的capacity缩小为size值</li>
<li>然后调用这个临时容器的swap，将其与vec1互换内存地址，临时容器就变成了有冗余容量的容器，vec1经过变换后变成了容量capacity和size相等的容器</li>
<li>没有分配标识符的临时vector在下一句立刻被析构释放。</li>
<li>vec1的容量被成功缩小</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i)&#123;</span><br><span class="line">  vec.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;vec.<span class="built_in">size</span>()&lt;&lt;<span class="built_in">endl</span>;     <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;vec.capacity()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 128</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;vec.max_size()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 4611686018427387903</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(vec).swap(vec);  <span class="comment">// vector&lt;int&gt;(vec)表示用vec构造一个临时对象</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;vec.<span class="built_in">size</span>()&lt;&lt;<span class="built_in">endl</span>;     <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;vec.capacity()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;vec.max_size()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 4611686018427387903</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><a href="https://zh.cppreference.com/w/cpp/container/vector/shrink_to_fit" target="_blank" rel="noopener">shrink_to_fit</a></p>
<ul>
<li>c++11开始支持的的自带解决vector.capacity() &gt; vector.size()问题的函数</li>
<li>时间复杂度：至多与容器大小成线性。</li>
</ul>
</li>
<li><p>两种方式对比性能</p>
<ul>
<li>shrink_to_fit更快, 基本是另一种方法的1.2–1.6倍</li>
<li>原因可能是：构造函数需要开辟空间，然后移动，然后删除临时空间，开销更大</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testCreate</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">100000000</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">      vec.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;vec.<span class="built_in">size</span>()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;vec.capacity()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">clock_t</span> startTime = clock();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(vec).swap(vec);</span><br><span class="line">    <span class="keyword">clock_t</span> endTime = clock();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"runtime: "</span> &lt;&lt; <span class="keyword">double</span>(endTime - startTime) / CLOCKS_PER_SEC &lt;&lt; <span class="string">" s"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;vec.<span class="built_in">size</span>()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;vec.capacity()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testShrinkTF</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">100000000</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">      vec.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;vec.<span class="built_in">size</span>()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;vec.capacity()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">clock_t</span> startTime = clock();</span><br><span class="line">    vec.shrink_to_fit();</span><br><span class="line">    <span class="keyword">clock_t</span> endTime = clock();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"runtime: "</span> &lt;&lt; <span class="keyword">double</span>(endTime - startTime) / CLOCKS_PER_SEC &lt;&lt; <span class="string">" s"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;vec.<span class="built_in">size</span>()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;vec.capacity()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  testCreate();</span><br><span class="line">  testShrinkTF();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line"><span class="comment">// testCreate</span></span><br><span class="line"><span class="number">100000000</span></span><br><span class="line"><span class="number">134217728</span></span><br><span class="line">runtime: <span class="number">0.590234</span> s</span><br><span class="line"><span class="number">100000000</span></span><br><span class="line"><span class="number">100000000</span></span><br><span class="line"><span class="comment">// testShrinkTF   </span></span><br><span class="line"><span class="number">100000000</span></span><br><span class="line"><span class="number">134217728</span></span><br><span class="line">runtime: <span class="number">0.370269</span> s</span><br><span class="line"><span class="number">100000000</span></span><br></pre></td></tr></table></figure>



<p><strong>resize、assign、reserve、clear区别</strong></p>
<blockquote>
<p> resize 和 assign: <a href="https://www.dianjilingqu.com/629188.html" target="_blank" rel="noopener">https://www.dianjilingqu.com/629188.html</a></p>
<p> assign resize reserve: <a href="https://blog.51cto.com/u_4135183/2822759" target="_blank" rel="noopener">https://blog.51cto.com/u_4135183/2822759</a></p>
<p> 关键点： capacity只能扩大不能缩小</p>
<p> 总结：</p>
<ul>
<li>assign： size、capacity都修改  必须填充   直接重置</li>
<li>resize:  修改size ，扩展部分可填充 </li>
<li>reserve:  修改capacity  </li>
<li>clear:  修改size为0</li>
</ul>
</blockquote>
<ul>
<li>resize<ul>
<li>修改size大小<ul>
<li>size变大，则修改部分由第二个参数填充，若没有传第二个参数则填充为：类型()  int型就填充为0</li>
<li>size变小，则丢掉缩小的范围内的值</li>
</ul>
</li>
<li>对capacity不影响，capacity仍然按动态扩容的策略更新</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;v.<span class="built_in">size</span>()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 3</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;v.capacity()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 3</span></span><br><span class="line">  v.resize(<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; el: v) <span class="built_in">cout</span> &lt;&lt; el &lt;&lt; <span class="string">' '</span>; <span class="comment">// 1 2 3 0 0 </span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;v.<span class="built_in">size</span>()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 5</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;v.capacity()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 6  动态扩容</span></span><br><span class="line"></span><br><span class="line">  v.resize(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; el: v) <span class="built_in">cout</span> &lt;&lt; el &lt;&lt; <span class="string">' '</span>; <span class="comment">// 1 2</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;v.<span class="built_in">size</span>()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 2</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;v.capacity()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line">  v.resize(<span class="number">6</span>, <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; el: v) <span class="built_in">cout</span> &lt;&lt; el &lt;&lt; <span class="string">' '</span>; <span class="comment">// 1 2 4 4 4 4 </span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;v.<span class="built_in">size</span>()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 6</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;v.capacity()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;v.<span class="built_in">size</span>()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 3</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;v.capacity()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 3</span></span><br><span class="line">  v.resize(<span class="number">7</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; el: v) <span class="built_in">cout</span> &lt;&lt; el &lt;&lt; <span class="string">' '</span>; <span class="comment">// 1 2 3 0 0 0 0 </span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;v.<span class="built_in">size</span>()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 7</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;v.capacity()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 7  超过动态扩容的范围(6)则直接开辟指定大小的空间</span></span><br><span class="line"></span><br><span class="line">  v.resize(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; el: v) <span class="built_in">cout</span> &lt;&lt; el &lt;&lt; <span class="string">' '</span>; <span class="comment">// 1 2</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;v.<span class="built_in">size</span>()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 2</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;v.capacity()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line">  v.resize(<span class="number">6</span>, <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; el: v) <span class="built_in">cout</span> &lt;&lt; el &lt;&lt; <span class="string">' '</span>; <span class="comment">// 1 2 4 4 4 4 </span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;v.<span class="built_in">size</span>()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 6</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;v.capacity()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>

<ul>
<li>assign： 用于初始化<ul>
<li>修改时，第二个填充的参数必填，否则报错</li>
<li>同时修改size和capacity,  就是初始化，一开始给定的 多少开辟的capacity就是多大</li>
<li>如果缩小则capacity不变</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;v.<span class="built_in">size</span>()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;v.capacity()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 3</span></span><br><span class="line">v.assign(<span class="number">5</span>, <span class="number">3</span>); <span class="comment">// 第二个参数必填</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; el: v) <span class="built_in">cout</span> &lt;&lt; el &lt;&lt; <span class="string">' '</span>; <span class="comment">// 3 3 3 3 3 </span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;v.<span class="built_in">size</span>()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;v.capacity()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">v.assign(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; el: v) <span class="built_in">cout</span> &lt;&lt; el &lt;&lt; <span class="string">' '</span>; <span class="comment">// 4 4</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;v.<span class="built_in">size</span>()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;v.capacity()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">v.assign(<span class="number">11</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; el: v) <span class="built_in">cout</span> &lt;&lt; el &lt;&lt; <span class="string">' '</span>; <span class="comment">// 5 5 5 5 5 5 5 5 5 5 5 </span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;v.<span class="built_in">size</span>()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 11</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;v.capacity()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 11</span></span><br></pre></td></tr></table></figure>

<ul>
<li>reserve<ul>
<li>修改capacity大小，且只能扩大不能缩小capacity</li>
<li>对size不影响</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;v.<span class="built_in">size</span>()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;v.capacity()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 3</span></span><br><span class="line">v.reserve(<span class="number">5</span>); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; el: v) <span class="built_in">cout</span> &lt;&lt; el &lt;&lt; <span class="string">' '</span>; <span class="comment">// 1 2 3 </span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;v.<span class="built_in">size</span>()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;v.capacity()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">v.reserve(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; el: v) <span class="built_in">cout</span> &lt;&lt; el &lt;&lt; <span class="string">' '</span>; <span class="comment">// 1 2 3 </span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;v.<span class="built_in">size</span>()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;v.capacity()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">v.reserve(<span class="number">11</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; el: v) <span class="built_in">cout</span> &lt;&lt; el &lt;&lt; <span class="string">' '</span>; <span class="comment">// 1 2 3  </span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;v.<span class="built_in">size</span>()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;v.capacity()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 11</span></span><br></pre></td></tr></table></figure>

<ul>
<li>clear<ul>
<li>改变size为0</li>
<li>对capacity无影响</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;v.<span class="built_in">size</span>()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;v.capacity()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 3</span></span><br><span class="line">v.<span class="built_in">clear</span>(); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; el: v) <span class="built_in">cout</span> &lt;&lt; el &lt;&lt; <span class="string">' '</span>; <span class="comment">// </span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;v.<span class="built_in">size</span>()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;v.capacity()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><a href="https://blog.csdn.net/nirendao/article/details/114859295" target="_blank" rel="noopener">emplace_back/emplace 与 push_back/insert 效率的详细比较</a></p>
<p>emplace_back/emplace传入的参数不是容器的数据类型，而是构造容器数据类型的参数，原地构造，相对push_back/insert少了一次移动构造或拷贝构造</p>
<ul>
<li>push_back/insert是右值参数时，少一次移动构造</li>
<li>push_back/insert是左值参数时，少一次拷贝构造</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">President</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> country;</span><br><span class="line">    <span class="keyword">int</span> year;</span><br><span class="line"> </span><br><span class="line">    President(<span class="built_in">std</span>::<span class="built_in">string</span> p_name, <span class="built_in">std</span>::<span class="built_in">string</span> p_country, <span class="keyword">int</span> p_year)</span><br><span class="line">        : name(<span class="built_in">std</span>::<span class="built_in">move</span>(p_name)), country(<span class="built_in">std</span>::<span class="built_in">move</span>(p_country)), year(p_year)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I am being constructed.\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    President(President&amp;&amp; other) <span class="comment">// 右值应用，移动构造</span></span><br><span class="line">        : name(<span class="built_in">std</span>::<span class="built_in">move</span>(other.name)), country(<span class="built_in">std</span>::<span class="built_in">move</span>(other.country)), year(other.year)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I am being moved.\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    President&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> President&amp; other) = <span class="keyword">default</span>;  <span class="comment">// 左值引用 ， 拷贝构造</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;President&gt; elections;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"emplace_back:\n"</span>;</span><br><span class="line">    elections.emplace_back(<span class="string">"Nelson Mandela"</span>, <span class="string">"South Africa"</span>, <span class="number">1994</span>);</span><br><span class="line">    <span class="comment">// elections.emplace_back(President("Nelson Mandela", "South Africa", 1994));   这种方式同下面的push_back</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;President&gt; reElections;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\npush_back:\n"</span>;</span><br><span class="line">    reElections.push_back(President(<span class="string">"Franklin Delano Roosevelt"</span>, <span class="string">"the USA"</span>, <span class="number">1936</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印</span></span><br><span class="line">emplace_back:</span><br><span class="line">I am being constructed.</span><br><span class="line"> </span><br><span class="line">push_back:</span><br><span class="line">I am being constructed.</span><br><span class="line">I am being moved.</span><br></pre></td></tr></table></figure>

<h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><p>注意在访问，top，pop等方法时需要先判断栈是否为空</p>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><ul>
<li>multimap和unordered_multimap不可用[]作insert,  map和unordered_map可以用[]作insert  </li>
<li>mp[i] 操作值时，初始值是什么？<ul>
<li>mp[i]时，若i在map中不存在，则会先创造这个mp[i]这个数据对,再返回mp[i]</li>
</ul>
</li>
<li>只要使用mp[i], 就会构造mp[i], 初始值应该为容器数据类型的默认值（即 int(), string(), char()）<ul>
<li>作判断、作左值、作右值都会构造mp[i]、打印</li>
</ul>
</li>
<li>默认按键的升序排列<ul>
<li>修改为键的降序：<code>multimap&lt;int, char,greater&lt;int&gt;&gt; count;</code></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">multimap</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; temp;</span><br><span class="line">temp.insert(&#123;<span class="number">1</span>,<span class="number">1</span>&#125;); <span class="comment">// 正确</span></span><br><span class="line">temp[<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">//错误</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; temp;</span><br><span class="line">temp.insert(&#123;<span class="number">1</span>,<span class="number">1</span>&#125;); <span class="comment">// 正确</span></span><br><span class="line">temp[<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// 正确</span></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; temp1;</span><br><span class="line">temp1.insert(&#123;<span class="number">1</span>, &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>&#125;&#125;);</span><br><span class="line">temp1[<span class="number">1</span>].push_back(<span class="number">1</span>); <span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line">  <span class="comment">// unordered_map&lt;int, vector&lt;R_ID&gt;&gt;  mp;</span></span><br><span class="line">  <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;R_ID&gt;&gt;  mp;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i )&#123;</span><br><span class="line">    mp[i].push_back(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; a : mp)&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a.first&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(mp[<span class="number">1</span>].<span class="built_in">size</span>())&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"1 has...."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(mp[<span class="number">11</span>].<span class="built_in">size</span>())&#123;  <span class="comment">// 可以正常判断</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"11 has...."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(mp)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// map[]的使用</span></span><br><span class="line">  <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp1;</span><br><span class="line">  <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mp2;</span><br><span class="line">  <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt; mp3;</span><br><span class="line">  <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; mp4;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 作判断</span></span><br><span class="line">  <span class="keyword">if</span>(mp1[<span class="number">1</span>] == <span class="number">0</span>)&#123;&#125;</span><br><span class="line">  <span class="keyword">if</span>(mp2[<span class="number">1</span>] == <span class="string">"123"</span>)&#123;&#125; <span class="comment">//mp2[1]初始化为string()</span></span><br><span class="line">  <span class="keyword">if</span>(mp3[<span class="number">1</span>] == <span class="string">'c'</span>)&#123;&#125; <span class="comment">//mp3[1]初始化为char()</span></span><br><span class="line">  <span class="keyword">if</span>(mp1[<span class="number">2</span>])&#123;&#125; <span class="comment">// 未报错</span></span><br><span class="line">  <span class="comment">//if(mp2[1])&#123;&#125; // 报错，本质应该是值的数据类型是否可以转换为bool类型  string不能强制转换为bool</span></span><br><span class="line">  <span class="comment">//if(mp4[1])&#123;&#125; // 报错，vector不能强制转换为bool</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 作左值</span></span><br><span class="line">  mp1[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">  mp2[<span class="number">2</span>] = <span class="string">"test"</span>;</span><br><span class="line">  mp3[<span class="number">2</span>] = <span class="string">'t'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 作右值</span></span><br><span class="line">  <span class="keyword">int</span> x = mp1[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打印</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;mp1[<span class="number">5</span>]&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"------mp1-------"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; a : mp1)&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a.first&lt;&lt;<span class="string">": "</span>&lt;&lt;a.second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"------mp2-------"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; a : mp2)&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a.first&lt;&lt;<span class="string">": "</span>&lt;&lt;a.second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"------mp3-------"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; a : mp3)&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a.first&lt;&lt;<span class="string">": "</span>&lt;&lt;a.second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">int</span>()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 0</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">string</span>()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// ""</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">char</span>()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// ''</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打印结果</span></span><br><span class="line">  <span class="comment">// ------mp1-------</span></span><br><span class="line">  <span class="comment">// 1: 0</span></span><br><span class="line">  <span class="comment">// 2: 0</span></span><br><span class="line">  <span class="comment">// 3: 3</span></span><br><span class="line">  <span class="comment">// 4: 0</span></span><br><span class="line">  <span class="comment">// 5: 0</span></span><br><span class="line">  <span class="comment">// ------mp2-------</span></span><br><span class="line">  <span class="comment">// 1: </span></span><br><span class="line">  <span class="comment">// 2: test</span></span><br><span class="line">  <span class="comment">// ------mp3-------</span></span><br><span class="line">  <span class="comment">// 1: </span></span><br><span class="line">  <span class="comment">// 2: t</span></span><br></pre></td></tr></table></figure>

<h3 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h3><ul>
<li>系统分配的篮子大小为53(质数，gcc2.9编译器处理的情况是53)</li>
<li>篮子是用vector实现的，只是扩容策略不是两倍扩容，而是写死的质数扩容<ul>
<li>压入元素个数大于篮子大小时篮子扩容，扩容一般是当前大小2倍左右的一个质数大小</li>
</ul>
</li>
</ul>
<h3 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h3><ul>
<li>默认是最大堆</li>
<li>改为最小堆</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>自定义比较函数</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 个位数大的在前</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCom</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a%<span class="number">10</span> &lt; b%<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;int, vector&lt;int&gt;, decltype(myCom)&gt; pq(myCom);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转为最小堆</span></span><br><span class="line"><span class="keyword">auto</span> cmp = [](ListNode* l1, ListNode* l2)&#123;</span><br><span class="line">  <span class="keyword">return</span> l1-&gt;val &gt; l2-&gt;val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, decltype(cmp)&gt; pq(cmp); // decltype 用于数据类型的推导</span><br></pre></td></tr></table></figure>

<h3 id="set、map"><a href="#set、map" class="headerlink" title="set、map"></a>set、map</h3><ul>
<li>set、map在循环时，set的值和map的key是不能修改的</li>
</ul>
<h3 id="相关知识点"><a href="#相关知识点" class="headerlink" title="相关知识点"></a>相关知识点</h3><h4 id="move-左值-右值"><a href="#move-左值-右值" class="headerlink" title="move 左值 右值"></a>move 左值 右值</h4><blockquote>
<p><a href="http://www.manongjc.com/detail/23-dciaudkgcqpkulj.html" target="_blank" rel="noopener">http://www.manongjc.com/detail/23-dciaudkgcqpkulj.html</a></p>
</blockquote>
<p><strong>左值 右值</strong></p>
<ul>
<li><p>左值是表达式结束后依然存在的持久对象(代表一个在内存中占有确定位置的对象)</p>
</li>
<li><p>右值是表达式结束时不再存在的临时对象(不在内存中占有确定位置的表达式）</p>
</li>
</ul>
<p><strong>move</strong></p>
<p>待完成</p>
<h4 id="迭代器移动"><a href="#迭代器移动" class="headerlink" title="迭代器移动"></a>迭代器移动</h4><blockquote>
<p><a href="http://c.biancheng.net/view/7384.html" target="_blank" rel="noopener">C++ STL prev()和next()函数用法详解</a></p>
</blockquote>
<p>迭代的++是对++运算符重载了的</p>
<p>it += 2 不一定等于两次it++  </p>
<ul>
<li>线性容器可以这样用，但是非线性容器则会报错</li>
</ul>
<p>next(it, 2)表示往后移动2个单位, 并将移动后的迭代器返回，原迭代器不变</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> it = v.<span class="built_in">begin</span>();</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 11</span></span><br><span class="line">++it;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="built_in">endl</span>;<span class="comment">// 12</span></span><br><span class="line">it += <span class="number">2</span>; <span class="comment">// 线性容器可以这样用，但是非线性容器则会报错,例如set, unordered_set</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="built_in">endl</span>;<span class="comment">// 14</span></span><br><span class="line">next(it, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="built_in">endl</span>;<span class="comment">// 14</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*(next(it, <span class="number">3</span>))&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 17</span></span><br><span class="line"><span class="keyword">auto</span> it1 = next(it, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*it1&lt;&lt;<span class="built_in">endl</span>;<span class="comment">// 17</span></span><br></pre></td></tr></table></figure>



<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>1 索引优化</p>
<blockquote>
<p>索引失效：<a href="https://mp.weixin.qq.com/s/orHhcaxjrRcJl9GJoVV3Zg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/orHhcaxjrRcJl9GJoVV3Zg</a></p>
<p>索引优化：<a href="https://mp.weixin.qq.com/s/hc4Nmk8L3FVRUTG3IQcreQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/hc4Nmk8L3FVRUTG3IQcreQ</a></p>
</blockquote>
<p>2 为什么使用b+树</p>
<p>b站 IT老哥<br>数据库索引<br>索引需求:<br>查找要快<br>要有顺序性<br>要可以快速范围查找</p>
<p>哈希索引<br>可能存在索引后链式查找的问题，查找不一定快<br>哈希是无序的，不满足顺序性<br>无序则也不支持范围查找</p>
<p>平衡二叉树<br>查找快，但是树的深度相对b树更深<br>满足有序性<br>但是范围查找要回旋查找，效率不高</p>
<p>b树<br>查找快，一个节点可以存多个值，比平衡二叉树深度浅<br>满足有序性<br>仍然需要回旋查找，范围查找太慢</p>
<p>b+树<br>查找快，深度浅<br>满足有序性<br>因为叶子节点是链式存储的方便范围查找<br>且MySQL将叶子节点改成了双向链表，范围查找更方便</p>
<p>索引失效是指在使用组合索引的情况下不使用最左前缀法则导致的索引失效</p>
<p>平衡二叉树和红黑树区别<br>平衡二叉树是严格平衡的，每次插入和删除都有可能需要旋转以达到平衡，所以适用于插入，删除少的情况，但查询相对红黑树快，因为高度浅<br>使用场景:Windows NT内核中广泛存在<br>红黑树是弱平衡二叉树，对于搜索，插入，删除操作较多的情况下，我们就用红黑树，但搜索性能低于平衡二叉树<br>使用场景: stl库map，set</p>
<p>红黑树定义</p>
<p>性质1. 结点是红色或黑色。 [3] </p>
<p>性质2. 根结点是黑色。 [3] </p>
<p>性质3. 所有叶子都是黑色。（叶子是NIL结点） [3] </p>
<p>性质4. 每个红色结点的两个子结点都是黑色。（从每个叶子到根的所有路径上不能有两个连续的红色结点）</p>
<p>性质5. 从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点。</p>
<p>b树b+树定义</p>
<p>3 redis的两个集群，和优势</p>
<p><strong>redis数据类型</strong></p>
<p>string、list、hash、set、zset</p>
<p><strong>缓存问题</strong></p>
<ul>
<li>缓存击穿：<ul>
<li>查询的数据不存在，redis不能缓存，所以每次不存在的查询都需要MYSQL处理</li>
<li>热点数据过期清除后，突然来了大量的对热点数据的请求，直接由MySQL处理</li>
</ul>
</li>
<li>缓存雪崩：<ul>
<li>相对缓存击穿，同时过期失效的热点数据特别多，导致大量热点数据的访问都需要MySQL来处理</li>
</ul>
</li>
<li>解决方案：<ul>
<li>热点数据永不过期</li>
<li>数据过期时间随机化，避免同时大量过期</li>
</ul>
</li>
</ul>
<p><strong>数据持久化</strong></p>
<ul>
<li>问题：进程死掉，挂机导致内存数据丢失</li>
<li>解决方案：将内存缓存的数据持久化到硬盘<ul>
<li>RDB<ul>
<li>每隔一段时间就将内存缓存的数据写入到磁盘持久化</li>
</ul>
</li>
<li>AOF<ul>
<li>记录内存的缓存数据到硬盘</li>
<li>每次更新只记录写入的操作命令，并将写入命令合并，然后去修改磁盘中的数据</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>高可用，主从节点集群</strong></p>
<ul>
<li>读写分离</li>
<li>主节点负责数据的写入和数据同步<ul>
<li>先生成RDB文件发给从节点，后续有写入修改则记录操作命令，并将命令发给从节点进行数据同步</li>
<li>操作命令发给从节点的同时写入一个命令缓冲区并用游标记录写入的位置（主记录写入游标，从记录各自的读游标，即读到哪儿了）<ul>
<li>从节点挂掉后重启，只需要在缓存区读命令更新即可，不要重新从主节点获取RDB文件，从缓存区读命令的标志是之前读命令的游标位置</li>
</ul>
</li>
</ul>
</li>
<li>从节点负责数据的读</li>
<li>如果主节点挂掉了就由从节点顶替<ul>
<li>但是需要程序员手动选择从节点进行顶替</li>
</ul>
</li>
</ul>
<p><strong>主从复制+哨兵监控管理</strong></p>
<blockquote>
<p>这种模式只能解决高可用的问题，不能解决数据量大的问题</p>
</blockquote>
<ul>
<li>多个哨兵监控主从节点，每隔一段时间则看主从节点是否还在线，来实现自动的主节点顶替<ul>
<li>如果一个哨兵发现一个节点掉线判定为主观下线，如果多个哨兵发现一个节点掉线则判断为客观下线则开始执行故障转移</li>
</ul>
</li>
<li>选择主节点的策略<ul>
<li>优先级高的，即硬件设配好的从节点</li>
<li>断开主节点时间最短的</li>
<li>复制偏移量最大的，即丢失的数据最少的从节点</li>
</ul>
</li>
</ul>
<p><strong>集群+主从复制</strong></p>
<ul>
<li>划分了16384个哈希桶，槽位slot ,每个节点负责一部分槽位<ul>
<li>如果有新节点加入则重新划分并分配每个节点负责的槽位</li>
<li>当请求来时先判断这个槽位是否是自己节点负责，如果是则响应，如果不是则返回负责这个槽位的ip</li>
</ul>
</li>
<li>每个节点都有一个从节点，当当前节点挂掉后则由从节点顶替</li>
</ul>
<p>4 acid</p>
<ul>
<li>原子性</li>
<li>一致性</li>
<li>隔离性</li>
<li>持久性</li>
</ul>
<p>5 三范式</p>
<pre><code>第一范式：要求任何一张表必须有主键，每一个字段原子性不可再分。

第二范式：建立在第一范式的基础之上，要求所有非主键字段完全依赖主键，不要产生部分依赖。

第三范式：建立在第二范式的基础之上，要求所有非主键字段直接依赖主键，不要产生传递依赖。</code></pre><p><strong>举例说明不符合第二范式的情况</strong></p>
<p>假设有一个学生课程表的数据库，其中包含以下表格：</p>
<ol>
<li>学生表格（Students），包含以下列：</li>
</ol>
<ul>
<li>StudentID (主键)</li>
<li>StudentName</li>
<li>Address</li>
</ul>
<ol>
<li>课程表格（Courses），包含以下列：</li>
</ol>
<ul>
<li>CourseID (主键)</li>
<li>CourseName</li>
<li>CourseDescription</li>
</ul>
<ol>
<li>成绩表格（Grades），包含以下列：</li>
</ol>
<ul>
<li>StudentID (主键，外键到学生表格)</li>
<li>CourseID (主键，外键到课程表格)</li>
<li>Grade</li>
</ul>
<p>在这个设计中，Grades 表符合第二范式的要求，因为每个非主键列都完全依赖于主键（即 StudentID 和 CourseID）。但是，如果我们向 Grades 表中添加一列 CourseName，用于存储课程的名称，那么该表就不符合第二范式的要求了，因为 CourseName 列只依赖于 CourseID 列，而不是主键（即它间接依赖于主键）。这种情况称为部分依赖。为了符合第二范式的要求，我们应该将 CourseName 列移动到课程表格中，并创建一个新的关系来连接成绩表格和课程表格。这样，每个非主键列都只依赖于主键，数据库也就更加规范化了。</p>
<p>6 隔离级别和产生的问题</p>
<ul>
<li>脏读：读取到了未提交的数据</li>
<li>不可重复读：前一次读取的数据和后一次读取的数据不一致<ul>
<li>注意是读，且是读同一个数据，两次读的数据不同，表示有<strong>别的事务对数据发生了修改</strong></li>
</ul>
</li>
<li>幻读：前一次读取的数据和后一次读取的数据不一致<ul>
<li>注意是读，但不是指同一个数据，比如查询一张表，查询结果为一条，将这条数据删除，再次查询结果查询结果应该是0，但是由于在删除后其它事务插入了数据导致表中还是有数据，这就是幻读，读到了预取之外的数据，即<strong>其它事务的插入和删除</strong>导致的</li>
</ul>
</li>
</ul>
<p><img src="/2022/01/26/C++/C++interview/image-20230321194637445.png" alt="image-20230321194637445"></p>
<pre><code>读未提交：read uncommitted（最低的隔离级别）《没有提交就读到了》
        什么是读未提交？
            事务A可以读取到事务B未提交的数据。
        这种隔离级别存在的问题就是：
            脏读现象！(Dirty Read)
            我们称读到了脏数据。
        这种隔离级别一般都是理论上的，大多数的数据库隔离级别都是二档起步！
读已提交：read committed《提交之后才能读到》
    什么是读已提交？
        事务A只能读取到事务B提交之后的数据。
    这种隔离级别解决了什么问题？
        解决了脏读的现象。
    这种隔离级别存在什么问题？
        不可重复读取数据。
        什么是不可重复读取数据呢？
            在事务开启之后，第一次读到的数据是3条，当前事务还没有
            结束，可能第二次再读取的时候，读到的数据是4条，3不等于4
            称为不可重复读取。

    这种隔离级别是比较真实的数据，每一次读到的数据是绝对的真实。
    oracle数据库默认的隔离级别是：read committed

可重复读：repeatable read《提交之后也读不到，永远读取的都是刚开启事务时的数据》
    什么是可重复读取？
        事务A开启之后，不管是多久，每一次在事务A中读取到的数据
        都是一致的。即使事务B将数据已经修改，并且提交了，事务A
        读取到的数据还是没有发生改变，这就是可重复读。
    可重复读解决了什么问题？
        解决了不可重复读取数据。
    可重复读存在的问题是什么？
        可以会出现幻影读。
        每一次读取到的数据都是幻象。不够真实！

    早晨9点开始开启了事务，只要事务不结束，到晚上9点，读到的数据还是那样！
    读到的是假象。不够绝对的真实。

    mysql中默认的事务隔离级别就是这个！！！！！！！！！！！

序列化/串行化：serializable（最高的隔离级别）
    这是最高隔离级别，效率最低。解决了所有的问题。
    这种隔离级别表示事务排队，不能并发！
    synchronized，线程同步（事务同步）
    每一次读取到的数据都是最真实的，并且效率是最低的。</code></pre><p><strong>非关系型数据库的优势是什么</strong></p>
<p>非关系型数据库相对于传统的关系型数据库有以下优势：</p>
<ol>
<li>高可扩展性：非关系型数据库采用分布式的数据存储方式，支持数据的水平扩展，可方便地扩展系统性能和存储容量。</li>
<li>高性能：非关系型数据库通常采用内存计算和缓存技术等，能够快速地处理海量数据，支持高并发的读写操作。</li>
<li>高灵活性：非关系型数据库通常采用动态模式，可以根据需求随时更改数据库结构，无需像关系型数据库那样需要预先定义好表结构。</li>
<li>适合大数据：非关系型数据库适合处理大数据、半结构化数据和非结构化数据，能够更好地满足互联网时代数据存储和处理的需求。</li>
<li>低成本：非关系型数据库通常使用开源软件实现，而且可以运行在廉价的硬件上，因此成本相对较低。</li>
</ol>
<p>总之，非关系型数据库在高可扩展性、高性能、高灵活性、适合大数据和低成本等方面具有优势，逐渐成为处理大数据和高并发场景的首选数据库。</p>
<p><strong>可以具体解释一下高可扩展性吗，传统关系型数据库也可以建立集群实现扩展啊</strong></p>
<p>是的，传统关系型数据库也可以建立集群实现扩展，但是相比非关系型数据库，它们的扩展性相对较低，主要表现在以下几个方面：</p>
<ol>
<li>数据模型的限制：关系型数据库需要提前设计好表结构，一旦数据结构发生变化，就需要修改表结构，这样就会涉及到大量的迁移和更新操作，而非关系型数据库不需要提前设计好表结构，可以动态添加和删除字段，具有更好的灵活性。</li>
<li>存储和查询效率的提升：非关系型数据库采用的是键值对的存储方式，相比于传统的表格存储方式，能够更快地存储和查询数据，尤其是在分布式系统中，可以通过分片技术将数据存储在不同的节点上，提高了读写性能和可扩展性。</li>
<li>数据分布的自动化：非关系型数据库在数据分布上更加自动化，不需要像关系型数据库一样手动将数据分布到不同的节点上，而是采用分片技术，自动将数据分布到不同的节点上，大大减少了管理和维护的工作量。</li>
</ol>
<p>综上所述，相比传统的关系型数据库，非关系型数据库具有更好的高可扩展性，更加适合大规模分布式系统。</p>
<p><strong>关系型数据在搭建集群的情况下，在连表查询时会需要跨机器连表吗</strong></p>
<p>在搭建集群的情况下，关系型数据库通常会进行数据分片，将不同的数据分配到不同的机器上存储，以达到横向扩展的目的。在这种情况下，如果一个查询需要跨多个数据分片才能完成，就需要在多个机器上执行这个查询，也就需要进行跨机器连接，这会给查询的效率带来很大的影响。</p>
<p>为了解决这个问题，一些关系型数据库会提供一些优化策略，比如将跨分片的查询拆分成多个子查询，在每个数据分片上执行子查询并将结果返回，然后在客户端将这些结果进行合并。这样虽然可以避免跨机器连接的问题，但是会带来更多的网络通信和计算开销。</p>
<p>总之，关系型数据库在搭建集群的情况下，连表查询可能会需要跨机器连接，但是一些优化策略可以帮助减轻这个问题带来的影响。</p>
<p><strong>非关系型数据库搭建集群的情况下存在跨分片的查询吗</strong></p>
<p>非关系型数据库搭建集群的情况下，存在跨分片查询的情况。因为非关系型数据库一般是将数据分散存储在多个节点上，每个节点存储不同的数据分片，当查询请求涉及到多个分片的数据时，就需要跨分片查询。</p>
<p>举个例子，如果将一个包含用户信息和订单信息的数据库分成两个分片分别存储，当要查询某个用户的订单信息时，就需要跨两个分片进行查询，即进行跨分片查询。这种情况下，非关系型数据库一般会将跨分片查询的操作交给协调节点来处理，协调节点负责将查询请求发送到涉及的多个分片节点，然后将查询结果汇总返回给客户端。</p>
<p><strong>非关系型数据库跨分片查询的效率相比关系型数据库哪个高</strong></p>
<p>通常情况下，非关系型数据库跨分片查询的效率要低于关系型数据库的跨机器查询。这是因为，在非关系型数据库中，数据通常是根据某种规则分散在不同的节点上的，而这些节点之间可能没有进行数据复制或同步，因此在进行跨分片查询时，需要将查询请求发送到多个节点上，将结果进行合并，再返回给客户端，这会增加查询的网络开销和延迟。</p>
<p>相比之下，关系型数据库在搭建集群时，通常会采用分布式数据库或共享存储等技术，将数据复制或同步到多个节点上，从而实现数据的高可用和分布式查询。虽然在进行跨机器查询时也会有一定的网络开销和延迟，但是相对于非关系型数据库而言，跨机器查询的效率会更高一些。</p>
<p><strong>Redis，Mongdb和MySQL的区别</strong></p>
<p>Redis、MongoDB和MySQL都是常见的数据库系统，它们有以下的区别：</p>
<ol>
<li>数据库类型：</li>
</ol>
<ul>
<li>Redis是一个基于内存的键值对数据库，主要用于缓存和高速数据读写操作。</li>
<li>MongoDB是一种文档数据库，支持面向文档的查询和数据存储。</li>
<li>MySQL是一个关系型数据库，支持使用SQL进行数据查询和存储。</li>
</ul>
<ol>
<li>数据模型：</li>
</ol>
<ul>
<li>Redis使用键值对模型存储数据，数据结构简单，适用于高速数据存储和访问。</li>
<li>MongoDB使用文档模型存储数据，文档是一种类似于JSON的格式，可以支持嵌套和复杂的数据结构。</li>
<li>MySQL使用表格模型存储数据，表格包含多个字段，可以通过SQL语句进行数据的操作和查询。</li>
</ul>
<ol>
<li>数据一致性：</li>
</ol>
<ul>
<li>Redis是一个支持主从复制和哨兵模式的高可用系统，但是不支持ACID事务。</li>
<li>MongoDB支持复制集和分片集群，可以提供高可用和容错性，支持ACID事务。</li>
<li>MySQL支持主从复制、主主复制和集群部署，也支持ACID事务。</li>
</ul>
<ol>
<li>查询语言：</li>
</ol>
<ul>
<li>Redis没有查询语言，主要通过键值对进行数据访问和操作。</li>
<li>MongoDB使用基于文档结构的查询语言，可以使用类似于SQL的查询语言，也支持Aggregation Pipeline进行复杂查询。</li>
<li>MySQL使用SQL语言进行查询和操作数据。</li>
</ul>
<ol>
<li>数据存储：</li>
</ol>
<ul>
<li>Redis将数据存储在内存中，可以支持高速读写和低延迟的访问。</li>
<li>MongoDB可以将数据存储在内存中或者磁盘中，可以根据需求进行配置。</li>
<li>MySQL将数据存储在磁盘中，需要进行磁盘I/O操作，相比Redis和MongoDB速度较慢。</li>
</ul>
<ol>
<li>应用场景：</li>
</ol>
<ul>
<li>Redis适用于高速缓存、队列、实时计数器、发布/订阅等场景。</li>
<li>MongoDB适用于需要灵活的文档数据模型，复杂查询和高性能读写的场景。</li>
<li>MySQL适用于需要高可用、安全、可扩展和支持ACID事务的关系型数据库场景。</li>
</ul>
<p><strong>mongodb也支持acid吗</strong></p>
<p>MongoDB不完全支持ACID，而是提供了一种称为“原子性写入”的操作。它保证单个文档在写入时是原子性的，即要么成功写入，要么没有写入。但是，MongoDB不支持跨文档或跨集合的事务，因此不完全符合ACID标准。相反，MongoDB更适合于大量的读写操作，对数据的一致性要求不是非常高的应用场景，如社交媒体、博客、物联网等应用。</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p><strong>定义</strong></p>
<p>单例模式，属于创建类型的一种常用的软件设计模式。通过单例模式的方法创建的类在当前进程中只有一个实例。</p>
<p><strong>应用场景</strong></p>
<p>对资源的统一的访问</p>
<p>配置管理</p>
<p>日志记录</p>
<p>线程池</p>
<p>连接池</p>
<p>内存池</p>
<p>对象池</p>
<p>消息队列</p>
<p><strong>实现步骤</strong></p>
<p>将类的构造方法定义为私有方法</p>
<p>定义一个私有的类的静态实例</p>
<p>提供一个公有的获取实例的静态方法</p>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><blockquote>
<p><a href="https://segmentfault.com/a/1190000039147687?sort=votes" target="_blank" rel="noopener">detach使用注意事项</a></p>
<p><a href="https://blog.csdn.net/KingOfMyHeart/article/details/96492417" target="_blank" rel="noopener">detach使用注意事项</a></p>
</blockquote>
<p><strong>多线程使用join回收方案</strong></p>
<ul>
<li>在主线程中join回收子线程的返回值，会导致阻塞</li>
<li>另外开一个单独的线程负责回收其它子线程的返回值</li>
</ul>
<p><strong>多线程和多进程的选择</strong></p>
<ul>
<li>nginx采用多进程</li>
<li>redis采用多线程</li>
<li>互相之际通信小则可用采用多进程，互相之间通信大则采用多线程</li>
</ul>
<h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p><strong>池技术解决的问题</strong></p>
<ul>
<li>减少资源频繁的创建和销毁的开销</li>
<li>异步解耦<ul>
<li>任务的构建是快速的，构建完就直接加入任务队列，不用阻塞等待任务完成，这样主线程就可以处理更多的任务</li>
<li>具体的任务可能需要进行I/O等耗时操作，则交给专门的任务线程处理</li>
<li>这样就实现了异步解耦</li>
</ul>
</li>
</ul>
<p><strong>使用场景</strong></p>
<ul>
<li>日志<ul>
<li>nlog(“日志内容”)  这个函数的本质是将这个任务发布，因为日志是要写到磁盘的，内存和磁盘读写速度不一样，这个函数如果直接写入磁盘就会阻塞，所以只是将这个任务加入任务队列，由专门的消费者线程将日志内容再一一写入磁盘</li>
</ul>
</li>
<li>业务解析<ul>
<li>面对大量的网络请求先将数据获取并加入任务队列，由专门的消费者线程再对数据进行解析</li>
<li>如果发送过来的数据只用http解析则不用线程池，如果需要操作数据库，需要缓存等则需要线程池进行异步解耦</li>
</ul>
</li>
</ul>
<p><strong>线程数量设置</strong></p>
<ul>
<li><p>I/O密集型： cpu*2  (I/O等待时间+cpu执行时间)x核心数/cpu执行时间</p>
</li>
<li><p>计算密集型： cpu+1</p>
</li>
</ul>
<p><strong>线程池组成</strong></p>
<ul>
<li>任务队列</li>
<li>执行队列（消费者线程）</li>
<li>管理者（控制线程的增加和缩减）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">JOB</span>&#123;</span></span><br><span class="line">    <span class="keyword">void</span> (*function) (<span class="keyword">void</span> *args);</span><br><span class="line">    <span class="keyword">void</span> *args;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">JOB</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">JOB</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">WORKER</span>&#123;</span></span><br><span class="line">    <span class="keyword">pthread_t</span> thread; <span class="comment">// 线程id</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">WORKER</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">WORKER</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MANAGER</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">JOB</span> *<span class="title">jobs</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">WORKER</span> *<span class="title">workers</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> mutex; <span class="comment">// 互斥锁</span></span><br><span class="line">    <span class="keyword">pthread_cond_t</span> con;<span class="comment">// 条件变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/01/26/C++/C++interview/image-20230322101245842.png" alt="image-20230322101245842"></p>
<p><img src="/2022/01/26/C++/C++interview/image-20230322101607489.png" alt="image-20230322101607489"></p>
<p><img src="/2022/01/26/C++/C++interview/image-20230322102117770.png" alt="image-20230322102117770"></p>
<h1 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h1><h2 id="c-1"><a href="#c-1" class="headerlink" title="c++"></a>c++</h2><h4 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h4><blockquote>
<p><a href="https://blog.csdn.net/solstice/article/details/8547547" target="_blank" rel="noopener">https://blog.csdn.net/solstice/article/details/8547547</a></p>
</blockquote>
<p>内部实现</p>
<p>线程安全</p>
<p>unique_ptr 阻止拷贝是编译阶段，通过delete拷贝构造函数实现，但是移动拷贝没有delete, 所以通过move是可以赋值的</p>
<h4 id="vector存储对象"><a href="#vector存储对象" class="headerlink" title="vector存储对象"></a>vector存储对象</h4><blockquote>
<p><a href="https://blog.csdn.net/Think88666/article/details/89408890" target="_blank" rel="noopener">https://blog.csdn.net/Think88666/article/details/89408890</a></p>
<p><a href="https://blog.csdn.net/weixin_42322256/article/details/125068306" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42322256/article/details/125068306</a></p>
</blockquote>
<p>vector存储对象扩容时，也是完全拷贝对象，push_back和emplace_back对比</p>
<p>c++11 push_back() 也开始支持移动拷贝</p>
<h4 id="虚函数表和虚函数指针"><a href="#虚函数表和虚函数指针" class="headerlink" title="虚函数表和虚函数指针"></a>虚函数表和虚函数指针</h4><blockquote>
<p><a href="https://blog.csdn.net/qq_43142509/article/details/126365313" target="_blank" rel="noopener">https://blog.csdn.net/qq_43142509/article/details/126365313</a></p>
<p><a href="https://www.nowcoder.com/discuss/415213368640909312?sourceSSR=users" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/415213368640909312?sourceSSR=users</a></p>
</blockquote>
<p>虚函数表创建时刻</p>
<p>虚函数指针创建时刻</p>
<p>虚函数表属于类还是实例</p>
<h4 id="placement-new"><a href="#placement-new" class="headerlink" title="placement new"></a>placement new</h4><blockquote>
<p><a href>侯捷内存管理1-12</a></p>
<p>placement: 安置</p>
<p>只要是带小括号的用法都是placement new ： new(ptr)</p>
<p>系统自带的是传入指针的用法，即已经开辟了空间，并用指针ptr指向这个空间，则可以通过new(ptr) Foo(1, 2)来在已经开辟空间的地址上调用构造函数</p>
<p>placement new本质上是对 operator new的重载，添加了第二参数或更多参数</p>
</blockquote>
<p><strong>题目</strong> 阿里二面</p>
<p>vector先开辟空间，然后再调用构造函数初始化</p>
<ul>
<li>new底层是默认的operator new，只有第一个默认参数</li>
<li>new()底层是对operator new重载了，添加了第二参数，第一参数默认是对象的大小</li>
<li>placement new构造起来的对象数组，要显式的调用他们的析构函数来销毁（析构函数并不释放对象的内存），千万不要使用delete，这是因为placement new构造起来的对象或数组大小并不一定等于原来分配的内存大小，使用delete会造成内存泄漏或者之后释放内存时出现运行时错误。<ul>
<li>如果确定构造的对象就是开辟的大小，则可以直接delete</li>
</ul>
</li>
</ul>
<p><img src="/2022/01/26/C++/C++interview/image-20230420205210767.png" alt="image-20230420205210767"></p>
<p><img src="/2022/01/26/C++/C++interview/image-20230420205013208.png" alt="image-20230420205013208"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> id;</span><br><span class="line">  A():id(<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"default ctor.this: "</span>&lt;&lt;<span class="keyword">this</span>&lt;&lt;<span class="string">" id="</span>&lt;&lt;id&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  A(<span class="keyword">int</span> id):id(id)&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"ctor.this: "</span>&lt;&lt;<span class="keyword">this</span>&lt;&lt;<span class="string">" id="</span>&lt;&lt;id&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  A&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> A&amp; other)&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"operator=().this: "</span>&lt;&lt;<span class="keyword">this</span>&lt;&lt;<span class="string">" id="</span>&lt;&lt;id&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    id = other.id;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ~A()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"dtor.this: "</span>&lt;&lt;<span class="keyword">this</span>&lt;&lt;<span class="string">" id="</span>&lt;&lt;id&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// g++ -o place placement_new.cpp </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">size</span> = <span class="number">3</span>;</span><br><span class="line">  A* buf = <span class="keyword">new</span> A[<span class="built_in">size</span>];</span><br><span class="line"></span><br><span class="line">  A* tmp = buf;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"buf="</span>&lt;&lt;buf&lt;&lt;<span class="string">" tmp="</span>&lt;&lt;tmp&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="built_in">size</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">new</span>(tmp) A(i);</span><br><span class="line">    tmp++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"buf="</span>&lt;&lt;buf&lt;&lt;<span class="string">" tmp="</span>&lt;&lt;tmp&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span>[] buf;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印</span></span><br><span class="line"><span class="keyword">default</span> ctor.<span class="keyword">this</span>: <span class="number">0x55c8c80f5e78</span> id=<span class="number">0</span></span><br><span class="line"><span class="keyword">default</span> ctor.<span class="keyword">this</span>: <span class="number">0x55c8c80f5e7c</span> id=<span class="number">0</span></span><br><span class="line"><span class="keyword">default</span> ctor.<span class="keyword">this</span>: <span class="number">0x55c8c80f5e80</span> id=<span class="number">0</span></span><br><span class="line">buf=<span class="number">0x55c8c80f5e78</span> tmp=<span class="number">0x55c8c80f5e78</span></span><br><span class="line">ctor.<span class="keyword">this</span>: <span class="number">0x55c8c80f5e78</span> id=<span class="number">0</span></span><br><span class="line">ctor.<span class="keyword">this</span>: <span class="number">0x55c8c80f5e7c</span> id=<span class="number">1</span></span><br><span class="line">ctor.<span class="keyword">this</span>: <span class="number">0x55c8c80f5e80</span> id=<span class="number">2</span></span><br><span class="line">buf=<span class="number">0x55c8c80f5e78</span> tmp=<span class="number">0x55c8c80f5e84</span></span><br><span class="line">dtor.<span class="keyword">this</span>: <span class="number">0x55c8c80f5e80</span> id=<span class="number">2</span></span><br><span class="line">dtor.<span class="keyword">this</span>: <span class="number">0x55c8c80f5e7c</span> id=<span class="number">1</span></span><br><span class="line">dtor.<span class="keyword">this</span>: <span class="number">0x55c8c80f5e78</span> id=<span class="number">0</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// new()  结合vector用法</span></span><br><span class="line"><span class="keyword">int</span> main()&#123;</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">size</span> = <span class="number">3</span>;</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;A&gt; <span class="title">vec</span><span class="params">(<span class="built_in">size</span>)</span></span>; <span class="comment">// 调用3次默认构造函数    vector会自动调用每个对象的析构函数</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">new</span>(&amp;vec[i]) A(i); <span class="comment">// 调用有参构造函数</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印</span></span><br><span class="line"><span class="keyword">default</span> ctor.<span class="keyword">this</span>: <span class="number">0x55f6ac63ee70</span> id=<span class="number">0</span></span><br><span class="line"><span class="keyword">default</span> ctor.<span class="keyword">this</span>: <span class="number">0x55f6ac63ee74</span> id=<span class="number">0</span></span><br><span class="line"><span class="keyword">default</span> ctor.<span class="keyword">this</span>: <span class="number">0x55f6ac63ee78</span> id=<span class="number">0</span></span><br><span class="line">ctor.<span class="keyword">this</span>: <span class="number">0x55f6ac63ee70</span> id=<span class="number">0</span></span><br><span class="line">ctor.<span class="keyword">this</span>: <span class="number">0x55f6ac63ee74</span> id=<span class="number">1</span></span><br><span class="line">ctor.<span class="keyword">this</span>: <span class="number">0x55f6ac63ee78</span> id=<span class="number">2</span></span><br><span class="line">dtor.<span class="keyword">this</span>: <span class="number">0x55f6ac63ee70</span> id=<span class="number">0</span></span><br><span class="line">dtor.<span class="keyword">this</span>: <span class="number">0x55f6ac63ee74</span> id=<span class="number">1</span></span><br><span class="line">dtor.<span class="keyword">this</span>: <span class="number">0x55f6ac63ee78</span> id=<span class="number">2</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 相对与new()的方式，会多一次临时对象的创建和销毁，还会多一次等值拷贝构造，但是会少一次有参构造</span></span><br><span class="line"><span class="comment">// 相对来说性能是更差的</span></span><br><span class="line"><span class="keyword">int</span> main()&#123;</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">size</span> = <span class="number">3</span>;</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;A&gt; <span class="title">vec</span><span class="params">(<span class="built_in">size</span>)</span></span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++)&#123;</span><br><span class="line">    vec[i] = A(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印</span></span><br><span class="line"><span class="keyword">default</span> ctor.<span class="keyword">this</span>: <span class="number">0x5563d7c09e70</span> id=<span class="number">0</span></span><br><span class="line"><span class="keyword">default</span> ctor.<span class="keyword">this</span>: <span class="number">0x5563d7c09e74</span> id=<span class="number">0</span></span><br><span class="line"><span class="keyword">default</span> ctor.<span class="keyword">this</span>: <span class="number">0x5563d7c09e78</span> id=<span class="number">0</span></span><br><span class="line">ctor.<span class="keyword">this</span>: <span class="number">0x7ffebb7eb044</span> id=<span class="number">0</span></span><br><span class="line"><span class="keyword">operator</span>=().<span class="keyword">this</span>: <span class="number">0x5563d7c09e70</span> id=<span class="number">0</span></span><br><span class="line">dtor.<span class="keyword">this</span>: <span class="number">0x7ffebb7eb044</span> id=<span class="number">0</span></span><br><span class="line">ctor.<span class="keyword">this</span>: <span class="number">0x7ffebb7eb044</span> id=<span class="number">1</span></span><br><span class="line"><span class="keyword">operator</span>=().<span class="keyword">this</span>: <span class="number">0x5563d7c09e74</span> id=<span class="number">0</span></span><br><span class="line">dtor.<span class="keyword">this</span>: <span class="number">0x7ffebb7eb044</span> id=<span class="number">1</span></span><br><span class="line">ctor.<span class="keyword">this</span>: <span class="number">0x7ffebb7eb044</span> id=<span class="number">2</span></span><br><span class="line"><span class="keyword">operator</span>=().<span class="keyword">this</span>: <span class="number">0x5563d7c09e78</span> id=<span class="number">0</span></span><br><span class="line">dtor.<span class="keyword">this</span>: <span class="number">0x7ffebb7eb044</span> id=<span class="number">2</span></span><br><span class="line">dtor.<span class="keyword">this</span>: <span class="number">0x5563d7c09e70</span> id=<span class="number">0</span></span><br><span class="line">dtor.<span class="keyword">this</span>: <span class="number">0x5563d7c09e74</span> id=<span class="number">1</span></span><br><span class="line">dtor.<span class="keyword">this</span>: <span class="number">0x5563d7c09e78</span> id=<span class="number">2</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ADT</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	ADT()&#123;</span><br><span class="line">		i = <span class="number">10</span>;</span><br><span class="line">		j = <span class="number">100</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"ADT construct i="</span> &lt;&lt; i &lt;&lt; <span class="string">"j="</span>&lt;&lt;j &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	~ADT()&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"ADT destruct"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *p = <span class="keyword">new</span>(nothrow) <span class="keyword">char</span>[<span class="keyword">sizeof</span>(ADT) + <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"alloc failed"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ADT *q = <span class="keyword">new</span>(p) ADT;  <span class="comment">//placement new:不必担心失败，只要p所指对象的的空间足够ADT创建即可</span></span><br><span class="line">	<span class="comment">//delete q;//错误!不能在此处调用delete q;</span></span><br><span class="line">  q-&gt;~ADT();<span class="comment">//显示调用析构函数</span></span><br><span class="line">	<span class="comment">// q-&gt;ADT::~ADT();//显示调用析构函数</span></span><br><span class="line">	<span class="keyword">delete</span>[] p;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="delete-与-delete"><a href="#delete-与-delete" class="headerlink" title="delete[] 与 delete"></a>delete[] 与 delete</h4><ul>
<li><p>delete this会发生什么</p>
<ul>
<li>在析构函数中调用会一直循环递归调用<ul>
<li>delete会先调用析构函数，然后再释放内存</li>
</ul>
</li>
</ul>
</li>
<li><p>在普通函数中调用会释放内存，函数后续不能再访问成员变量和this，因为内存已经释放</p>
<ul>
<li>delete this 一定要和new 出来的对象配合使用<ul>
<li>关于如何保证一个对象只能动态创建(new)<ul>
<li>析构函数设置为保护(可继承)或私有(不可继承)</li>
<li>需要额外定义释放内存的函数destory(), 在这个函数中可以delete this来释放对象内存</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>delete可以delete NULL、nullptr  不会报错</p>
</li>
<li><p>delete会干两件事</p>
<ul>
<li>调用一次析构函数</li>
<li>释放开辟的空间</li>
</ul>
</li>
<li><p>delete[] 会干两件事</p>
<ul>
<li>调用多次析构函数，即调用数组中每个对象的析构函数</li>
<li>释放开辟的空间</li>
</ul>
</li>
<li><p>new T[]   但调用delete可能出错</p>
<ul>
<li>如果T是基本数据类型，即开辟的空间没有指针指向其它地方，直接delete可以正常释放开辟的空间</li>
<li>如果T是对象，因为对象中可能也开辟了堆数据，用指针指向，需要在析构函数中释放指针指向的空间，如果调用的是delete则只会调用一次析构函数，则有些对象的析构函数没有调用，对象中开辟的堆数据就没有在析构函数中释放，则会导致内存泄漏<ul>
<li>如果对象中没有开辟对数据指向其它地方，只调用delete，理论上也是可以释放空间，不会导致内存泄漏的，但是如果对象有析构函数，这种写法仍然会执行报错，<ul>
<li>对象中没有开辟堆数据，且没有写析构函数，则使用delete是可以成功执行的，且不会有内存泄漏</li>
<li>对象中没有开辟堆数据，但有写析构函数，则使用delete，执行会报错<ul>
<li>写了析构函数，在开辟的空间中会标注需要析构的次数，如果使用delete只调用一次析构，和之前标注的次数不一致，则会导致报错</li>
</ul>
</li>
</ul>
</li>
<li>对象中有开辟堆数据<ul>
<li>对象中有开辟堆数据，且没有写析构函数，则使用delete是可以成功执行的，但会导致内存泄漏</li>
<li>对象中有开辟堆数据，且有写析构函数，则使用delete，执行会报错</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有析构函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span> <span class="comment">// 没有指针，没有开辟新的内存，只是一个简单的类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  A():a(<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"A create"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ~A()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"A delete"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span>* pi;</span><br><span class="line">  B()&#123;</span><br><span class="line">    pi = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"B create"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ~B()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"B delete"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span> pi;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  A* p = <span class="keyword">new</span> A[<span class="number">3</span>];</span><br><span class="line">  <span class="comment">// delete p; // 执行报错</span></span><br><span class="line">  <span class="keyword">delete</span>[] p;</span><br><span class="line"></span><br><span class="line">  B* p2 = <span class="keyword">new</span> B[<span class="number">3</span>];</span><br><span class="line">  <span class="comment">// delete p2; // 执行报错</span></span><br><span class="line">  <span class="keyword">delete</span>[] p2;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span>* p3 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">  <span class="comment">// delete p3; // 执行成功</span></span><br><span class="line">  <span class="keyword">delete</span>[] p3; <span class="comment">// 执行成功</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有析构函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span> <span class="comment">// 没有指针，没有开辟新的内存，只是一个简单的类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  A():a(<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"A create"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ~A()&#123;</span></span><br><span class="line">  <span class="comment">//   cout&lt;&lt;"A delete"&lt;&lt;endl;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span>* pi;</span><br><span class="line">  B()&#123;</span><br><span class="line">    pi = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"B create"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ~B()&#123;</span></span><br><span class="line">  <span class="comment">//   cout&lt;&lt;"B delete"&lt;&lt;endl;</span></span><br><span class="line">  <span class="comment">//   delete pi;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Test1* t = <span class="keyword">new</span> Test1(<span class="number">10</span>);</span><br><span class="line">  <span class="comment">// t = nullptr;</span></span><br><span class="line">  t = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">delete</span> t; <span class="comment">//可以正常delete</span></span><br><span class="line">  </span><br><span class="line">  A* p = <span class="keyword">new</span> A[<span class="number">3</span>];</span><br><span class="line">  <span class="keyword">delete</span> p; <span class="comment">// 执行通过，不会导致内存泄漏</span></span><br><span class="line">  <span class="comment">// delete[] p;</span></span><br><span class="line"></span><br><span class="line">  B* p2 = <span class="keyword">new</span> B[<span class="number">3</span>];</span><br><span class="line">  <span class="keyword">delete</span> p2; <span class="comment">// 执行通过，但是会导致内存泄漏   因为b中开辟了堆数据</span></span><br><span class="line">  <span class="comment">// delete[] p2;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span>* p3 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">  <span class="comment">// delete p3; // 执行成功</span></span><br><span class="line">  <span class="keyword">delete</span>[] p3; <span class="comment">// 执行成功</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="shared-ptr与析构"><a href="#shared-ptr与析构" class="headerlink" title="shared_ptr与析构"></a>shared_ptr与析构</h4><ul>
<li>父类的析构函数没有定义为虚析构，多态情况下如何在析构的时候可以调用对应的子类的析构函数</li>
<li>shared_ptr默认就可以做到</li>
<li>父类指针只能调用虚函数，子类的非虚函数不能调用</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span>* m_i;</span><br><span class="line">    Base(<span class="keyword">int</span> i) :m_i(<span class="keyword">new</span> <span class="keyword">int</span>(i)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Base()</span><br><span class="line">    <span class="comment">// virtual ~Base()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"~Base"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">delete</span> m_i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span>* m_j;</span><br><span class="line">    Child(<span class="keyword">int</span> i, <span class="keyword">int</span> j) :Base(i), m_j(<span class="keyword">new</span> <span class="keyword">int</span>(j)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Child"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"fun"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Child()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"~Child"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">delete</span> m_j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base *p = <span class="keyword">new</span> Child(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    p-&gt;<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Child</span></span><br><span class="line">    <span class="comment">// ~Base</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;Base&gt; <span class="title">p0</span><span class="params">(<span class="keyword">new</span> Child(<span class="number">1</span>, <span class="number">2</span>), [](Base* p) &#123;<span class="keyword">delete</span> p; &#125;)</span></span>;</span><br><span class="line">    p0-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Child</span></span><br><span class="line">    <span class="comment">// ~Base</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;Base&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> Child(<span class="number">1</span>, <span class="number">2</span>), [](Child* p) &#123;<span class="keyword">delete</span> p; &#125;)</span></span>;</span><br><span class="line">    p1-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Child</span></span><br><span class="line">    <span class="comment">// ~Child</span></span><br><span class="line">    <span class="comment">// ~Base</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;Base&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> Child(<span class="number">1</span>, <span class="number">2</span>))</span></span>;   <span class="comment">// 默认析构的就是p1的lambda表达式的情况</span></span><br><span class="line">    p2-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Child</span></span><br><span class="line">    <span class="comment">// ~Child</span></span><br><span class="line">    <span class="comment">// ~Base</span></span><br><span class="line">    </span><br><span class="line">    Base* b = <span class="keyword">new</span> Child(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    b-&gt;<span class="built_in">print</span>();</span><br><span class="line">    b-&gt;fun(); <span class="comment">// 报错 父类指针只能调用虚函数，子类的非虚函数不能调用</span></span><br><span class="line">    b-&gt;~Child(); <span class="comment">// 报错 父类指针只能调用虚函数，子类的非虚函数不能调用</span></span><br><span class="line">    </span><br><span class="line">    Child* b1 = <span class="keyword">new</span> Child(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    b1-&gt;<span class="built_in">print</span>();</span><br><span class="line">    b1-&gt;fun(); </span><br><span class="line">    b1-&gt;~Child(); <span class="comment">// 析构函数是可以自己调用的，构造函数不能</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="智能指针的使用场景"><a href="#智能指针的使用场景" class="headerlink" title="智能指针的使用场景"></a>智能指针的使用场景</h4><p><strong>shared_ptr</strong></p>
<ul>
<li>多线程场景，引用计数，实现对资源的统一访问</li>
<li>在容器中存储动态分配的对象：<code>shared_ptr</code> 可以用于容器，以便容器中的多个元素可以共享动态分配的资源，并在不再需要时自动释放。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt;&gt; vec;</span><br><span class="line">vec.push_back(<span class="built_in">std</span>::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>));</span><br><span class="line">vec.push_back(<span class="built_in">std</span>::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>));</span><br><span class="line"><span class="comment">// 当 vector 销毁时，它会自动释放所有元素的资源</span></span><br></pre></td></tr></table></figure>

<ul>
<li>避免悬挂指针：当你需要传递指针给多个函数或对象，但不想手动管理内存释放，<code>shared_ptr</code> 可以确保在所有引用结束时自动释放资源</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; ptr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"><span class="built_in">process</span>(p); <span class="comment">// 在 process 函数结束后，p 仍然有效</span></span><br></pre></td></tr></table></figure>



<p><strong>unique_ptr</strong></p>
<ul>
<li>独占式</li>
<li>文件管理</li>
<li>资源管理</li>
<li>数据库链接管理</li>
</ul>
<h4 id="多态指针转型"><a href="#多态指针转型" class="headerlink" title="多态指针转型"></a>多态指针转型</h4><blockquote>
<p><a href="https://blog.csdn.net/weixin_44997886/article/details/104610140" target="_blank" rel="noopener">向上转型（子类指针赋值给父类指针）</a></p>
<p><a href="https://blog.csdn.net/liranke/article/details/5145787" target="_blank" rel="noopener">dynamic_cast</a></p>
</blockquote>
<p>指针的转型</p>
<ul>
<li>转型变化的是指针指向的内存的范围变化，没有涉及到重新构建内存</li>
</ul>
<p>dynamic_cast</p>
<ul>
<li><p>虚继承时，向下转型必须使用dynamic_cast</p>
</li>
<li><p>非虚继承时，可以直接通过(子类*)强制转换</p>
</li>
<li><p>先用父类指针构造子类，再将父类指针向下转型为子类指针，子类指针可以正常使用，这就是shared_ptr可以解决父类析构函数没有定义为虚函数的原因</p>
<ul>
<li><p>但是先用父类指针构造父类，再将父类指针向下转型为子类指针</p>
<ul>
<li><p>若不是虚继承</p>
<ul>
<li>使用dynamic_cast转型直接报错</li>
<li>使用(子类*)强制转换，可以正常转换，但是可能存在子类独有的内存未初始化的情况，可能执行报错</li>
</ul>
</li>
<li><p>若是虚继承</p>
<ul>
<li>使用dynamic_cast转型直接报错</li>
<li>(子类*)强制转换，不可用，编译提示错误</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span>* m_i;</span><br><span class="line">    Base(<span class="keyword">int</span> i) :m_i(<span class="keyword">new</span> <span class="keyword">int</span>(i)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Base()</span><br><span class="line">    <span class="comment">// virtual ~Base()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"~Base"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">delete</span> m_i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class Child : virtual public Base // 虚继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span>* m_j;</span><br><span class="line">    Child(<span class="keyword">int</span> i, <span class="keyword">int</span> j) :Base(i), m_j(<span class="keyword">new</span> <span class="keyword">int</span>(j)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Child"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;<span class="string">"self: "</span>&lt;&lt;<span class="keyword">this</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"fun"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Child()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"~Child"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">delete</span> m_j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Child* a = <span class="keyword">new</span> Child(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">  a-&gt;<span class="built_in">print</span>();</span><br><span class="line">  a-&gt;fun();</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"a: "</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  Base* b = a;</span><br><span class="line">  b-&gt;<span class="built_in">print</span>();</span><br><span class="line">  <span class="comment">// b-&gt;fun(); // error</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"b: "</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  Child* c = <span class="keyword">dynamic_cast</span>&lt;Child*&gt;(b);</span><br><span class="line">  <span class="comment">// Child* c = (Child*)b;  // 虚继承时这种写法不对，只能用dynamic_cast方式， 不是虚继承时可以这样转化</span></span><br><span class="line">  c-&gt;<span class="built_in">print</span>();</span><br><span class="line">  c-&gt;fun();</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"c: "</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="comment">// delete a;  // 结果同b  但Child的析构函数会被调用</span></span><br><span class="line">  <span class="keyword">delete</span> b;</span><br><span class="line">  <span class="comment">// delete c; // 结果同b  但Child的析构函数会被调用</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印</span></span><br><span class="line">Child</span><br><span class="line">self: <span class="number">0x55d576a7fe70</span></span><br><span class="line">fun</span><br><span class="line">a: <span class="number">0x55d576a7fe70</span></span><br><span class="line">Child</span><br><span class="line">b: <span class="number">0x55d576a7fe70</span></span><br><span class="line">Child</span><br><span class="line">self: <span class="number">0x55d576a7fe70</span></span><br><span class="line">fun</span><br><span class="line">c: <span class="number">0x55d576a7fe70</span></span><br><span class="line">~Base</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Base* b = <span class="keyword">new</span> Base(<span class="number">1</span>);</span><br><span class="line">  b-&gt;<span class="built_in">print</span>();</span><br><span class="line">  <span class="comment">// b-&gt;fun(); // error</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"b: "</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  Child* c = <span class="keyword">dynamic_cast</span>&lt;Child*&gt;(b);</span><br><span class="line">  <span class="comment">// Child* c = (Child*)b;  // 虚继承时这种写法不对，只能用dynamic_cast方式， 不是虚继承时可以这样转化</span></span><br><span class="line">  c-&gt;<span class="built_in">print</span>();</span><br><span class="line">  c-&gt;fun();</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"c: "</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">delete</span> c; <span class="comment">// 结果同b  但Child的析构函数会被调用</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印</span></span><br><span class="line">Base</span><br><span class="line">b: <span class="number">0x564de3d9ee70</span></span><br><span class="line"><span class="function">Segmentation <span class="title">fault</span> <span class="params">(core dumped)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// dynamic_cast 向下转型比static_cast更安全，因为转成不成功返回的是nullptr, 而使用static_cast转型不成功没有返回nullptr，不便于判断，使用易错   </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Base* b = <span class="keyword">new</span> Base(<span class="number">1</span>);</span><br><span class="line">  b-&gt;<span class="built_in">print</span>();</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"b: "</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  Child* c = <span class="keyword">dynamic_cast</span>&lt;Child*&gt;(b);</span><br><span class="line">  <span class="keyword">if</span>(c == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c is nullptr"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> b;</span><br><span class="line">  <span class="comment">// delete c; // 此时c == nullptr， 构造的b得不到释放，需要通过delete b来释放</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印</span></span><br><span class="line">Base</span><br><span class="line">b: <span class="number">0x55fe086f4e70</span></span><br><span class="line">c is <span class="literal">nullptr</span></span><br><span class="line">~Base</span><br></pre></td></tr></table></figure>

<h4 id="内存共享"><a href="#内存共享" class="headerlink" title="内存共享"></a>内存共享</h4><blockquote>
<p>shm: <a href="https://blog.csdn.net/weixin_42483745/article/details/123781769" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42483745/article/details/123781769</a></p>
<p><a href="https://blog.csdn.net/m0_50662680/article/details/127734782" target="_blank" rel="noopener">https://blog.csdn.net/m0_50662680/article/details/127734782</a></p>
<p><a href="https://blog.csdn.net/Young_Bobooo/article/details/121975632" target="_blank" rel="noopener">https://blog.csdn.net/Young_Bobooo/article/details/121975632</a></p>
<p>mmap与shm的区别：<a href="https://blog.csdn.net/weixin_44233369/article/details/96431640" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44233369/article/details/96431640</a></p>
<p>1、mmap保存到实际硬盘，实际存储并没有反映到主存上。优点：储存量可以很大（多于主存），缺点：进程间读取和写入速度要比主存的要慢。<br>2、shm保存到物理存储器（主存），实际的储存量直接反映到主存上。优点，进程间访问速度（读写）比磁盘要快；缺点，储存量不能非常大（多于主存）</p>
</blockquote>
<h4 id="宏、const和static"><a href="#宏、const和static" class="headerlink" title="宏、const和static"></a>宏、const和static</h4><blockquote>
<p>const的使用:<a href="https://blog.csdn.net/qq_41902325/article/details/124274072" target="_blank" rel="noopener">https://blog.csdn.net/qq_41902325/article/details/124274072</a></p>
<p>const的使用<a href="https://blog.csdn.net/limengshi138392/article/details/122078477" target="_blank" rel="noopener">https://blog.csdn.net/limengshi138392/article/details/122078477</a></p>
<p>stati初始化时机：<a href="https://blog.csdn.net/qq_52809807/article/details/129783093" target="_blank" rel="noopener">https://blog.csdn.net/qq_52809807/article/details/129783093</a></p>
</blockquote>
<ul>
<li>宏要点<ul>
<li>预编译阶段</li>
<li>直接文本替换</li>
<li>没有类型检测</li>
</ul>
</li>
<li>const要点<ul>
<li>定义时必须初始化，之后无法更改</li>
<li>const成员变量<ul>
<li>只能通过构造函数初始化列表进行初始化，并且必须有构造函数</li>
<li>不同类对其const数据成员的值可以不同，所以不能在类中声明时初始化<ul>
<li>const变量是属于对象的，和static不同</li>
</ul>
</li>
</ul>
</li>
<li>const成员函数<ul>
<li>对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量<ul>
<li>本质是常函数的入参为 func(const Person * const this), this指向的数据是不可变的</li>
</ul>
</li>
<li>也就是不可以改变非mutable（用该关键字声明的变量可以在const成员函数中被修改）数据的值<ul>
<li>用mutable关键字声明的变量可以在const成员函数中被修改</li>
</ul>
</li>
</ul>
</li>
<li>const对象<ul>
<li>类的常对象只能访问类的常成员函数</li>
<li>本质是调用函数时，入参类型为 const Person* const this,  只能匹配上常函数的入参</li>
</ul>
</li>
<li>隐藏性<ul>
<li>const修饰变量是也与static有一样的隐藏作用。只能在该文件中使用，其他文件不可以引用声明使用。 因此在头文件中声明const变量是没问题的，因为即使被多个文件包含，链接性都是内部的，不会出现符号冲突。</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://blog.csdn.net/www_dong/article/details/116102066" target="_blank" rel="noopener">static要点</a><ul>
<li>初始化 <a href="https://blog.csdn.net/qq_34139994/article/details/105157313" target="_blank" rel="noopener">C++中static变量的初始化</a><ul>
<li>静态成员的数据存放在数据(data)区，未初始化的存储在(bss)区，编译的时候进行分配空间。</li>
<li>如果是在C语言中在编译的时候进行初始化。</li>
<li>如果是在C++中在对象第一次使用的时候进行初始化。<ul>
<li>编译时初始化<ul>
<li>基本数据类型，且是<strong>常量</strong></li>
</ul>
</li>
<li>加载时初始化<ul>
<li>发生在main函数之前</li>
<li>饿汉模式</li>
<li>静态变量是一个基本数据类型，但是初始值<strong>非常量</strong></li>
<li>静态变量是一个<strong>类对象</strong>，这种情况下即使是使用常量初始化，也是加载时初始化，而不是编译时初始化</li>
</ul>
</li>
<li>运行时初始化<ul>
<li>发生在变量第一次被引用 （<strong>函数内部局部变量</strong>）</li>
<li>懒汉模式</li>
</ul>
</li>
</ul>
</li>
<li>static初始化注意事项和原理（看原文）<ul>
<li>只初始化一次，以后给它赋值，赋值不会成功，仍然使用之前的值，只能通过自增减，或者加减乘除等来改变，反正就是不能通过赋值再给他赋其它值</li>
<li>原理是用变量后面的32位标记来存储是否已经初始化了</li>
</ul>
</li>
</ul>
</li>
<li>局部静态变量(函数内)<ul>
<li>静态变量在函数内定义，始终存在，且只进行一次初始化，具有记忆性，其作用范围与局部变量相同，函数退出后仍然存在，但不能使用</li>
</ul>
</li>
<li>静态函数(面向过程)<ul>
<li>只能当前文件使用，和静态对象一样有隐藏性</li>
<li>函数内部的非静态变量每次调用函数都是重新分配内存和初始化，也就是每次调用互相之间不影响</li>
<li>函数内部的静态变量只初始化一次，每次调用沿用的都是之前的数据</li>
</ul>
</li>
<li>static成员变量<ul>
<li>属于类，定义时要分配空间，不能在类声明中初始化，必须在类定义体外部初始化</li>
</ul>
</li>
<li>static成员函数<ul>
<li>属于类，没有this指针，只能访问static成员变量和static成员函数</li>
<li><strong>不能被声明为const、虚函数和volatile</strong>：  关键是没有this指针<ul>
<li>const是属于对象的，没有this指针是访问不到const的</li>
</ul>
</li>
<li><a href="https://blog.csdn.net/Dream_Weave/article/details/119808269" target="_blank" rel="noopener">线程安全问题</a><ul>
<li>static函数中有使用静态变量则需要加锁</li>
</ul>
</li>
</ul>
</li>
<li>static对象<ul>
<li><a href="https://blog.csdn.net/lizhichao410/article/details/124121253" target="_blank" rel="noopener">单例模式的应用</a></li>
<li>静态对象在使用上和正常对象一样，可以使用静态或非静态成员函数和变量，只是这个对象自己是静态的</li>
</ul>
</li>
<li>隐藏性<ul>
<li>static函数不能通过include static函数的.h文件在其它文件中使用，因为具有隐藏性</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  test(<span class="keyword">int</span> a):a(a)&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"test"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ~test()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"~test"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printb</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"printb"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"b = "</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"print"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"a = "</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"b = "</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> test::b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> test <span class="title">t</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"main start"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  test::printb();</span><br><span class="line">  t.<span class="built_in">print</span>();</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"main end"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印</span></span><br><span class="line">test</span><br><span class="line">main start</span><br><span class="line">printb</span><br><span class="line">b = <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">main <span class="built_in">end</span></span><br><span class="line">~test</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line">  a++;</span><br><span class="line">  b++;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This is a static function\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Func(); </span><br><span class="line">	Func(); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">This is a <span class="keyword">static</span> function</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">This is a <span class="keyword">static</span> function</span><br></pre></td></tr></table></figure>

<p><strong>只初始化一次</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> y = x; <span class="comment">// ---1--- y只被第一个x初始化，后面再不能赋值给y</span></span><br><span class="line">    <span class="comment">// y += x;        // ---2--- y可以通过非赋值的方式改变</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"x = "</span> &lt;&lt; x &lt;&lt; <span class="string">", y = "</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">5</span>; x &lt; <span class="number">10</span>; x++)</span><br><span class="line">    &#123;</span><br><span class="line">		func(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印</span></span><br><span class="line">x = <span class="number">5</span>, y = <span class="number">5</span></span><br><span class="line">x = <span class="number">6</span>, y = <span class="number">5</span></span><br><span class="line">x = <span class="number">7</span>, y = <span class="number">5</span></span><br><span class="line">x = <span class="number">8</span>, y = <span class="number">5</span></span><br><span class="line">x = <span class="number">9</span>, y = <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p><strong>隐藏性</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"test.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;get()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 编辑器不报错</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译报错</span></span><br><span class="line">wangyj@node1:~/learn$ g++ main.cpp test.cpp -o main</span><br><span class="line">In file included from main.cpp:<span class="number">18</span>:<span class="number">0</span>:</span><br><span class="line">test.h:2:12: warning: ‘int get()’ used but never defined</span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">            ^~~</span><br><span class="line">/tmp/ccOZJvKr.o: In function `main<span class="number">'</span>:</span><br><span class="line">main.cpp:(.<span class="built_in">text</span>+<span class="number">0x5</span>): undefined reference to `<span class="built_in">get</span>()'</span><br><span class="line">collect2: error: ld returned <span class="number">1</span> <span class="built_in">exit</span> status</span><br></pre></td></tr></table></figure>



<h4 id="STL内存分配"><a href="#STL内存分配" class="headerlink" title="STL内存分配"></a>STL内存分配</h4><ul>
<li>STL容器都是通过二级分配器分配内存的，也就是分配在堆上，通过内存池来管理</li>
<li>在栈区定义容器变量，变量本身存储在栈区，但是变量存储的数据在堆区</li>
<li>在堆空间定义的容器变量，变量本身存储在堆区，存储的数据也在堆区</li>
<li>两级空间配置器<ul>
<li>底层都是调用malloc</li>
<li>一级空间配置器处理大于128k的申请<ul>
<li>直接调用malloc</li>
</ul>
</li>
<li>二级空间配置器处理小于128k的申请<ul>
<li>内存池管理内存，16条链表，每条链表上挂20个，只有内存池中内存不够时才调用malloc再次申请内存</li>
</ul>
</li>
</ul>
</li>
<li>malloc<ul>
<li>大于128k, 在自由存储区申请内存，底层用mmap</li>
<li>小于128k，在堆区申请内存，底层用brk</li>
</ul>
</li>
</ul>
<h4 id="类如何只能静态分配和只能动态分配"><a href="#类如何只能静态分配和只能动态分配" class="headerlink" title="类如何只能静态分配和只能动态分配"></a>类如何只能静态分配和只能动态分配</h4><blockquote>
<p><a href="https://blog.csdn.net/weixin_42752274/article/details/126150079" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42752274/article/details/126150079</a></p>
</blockquote>
<ul>
<li>静态分配<ul>
<li>重载new， delete运算符，并设置为私有</li>
<li>或者将new, delete运算符=delete</li>
</ul>
</li>
<li>动态分配<ul>
<li>将析构函数设置为私有的（不能继承）或者是保护（可继承）<ul>
<li>编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性（其实不光是析构函数，只要是非静态的函数，编译器都会进行检查）。如果类的析构函数在类外部无法访问，则编译器拒绝在栈空间上为类对象分配内存。<strong>这样也就禁止了静态分配</strong></li>
</ul>
</li>
<li>由于将析构函数定义为私有，需要额外定义析构函数释放内存？？？</li>
</ul>
</li>
</ul>
<h4 id="单例模式-1"><a href="#单例模式-1" class="headerlink" title="单例模式"></a>单例模式</h4><blockquote>
<p>小林coding : <a href="https://www.cnblogs.com/xiaolincoding/p/11437231.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaolincoding/p/11437231.html</a></p>
</blockquote>
<ul>
<li>懒汉模式：线程不安全<ul>
<li>定义静态实例对象指针，每次获取需要加锁</li>
<li>定义局部静态实例对象，不用加锁，因为局部静态对象只会被初始化一次</li>
</ul>
</li>
<li>饿汉模式：线程安全</li>
</ul>
<h4 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h4><blockquote>
<p><a href="https://blog.csdn.net/qq_52905520/article/details/127178512" target="_blank" rel="noopener">https://blog.csdn.net/qq_52905520/article/details/127178512</a></p>
</blockquote>
<ul>
<li>常规</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	A(<span class="keyword">int</span> x1 = <span class="number">0</span>, <span class="keyword">int</span> y1 = <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		x = x1;</span><br><span class="line">		y = y1;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">friend</span> A <span class="keyword">operator</span>+(<span class="keyword">const</span> A&amp; a, <span class="keyword">const</span> A&amp; b);</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"x="</span> &lt;&lt; x &lt;&lt; <span class="string">","</span> &lt;&lt; <span class="string">"y="</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">A <span class="keyword">operator</span>+(<span class="keyword">const</span> A&amp; a, <span class="keyword">const</span> A&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> A(a.x + b.x, a.y + b.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	A(<span class="keyword">int</span> x1 = <span class="number">0</span>, <span class="keyword">int</span> y1 = <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		x = x1;</span><br><span class="line">		y = y1;</span><br><span class="line">	&#125;</span><br><span class="line">	A <span class="keyword">operator</span>+(<span class="keyword">const</span> A&amp; a)<span class="keyword">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		A t;</span><br><span class="line">		t.x = <span class="keyword">this</span>-&gt;x + a.x;</span><br><span class="line">		t.y = <span class="keyword">this</span>-&gt;y + a.y;</span><br><span class="line">		<span class="keyword">return</span> t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"x="</span> &lt;&lt; x &lt;&lt; <span class="string">","</span> &lt;&lt; <span class="string">"y="</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>自增<ul>
<li>用前置来写后置</li>
<li>参数有类型为后置</li>
<li>前置返回引用</li>
<li>后置返回对象</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	A(<span class="keyword">int</span> x1 = <span class="number">0</span>, <span class="keyword">int</span> y1 = <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		x = x1;</span><br><span class="line">		y = y1;</span><br><span class="line">	&#125;</span><br><span class="line">	A &amp;<span class="keyword">operator</span>++()<span class="comment">//++i 前置++实现</span></span><br><span class="line">	&#123;</span><br><span class="line">		++x;	<span class="comment">//先自增</span></span><br><span class="line">		++y;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;	<span class="comment">//后引用</span></span><br><span class="line">	&#125;</span><br><span class="line">	A <span class="keyword">operator</span>++(<span class="keyword">int</span>)	<span class="comment">//i++ 后置++实现</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//int参数没有任何意义，只是为了区分是前置还是后置形式</span></span><br><span class="line">		A a = *<span class="keyword">this</span>;	<span class="comment">//保存对象引用</span></span><br><span class="line">		++(*<span class="keyword">this</span>);	<span class="comment">//自增，调用前面实现的前置++</span></span><br><span class="line">		<span class="keyword">return</span> a;	<span class="comment">//返回先前保存的对象</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"x="</span> &lt;&lt; x &lt;&lt; <span class="string">","</span> &lt;&lt; <span class="string">"y="</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A a1(1, 2), a2(3, 4);</span><br><span class="line">	(a1++).show();</span><br><span class="line">	(++a2).show();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印</span></span><br><span class="line">x=<span class="number">1</span>,y=<span class="number">2</span></span><br><span class="line">x=<span class="number">4</span>,y=<span class="number">5</span></span><br></pre></td></tr></table></figure>

<ul>
<li>输入输出<ul>
<li>返回值为引用</li>
<li>输入需要输入输出类的引用</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	A(<span class="keyword">int</span> x1 = <span class="number">0</span>, <span class="keyword">int</span> y1 = <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		x = x1;</span><br><span class="line">		y = y1;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; is, A&amp; a);</span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="keyword">const</span> A&amp; a);</span><br><span class="line">&#125;;</span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; is, A&amp; a)</span><br><span class="line">&#123;</span><br><span class="line">	is &gt;&gt; a.x &gt;&gt; a.y;</span><br><span class="line">	<span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="keyword">const</span> A&amp; a)</span><br><span class="line">&#123;</span><br><span class="line">	os &lt;&lt; <span class="string">"x="</span> &lt;&lt; a.x &lt;&lt; <span class="string">","</span> &lt;&lt; <span class="string">"y="</span>&lt;&lt;a.y ;</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">A <span class="title">a1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; a1;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; a1;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印</span></span><br><span class="line"><span class="number">21</span> <span class="number">88</span></span><br><span class="line">x=<span class="number">21</span>,y=<span class="number">88</span></span><br></pre></td></tr></table></figure>

<h4 id="c-11对象自带的函数"><a href="#c-11对象自带的函数" class="headerlink" title="c++11对象自带的函数"></a>c++11对象自带的函数</h4><blockquote>
<p>c++11中类的默认函数</p>
</blockquote>
<p>6个函数 + 全局默认操作符号</p>
<ul>
<li>构造函数:<code>A()</code></li>
<li>拷贝构造函数:<code>A(const A&amp;)</code>或<code>A(A&amp;)</code></li>
<li>拷贝赋值函数:<code>A&amp; operator=(const A&amp;)</code>或<code>A&amp; operator=(A&amp;)</code></li>
<li>移动构造函数:<code>A(A &amp;&amp;)</code></li>
<li>移动赋值函数:<code>A&amp; operator=(A &amp;&amp;)</code></li>
<li>析构函数:<code>~A()</code></li>
</ul>
<h4 id="const修饰成员函数"><a href="#const修饰成员函数" class="headerlink" title="const修饰成员函数"></a>const修饰成员函数</h4><blockquote>
<p>底层原理本质是利用了重载</p>
<p>修饰对象： <a href="https://blog.csdn.net/alidada_blog/article/details/86477750" target="_blank" rel="noopener">https://blog.csdn.net/alidada_blog/article/details/86477750</a></p>
<p>修饰对象成员函数：<a href="https://blog.csdn.net/qq_52302919/article/details/127129326" target="_blank" rel="noopener">https://blog.csdn.net/qq_52302919/article/details/127129326</a></p>
</blockquote>
<ul>
<li><p>修饰对象</p>
<ul>
<li>对象调用函数时，传入的this都是const A* const this， 只有常函数可以匹配这个参数，所以只能调用常函数</li>
</ul>
</li>
<li><p>修饰成员函数</p>
<ul>
<li>对象调用该函数时，该函数要求传入的this是const A* const this</li>
<li>所以内部不能修改成员变量</li>
</ul>
</li>
</ul>
<h4 id="A-p-NULL"><a href="#A-p-NULL" class="headerlink" title="A* p = NULL"></a>A* p = NULL</h4><blockquote>
<p><a href="https://blog.csdn.net/songzitea/article/details/52177279" target="_blank" rel="noopener">https://blog.csdn.net/songzitea/article/details/52177279</a></p>
</blockquote>
<ul>
<li>A* p = NULL;  // 只声明了， 并没有定义，A对象根本就没有定义，这个对象就没初始, <strong>就不存在一个A对象</strong></li>
<li>这个操作相当 this = NULL，访问成员变量时需要通过this，那就是访问空指针，自然报错<ul>
<li>本质是访问空指针</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">p0</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, <span class="number">123</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">p1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">p2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// printf("%d", (int)&amp;x); //编译报错，不能将int* 转化为int</span></span><br><span class="line">    <span class="comment">// printf("%d", reinterpret_cast&lt;int&gt;(&amp;x)); // 也不能正常转换</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;&amp;x&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 可通过编译</span></span><br><span class="line">  <span class="comment">// -------这里只声明了， 并没有定义，A对象根本就没有定义，这个对象就没初始化-------</span></span><br><span class="line">  A* p = <span class="literal">NULL</span>; <span class="comment">// 此时就是将NULL赋值给了this指针，NULL在c++中就是0， 0是基地址，访问需要进入内核态，没有权限报core错误</span></span><br><span class="line">  p-&gt;p0(); <span class="comment">// 可以调用</span></span><br><span class="line">  p-&gt;p1(); <span class="comment">// 对象地址为null 也就是0， **执行**报错 // Segmentation fault (core dumped)  内核态没有权限访问  基地址要进入内核态，没有权限访问</span></span><br><span class="line">  p-&gt;p2(); <span class="comment">// 需要通过this访问x， this = NULL，同样问题执行报错</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">p0</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, <span class="number">123</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">p1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">p2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;&amp;x&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 可通过编译</span></span><br><span class="line">  A* p = <span class="literal">NULL</span>; <span class="comment">// 此时就是将NULL赋值给了this指针，NULL在c++中就是0， 0是基地址，访问需要进入内核态，没有权限报core错误</span></span><br><span class="line">  <span class="comment">// 此时需要通过this，然后通过虚函数指针访问虚表里函数的地址  而this = NULL ,同样问题报错</span></span><br><span class="line">  p-&gt;p0(); </span><br><span class="line">  p-&gt;p1(); </span><br><span class="line">  p-&gt;p2(); </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">p0</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, <span class="number">123</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">p1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, x); <span class="comment">// 直接编辑器提示错误</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">p2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;&amp;x&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 直接编辑器提示错误</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 编译不通过</span></span><br><span class="line">  A* p = <span class="literal">NULL</span>; <span class="comment">// 此时就是将NULL赋值给了this指针，NULL在c++中就是0， 0是基地址，访问需要进入内核态，没有权限报core错误</span></span><br><span class="line">  <span class="comment">// static 函数属于类， 没有this指针，不能访问x，直接编译报错</span></span><br><span class="line">  p-&gt;p0(); </span><br><span class="line">  p-&gt;p1(); </span><br><span class="line">  p-&gt;p2(); </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="阿里二面"><a href="#阿里二面" class="headerlink" title="阿里二面"></a>阿里二面</h4><p>operator new的第二参数，传入指针，结合vector，先开辟空间再用new()构造</p>
<p>父类析构函数没有定义为虚析构函数，如何保证子类可以正常析构，使用share_ptr、template解决   share_ptr的删除器(default_delete)</p>
<p>如何解决share_ptr的高频访问，在多线程的情况下，实现原子性，，，，</p>
<p>编程规范，传入(const &amp;)传出参数</p>
<blockquote>
<p><a href="https://cloud.tencent.com/developer/article/2240964" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/2240964</a></p>
<p><a href="https://www.jianshu.com/p/d625150cdffc" target="_blank" rel="noopener">https://www.jianshu.com/p/d625150cdffc</a></p>
<p><a href="https://blog.csdn.net/weixin_43862847/article/details/126493820" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43862847/article/details/126493820</a></p>
<p><a href="https://blog.csdn.net/weixin_41504987/article/details/124396989" target="_blank" rel="noopener">https://blog.csdn.net/weixin_41504987/article/details/124396989</a></p>
<p><a href="https://blog.csdn.net/u012477435/article/details/106875121/" target="_blank" rel="noopener">https://blog.csdn.net/u012477435/article/details/106875121/</a></p>
<p><a href="https://blog.csdn.net/jiangfuqiang/article/details/8292906" target="_blank" rel="noopener">https://blog.csdn.net/jiangfuqiang/article/details/8292906</a></p>
<p><a href="https://blog.csdn.net/GreatTang/article/details/125814259?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-125814259-blog-8292906.235%5Ev30%5Epc_relevant_default_base&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-125814259-blog-8292906.235%5Ev30%5Epc_relevant_default_base&amp;utm_relevant_index=3" target="_blank" rel="noopener">https://blog.csdn.net/GreatTang/article/details/125814259?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-125814259-blog-8292906.235%5Ev30%5Epc_relevant_default_base&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-125814259-blog-8292906.235%5Ev30%5Epc_relevant_default_base&amp;utm_relevant_index=3</a>    </p>
<p><a href="https://blog.csdn.net/weixin_43606861/article/details/116121511?spm=1001.2101.3001.6650.5&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-5-116121511-blog-125814259.235%5Ev30%5Epc_relevant_default_base&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-5-116121511-blog-125814259.235%5Ev30%5Epc_relevant_default_base&amp;utm_relevant_index=8" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43606861/article/details/116121511?spm=1001.2101.3001.6650.5&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-5-116121511-blog-125814259.235%5Ev30%5Epc_relevant_default_base&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-5-116121511-blog-125814259.235%5Ev30%5Epc_relevant_default_base&amp;utm_relevant_index=8</a></p>
</blockquote>
<h4 id="华为"><a href="#华为" class="headerlink" title="华为"></a>华为</h4><p>申请一个int A[10]，然后把A强制转换成char<em>，问sizeof(A)返回多少，我回答是40B，理由是因为最开始就申请了10*4B的空间，强转了也是这么大，不知道对不对。追问给A赋值“hello”，问strlen返回多少（5，也不知道对不对），又问sizeof(char</em>)的大小（1B，C++常见的指针都是1B吧</p>
<ul>
<li><code>sizeof(char*) == 8</code>  只要是指针就是8</li>
<li>不能直接<code>char* c = &quot;hello&quot;</code>这样初始化，只能先初始化字符数组再赋值给这个指针</li>
<li><code>sizeof(数组) = 数组长度</code></li>
<li><code>strcpy(b，&quot;hello&quot;)</code>   b 是用字符数组初始化的字符指针，用这种方式才能给字符指针初始化</li>
<li><code>strlen()</code>只返回字符有效字符个数，不包括反斜杠<ul>
<li>传入参数可以是字符数组，也可以字符指针，返回结果一样</li>
</ul>
</li>
<li>int[] 转 char* 可以用(char*)强转，也可以用reinterpret_cast转换</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(a)&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">// 40</span></span><br><span class="line">  <span class="comment">// 把a强制转换成char*</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(<span class="keyword">char</span>*)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 8</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(<span class="keyword">int</span>)&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span>* b = (<span class="keyword">char</span>*)a;</span><br><span class="line">  <span class="comment">// b = "hello";  // 编译报错，不知直接用常量初始化</span></span><br><span class="line">  <span class="built_in">strcpy</span>(b, <span class="string">"hello"</span>);</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(b)&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">// 8</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(*b)&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">// 1</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="built_in">strlen</span>(b)&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">// 5</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">// hello</span></span><br><span class="line">  <span class="comment">// 循环b</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">    b[i] = <span class="string">'a'</span> + i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//  输出b</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;b[i];  <span class="comment">// abcdefghij</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"-------------------"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="comment">// char* c = "hello";  // 编译报错，不知直接用常量初始化</span></span><br><span class="line">  <span class="keyword">char</span> c[<span class="number">6</span>] = <span class="string">"hello"</span>;</span><br><span class="line">  <span class="keyword">char</span>* d = c;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(c)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 6</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(d)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 8</span></span><br><span class="line">  <span class="comment">// 输出 c</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;d&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(a)&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">// 40</span></span><br><span class="line">  <span class="comment">// 把a强制转换成char*类型，再求大小</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(<span class="keyword">char</span>*)&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">// 8</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>((<span class="keyword">char</span>*)a)&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">// 8</span></span><br><span class="line">  <span class="keyword">char</span> * b = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(a);</span><br><span class="line">  <span class="comment">// b = "hello world"; // 报错 不能这样赋值</span></span><br><span class="line">  <span class="built_in">strcpy</span>(b, <span class="string">"hello world"</span>);</span><br><span class="line">  <span class="comment">// strlen 求b 并输出</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="built_in">strlen</span>(b)&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">// 11</span></span><br><span class="line">  <span class="comment">// 输出b</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">// hello world</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> c[<span class="number">10</span>];</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(c)&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">// 10</span></span><br><span class="line">  <span class="built_in">strcpy</span>(c, <span class="string">"abc"</span>);</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="built_in">strlen</span>(c)&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">// 3</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(c)&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">// 10   取决于申请的空间大小</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="计算机上网络"><a href="#计算机上网络" class="headerlink" title="计算机上网络"></a>计算机上网络</h2><blockquote>
<p><a href="https://blog.csdn.net/Fuel_Ming/article/details/122931926" target="_blank" rel="noopener">select中的fd_set</a></p>
<p>fd_set: 是一个 unsighed long 数组，大小16   16 * 8 *8 = 1024</p>
</blockquote>
<h3 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h3><h4 id="TCP与UDP"><a href="#TCP与UDP" class="headerlink" title="TCP与UDP"></a>TCP与UDP</h4><p>TCP是可靠的，面向连接的，数据流传输协议</p>
<p>UPD是不可靠的，是面向无连接的，报式传输协议</p>
<h4 id="TCP通信流程"><a href="#TCP通信流程" class="headerlink" title="TCP通信流程"></a>TCP通信流程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">	1. socket()	创建socket</span><br><span class="line"></span><br><span class="line">	2. bind()	绑定服务器地址结构</span><br><span class="line"></span><br><span class="line">	3. listen()	设置监听上限</span><br><span class="line"></span><br><span class="line">	4. accept()	阻塞监听客户端连接</span><br><span class="line"></span><br><span class="line">	5. read(fd)	读socket获取客户端数据</span><br><span class="line"></span><br><span class="line">	6. 小--大写	toupper()</span><br><span class="line"></span><br><span class="line">	7. write(fd)</span><br><span class="line"></span><br><span class="line">	8. close();</span><br><span class="line"></span><br><span class="line">client:</span><br><span class="line"></span><br><span class="line">	1. socket()	创建socket</span><br><span class="line"></span><br><span class="line">	2. connect();	与服务器建立连接</span><br><span class="line"></span><br><span class="line">	3. write()	写数据到 socket</span><br><span class="line"></span><br><span class="line">	4. read()	读转换后的数据。</span><br><span class="line"></span><br><span class="line">	5. 显示读取结果</span><br><span class="line"></span><br><span class="line">	6. close()</span><br></pre></td></tr></table></figure>

<h4 id="UDP通信流程"><a href="#UDP通信流程" class="headerlink" title="UDP通信流程"></a>UDP通信流程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">	recv()&#x2F;send() 只能用于 TCP 通信。 替代 read、write</span><br><span class="line"></span><br><span class="line">	accpet(); ---- Connect(); ---被舍弃</span><br><span class="line"></span><br><span class="line">	server：</span><br><span class="line"></span><br><span class="line">		lfd &#x3D; socket(AF_INET, STREAM, 0);	SOCK_DGRAM --- 报式协议。</span><br><span class="line"></span><br><span class="line">		bind();</span><br><span class="line"></span><br><span class="line">		listen();  --- 可有可无</span><br><span class="line"></span><br><span class="line">		while（1）&#123;</span><br><span class="line"></span><br><span class="line">			read(cfd, buf, sizeof) --- 被替换 --- recvfrom（） --- 涵盖accept传出地址结构。</span><br><span class="line">            小-- 大</span><br><span class="line">				</span><br><span class="line">			write();--- 被替换 --- sendto（）---- connect</span><br><span class="line">		&#125;</span><br><span class="line">		close();</span><br><span class="line"></span><br><span class="line">client：</span><br><span class="line"></span><br><span class="line">		connfd &#x3D; socket(AF_INET, SOCK_DGRAM, 0);</span><br><span class="line"></span><br><span class="line">		sendto（‘服务器的地址结构’， 地址结构大小）</span><br><span class="line"></span><br><span class="line">		recvfrom（）</span><br><span class="line"></span><br><span class="line">		写到屏幕</span><br><span class="line"></span><br><span class="line">		close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,struct sockaddr *src_addr, socklen_t *addrlen);</span><br><span class="line"></span><br><span class="line">					sockfd： 套接字</span><br><span class="line"></span><br><span class="line">					buf：缓冲区地址</span><br><span class="line"></span><br><span class="line">					len：缓冲区大小</span><br><span class="line"></span><br><span class="line">					flags： 0</span><br><span class="line"></span><br><span class="line">					src_addr：（struct sockaddr *）&amp;addr 传出。 对端地址结构</span><br><span class="line"></span><br><span class="line">					addrlen：传入传出。</span><br><span class="line"></span><br><span class="line">				返回值： 成功接收数据字节数。 失败：-1 errn。 0： 对端关闭。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,const struct sockaddr *dest_addr, socklen_t addrlen);</span><br><span class="line"></span><br><span class="line">					sockfd： 套接字</span><br><span class="line"></span><br><span class="line">					buf：存储数据的缓冲区</span><br><span class="line"></span><br><span class="line">					len：数据长度</span><br><span class="line"></span><br><span class="line">					flags： 0</span><br><span class="line"></span><br><span class="line">					src_addr：（struct sockaddr *）&amp;addr 传入。 目标地址结构</span><br><span class="line"></span><br><span class="line">					addrlen：地址结构长度。</span><br><span class="line"></span><br><span class="line">				返回值：成功写出数据字节数。 失败 -1， errno</span><br></pre></td></tr></table></figure>



<h4 id="tcp第三次握手失败"><a href="#tcp第三次握手失败" class="headerlink" title="tcp第三次握手失败"></a>tcp第三次握手失败</h4><blockquote>
<p><a href="https://www.zhihu.com/question/36495943?sort=created" target="_blank" rel="noopener">详细解释</a></p>
<p>在建立 TCP 连接时，如果第三次握手的 ACK丢失，服务端无法收到，则服务端就会短暂处于 <code>SYN_RECV</code> 状态，而客户端会处于 <code>ESTABLISHED</code> 状态。</p>
<p>由于服务端一直收不到 TCP 第三次握手的 ACK，则会一直重传 SYN、ACK 包，直到重传次数超过 <code>tcp_synack_retries</code> 值（默认值 5 次）后，服务端就会断开 TCP 连接。</p>
<p>而客户端则会有两种情况：</p>
<ul>
<li>如果客户端没发送数据包，一直处于 <code>ESTABLISHED</code> 状态，然后经过 2 小时 11 分 15 秒才可以发现一个「死亡」连接，于是客户端连接就会断开连接。</li>
<li>如果客户端发送了数据包，一直没有收到服务端对该数据包的确认报文，则会一直重传该数据包，直到重传次数超过 <code>tcp_retries2</code> 值（默认值 15 次）后，客户端就会断开 TCP 连接。</li>
</ul>
<p><a href="https://blog.csdn.net/ActionTech/article/details/124858827" target="_blank" rel="noopener">解释1</a></p>
</blockquote>
<p><strong>服务端</strong></p>
<ul>
<li>没有收到ACK, 处于 <code>SYN_RECV</code> 状态</li>
<li>超时重传了 SYN、ACK 包，重传5 次，也就是<strong>超过 tcp_synack_retries 的值（默认值是 5），然后就没有继续重传了，此时服务端的 TCP 连接主动中止了，所以刚才处于 SYN_RECV 状态的 TCP 连接断开了</strong></li>
</ul>
<p><strong>客户端</strong></p>
<ul>
<li>收到第二次握手的SYN和ACK后就进入了<code>ESTABLISHED</code> 状态</li>
<li>建立连接后就发送数据<ul>
<li>客户端向服务端发送数据包时，由于服务端的 TCP 连接已经退出了，所以数据包一直在超时重传，共重传了 15 次， telnet 就断开了连接<ul>
<li>TCP 建立连接后的数据包传输，最大超时重传次数是由 <code>tcp_retries2</code> 指定，默认值是 15 次</li>
</ul>
</li>
</ul>
</li>
<li>建立连接后不发送数据<ul>
<li>TCP 的 <strong>保活机制</strong>进行处理<ul>
<li>定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个「探测报文」，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="拥塞控制-流量控制"><a href="#拥塞控制-流量控制" class="headerlink" title="拥塞控制/流量控制"></a>拥塞控制/流量控制</h4><blockquote>
<p><a href="https://xiaolincoding.com/network/3_tcp/tcp_feature.html" target="_blank" rel="noopener">https://xiaolincoding.com/network/3_tcp/tcp_feature.html</a></p>
</blockquote>
<ul>
<li>流量控制是避免「发送方」的数据填满「接收方」的缓存</li>
<li><strong>拥塞控制</strong>，控制的目的就是<strong>避免「发送方」的数据填满整个网络</strong></li>
</ul>
<h4 id="tcp粘包和拆包"><a href="#tcp粘包和拆包" class="headerlink" title="tcp粘包和拆包"></a>tcp粘包和拆包</h4><blockquote>
<p><a href="https://www.bilibili.com/video/BV1yf4y1Y7CU?p=1&vd_source=7230a052308bbb41976f248d2c778e3a" target="_blank" rel="noopener">大丙视频</a></p>
<p>添加包头</p>
<p>本质不是tcp的问题，tcp本身是流式传输，UDP是报式传输</p>
</blockquote>
<ul>
<li>发送方：在发送的数据包前添加数据包大小(注意字节序的转换)，在while发送这个数据包，每次write都会返回发送了多少，while直到整个包的数据确保都发完了</li>
<li>接收方：先接收包头即数据包的大小，在while接收这样大小的数据，每次read会返回接收了多少，while直到接收了整个数据包，除非read返回0，则表示发送方没有数据了</li>
</ul>
<h4 id="select"><a href="#select" class="headerlink" title="select"></a><strong>select</strong></h4><ul>
<li>优点<ul>
<li>跨平台</li>
</ul>
</li>
<li>缺点<ul>
<li>监听上限1024</li>
<li>每次需要遍历fd_set，找到有读事件的文件并处理<ul>
<li>需要自己构建一个监听的文件描述符的集合数组来优化这个问题</li>
</ul>
</li>
<li>每次select都是系统调用，都要切换用户态和内核态，fd_set要不在用户态和内核态直接反复拷贝</li>
</ul>
</li>
<li>参数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds,fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br><span class="line"></span><br><span class="line">		nfds：监听的所有文件描述符中，最大文件描述符+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">		readfds： 读 文件描述符监听集合。	传入、传出参数</span><br><span class="line"></span><br><span class="line">		writefds：写 文件描述符监听集合。	传入、传出参数		<span class="literal">NULL</span></span><br><span class="line"></span><br><span class="line">		exceptfds：异常 文件描述符监听集合	传入、传出参数		<span class="literal">NULL</span></span><br><span class="line"></span><br><span class="line">		timeout： 	&gt; <span class="number">0</span>: 	设置监听超时时长。</span><br><span class="line"></span><br><span class="line">				   <span class="literal">NULL</span>:	阻塞监听 （timeout）</span><br><span class="line"></span><br><span class="line">				      <span class="number">0</span>：	非阻塞监听，轮询 （timeout）</span><br><span class="line">		返回值：</span><br><span class="line"></span><br><span class="line">			&gt; <span class="number">0</span>:	所有监听集合（<span class="number">3</span>个）中， 满足对应事件的总数。</span><br><span class="line"></span><br><span class="line">			  <span class="number">0</span>：	没有满足监听条件的文件描述符</span><br><span class="line"></span><br><span class="line">			 <span class="number">-1</span>： 	errno</span><br></pre></td></tr></table></figure>



<h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a><strong>poll</strong></h4><ul>
<li><p>优点：</p>
<ul>
<li>自带数组结构。 可以将 监听事件集合 和 返回事件集合 分离。</li>
<li>拓展 监听上限。 超出 1024限制。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>不能跨平台。 Linux</li>
<li>无法直接定位满足监听事件的文件描述符， 编码难度较大。</li>
</ul>
</li>
<li><p>参数</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line">		fds：监听的文件描述符【数组】</span><br><span class="line"></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">				</span><br><span class="line">				<span class="keyword">int</span> fd：	待监听的文件描述符</span><br><span class="line">				</span><br><span class="line">				short events：	待监听的文件描述符对应的监听事件</span><br><span class="line"></span><br><span class="line">						取值：POLLIN、POLLOUT、POLLERR</span><br><span class="line"></span><br><span class="line">				short revnets：	传入时， 给<span class="number">0</span>。如果满足对应事件的话， 返回 非<span class="number">0</span> --&gt; POLLIN、POLLOUT、POLLERR</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		nfds: 监听数组的，实际有效监听个数。</span><br><span class="line"></span><br><span class="line">		timeout:  &gt; <span class="number">0</span>:  超时时长。单位：毫秒。</span><br><span class="line"></span><br><span class="line">			      <span class="number">-1</span>:	阻塞等待</span><br><span class="line"></span><br><span class="line">			       <span class="number">0</span>：  不阻塞</span><br><span class="line"></span><br><span class="line">		返回值：返回满足对应监听事件的文件描述符 总个数。</span><br></pre></td></tr></table></figure>



<h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a><strong>epoll</strong></h4><blockquote>
<p>epoll是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在<strong>大量并发连接中只有少量活跃</strong>的情况下的系统CPU利用率</p>
</blockquote>
<ul>
<li><p>优点：</p>
<ul>
<li>高效。突破1024文件描述符。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>不能跨平台。 Linux。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;						<span class="comment">//创建一棵监听红黑树</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">size</span>：创建的红黑树的监听节点数量。（仅供内核参考。）</span><br><span class="line"></span><br><span class="line">	返回值：指向新创建的红黑树的根节点的 fd。 </span><br><span class="line"></span><br><span class="line">		   失败： <span class="number">-1</span> errno</span><br><span class="line">           </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;	<span class="comment">//操作监听红黑树</span></span><br><span class="line"></span><br><span class="line">	epfd：epoll_create 函数的返回值。 epfd</span><br><span class="line"></span><br><span class="line">	op：对该监听红黑数所做的操作。</span><br><span class="line"></span><br><span class="line">		EPOLL_CTL_ADD 添加fd到 监听红黑树</span><br><span class="line"></span><br><span class="line">		EPOLL_CTL_MOD 修改fd在 监听红黑树上的监听事件。</span><br><span class="line"></span><br><span class="line">		EPOLL_CTL_DEL 将一个fd 从监听红黑树上摘下（取消监听）</span><br><span class="line"></span><br><span class="line">	fd：</span><br><span class="line">		待监听的fd</span><br><span class="line"></span><br><span class="line">	event：	本质 <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> 结构体 地址</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">		成员 <span class="title">events</span>：</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">			<span class="title">EPOLLIN</span> / <span class="title">EPOLLOUT</span> / <span class="title">EPOLLERR</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">		成员 <span class="title">data</span>： 联合体（共用体）：</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">			<span class="title">int</span> <span class="title">fd</span>;</span>	  对应监听事件的 fd</span><br><span class="line"></span><br><span class="line">			<span class="keyword">void</span> *ptr； </span><br><span class="line"></span><br><span class="line">			<span class="keyword">uint32_t</span> u32;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">uint64_t</span> u64;		</span><br><span class="line"></span><br><span class="line">	返回值：成功 <span class="number">0</span>； 失败： <span class="number">-1</span> errno</span><br><span class="line">           </span><br><span class="line">           </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>; 	 <span class="comment">//阻塞监听。</span></span><br><span class="line"></span><br><span class="line">	epfd：epoll_create 函数的返回值。 epfd</span><br><span class="line"></span><br><span class="line">	events：传出参数，【数组】， 满足监听条件的 那些 fd 结构体。</span><br><span class="line"></span><br><span class="line">	maxevents：数组 元素的总个数。 <span class="number">1024</span></span><br><span class="line">			</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">evnets</span>[1024]</span></span><br><span class="line"><span class="class">	<span class="title">timeout</span>：</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">		-1:</span> 阻塞</span><br><span class="line"></span><br><span class="line">		<span class="number">0</span>： 不阻塞</span><br><span class="line"></span><br><span class="line">		&gt;<span class="number">0</span>: 超时时间 （毫秒）</span><br><span class="line"></span><br><span class="line">	返回值：</span><br><span class="line"></span><br><span class="line">		&gt; <span class="number">0</span>: 满足监听的 总个数。 可以用作循环上限。</span><br><span class="line"></span><br><span class="line">		<span class="number">0</span>： 没有fd满足监听事件</span><br><span class="line"></span><br><span class="line">		<span class="number">-1</span>：失败。 errno</span><br></pre></td></tr></table></figure>

<h4 id="ET-LT"><a href="#ET-LT" class="headerlink" title="ET/LT"></a><strong>ET/LT</strong></h4><ul>
<li><p>Edge Triggered (ET) 边缘触发只有数据到来才触发，不管缓存区中是否还有数据。</p>
<ul>
<li>缓冲区剩余未读尽的数据不会导致epo11_wait返回</li>
<li>使用场景：读取文件的头信息（文件元信息，文件全部信息暂时不用读取）</li>
</ul>
</li>
<li><p>Level Triggered (LT) 水平触发只要有数据都会触发。</p>
<ul>
<li>缓冲区剩余未读尽的数据会导致epo11_wait返回</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> event.events = EPOLLIN | EPOLLET;     <span class="comment">// ET 边沿触发  </span></span><br><span class="line"> <span class="comment">// event.events = EPOLLIN;                 // LT 水平触发 (默认)  </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">epoll 的 ET模式， 高效模式，但是只支持 非阻塞模式。 --- 忙轮询。   ？？？？为什么只支持非阻塞？？？？</span><br><span class="line"></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line"></span><br><span class="line">		event.events = EPOLLIN | EPOLLET;</span><br><span class="line"></span><br><span class="line">		epoll_ctl(epfd, EPOLL_CTL_ADD, cfd， &amp;event);	</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 下面三句设置非阻塞</span></span><br><span class="line">		<span class="keyword">int</span> flg = fcntl(cfd, F_GETFL);	</span><br><span class="line"></span><br><span class="line">		flg |= O_NONBLOCK;</span><br><span class="line"></span><br><span class="line">		fcntl(cfd, F_SETFL, flg);</span><br></pre></td></tr></table></figure>

<h4 id="epoll反应堆"><a href="#epoll反应堆" class="headerlink" title="epoll反应堆"></a><strong>epoll反应堆</strong></h4><blockquote>
<p>day4-4-源代码-epoll_ET_LT</p>
<p>/learn/network/tcp_epoll/libevent.c</p>
<p>epoll ET模式 + 非阻塞、轮询 + void *ptr</p>
</blockquote>
<h3 id="基础问题"><a href="#基础问题" class="headerlink" title="基础问题"></a>基础问题</h3><h4 id="http1-0-1-1-2-3区别"><a href="#http1-0-1-1-2-3区别" class="headerlink" title="http1.0/1.1/2/3区别"></a>http1.0/1.1/2/3区别</h4><p>1.0 -&gt; 1.1</p>
<ul>
<li><p><a href="https://blog.csdn.net/u013531487/article/details/130337143" target="_blank" rel="noopener">长连接</a></p>
<ul>
<li><p>http的长连接是一个tcp上复用多个http</p>
</li>
<li><p>tcp的长连接就是tcp的保活机制，隔一段时间做一个探测</p>
</li>
</ul>
</li>
<li><p>管道，解决发送的对头阻塞</p>
</li>
</ul>
<p>1.1 -&gt; 2.0</p>
<ul>
<li>头部压缩</li>
<li>二进制格式传输，200字符传输3个字节，二进制传输1个字节</li>
<li>并发传输，stream，解决响应队头阻塞问题</li>
<li>主动推送，请求html返回html和css</li>
</ul>
<p>2.0 -&gt; 3.0</p>
<ul>
<li>底层改成UDP，解决TCP导致的队头阻塞(丢包重传，阻塞已经到达内核态的数据传到用户态)</li>
<li>QUIC，将https的握手结合，减少了握手次数</li>
</ul>
<h4 id="https握手过程"><a href="#https握手过程" class="headerlink" title="https握手过程"></a>https握手过程</h4><h4 id="浏览器输入url"><a href="#浏览器输入url" class="headerlink" title="浏览器输入url"></a>浏览器输入url</h4><p><strong>TCP</strong></p>
<ul>
<li><p>消息头</p>
<ul>
<li>序列号</li>
<li>确认序号</li>
<li>状态位</li>
<li>窗口大小</li>
</ul>
</li>
<li><p>握手</p>
</li>
</ul>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-Wireshark/19.jpg" alt="TCP 三次握手和四次挥手的流程"></p>
<h4 id="reset使用场景"><a href="#reset使用场景" class="headerlink" title="reset使用场景"></a>reset使用场景</h4><p>当收到不符合预期的情况时，就会使用reset，，，</p>
<h4 id="什么情况下会断开tcp"><a href="#什么情况下会断开tcp" class="headerlink" title="什么情况下会断开tcp"></a>什么情况下会断开tcp</h4><ul>
<li>当使用socket编程时，调用close，主动断开连接</li>
<li>当中间设备坏掉时，例如交换机坏掉了</li>
</ul>
<h2 id="操作系统-1"><a href="#操作系统-1" class="headerlink" title="操作系统"></a>操作系统</h2><h4 id="进程同步方式："><a href="#进程同步方式：" class="headerlink" title="进程同步方式："></a>进程同步方式：</h4><ul>
<li>信号</li>
<li>信号量</li>
<li>互斥锁</li>
</ul>
<h4 id="进程间通信方式："><a href="#进程间通信方式：" class="headerlink" title="进程间通信方式："></a>进程间通信方式：</h4><ul>
<li>管道</li>
<li>系统IPC<ul>
<li>内存共享</li>
<li>消息队列</li>
<li>信号</li>
<li>信号量</li>
</ul>
</li>
<li>套接字</li>
</ul>
<h4 id="线程间同步方式："><a href="#线程间同步方式：" class="headerlink" title="线程间同步方式："></a>线程间同步方式：</h4><ul>
<li>信号量</li>
<li>信号</li>
<li>条件变量</li>
<li>互斥锁</li>
<li>读写锁</li>
</ul>
<h4 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h4><ul>
<li>乐观锁通过CAS实现<ul>
<li>假设每次访问都没有竞争</li>
<li>先读取数据修改，写回时判断数据有没有被修改过，如果修改过则重写读取修改，如果没有修改过则写回</li>
</ul>
</li>
<li>悲观锁<ul>
<li>假设每次访问都有竞争，直接上锁然后操作</li>
</ul>
</li>
</ul>
<h4 id="死锁条件"><a href="#死锁条件" class="headerlink" title="死锁条件"></a>死锁条件</h4><ul>
<li>互斥条件</li>
<li>请求保持</li>
<li>不可剥夺</li>
<li>环路等待</li>
</ul>
<p>避免死锁</p>
<ul>
<li>资源统一分配，避免请求保持</li>
<li>可剥夺资源</li>
<li>资源有序分配，避免环路等待</li>
</ul>
<p>避免死锁</p>
<ul>
<li><p>从设计上避免死锁</p>
</li>
<li><p>按序分配资源</p>
</li>
<li><p><strong>使用锁的顺序</strong>：确保所有线程都按照相同的顺序请求锁。这可以减少死锁的概率。例如，如果线程A首先请求锁X，然后请求锁Y，那么线程B也应该按照相同的顺序请求这两个锁。</p>
</li>
<li><p><strong>使用超时</strong>：在获取锁时，可以设置一个超时时间。如果在超时时间内无法获取锁，线程可以释放已经持有的锁并重试，从而避免死锁。</p>
</li>
<li><p><strong>使用适当的锁粒度</strong>：尽量避免使用全局锁，而是使用更小的锁粒度。这可以减少锁的争夺，降低死锁的可能性。</p>
</li>
<li><p><strong>使用信号量和条件变量</strong>：这些同步工具可以帮助你更精细地控制线程的执行顺序，从而降低死锁的风险</p>
</li>
<li></li>
<li><p><strong>避免嵌套锁</strong>：不要在持有一个锁的情况下再次请求另一个锁，因为这可能导致死锁。如果确实需要多个锁，可以使用递归锁来解决这个问题。</p>
</li>
<li><p><strong>使用资源分配图</strong>：可以使用资源分配图来检测潜在的死锁情况。如果发现资源分配图中存在环路，那么就可能存在死锁。</p>
</li>
<li><p><strong>合理设计算法</strong>：尽量设计避免死锁的算法。例如，银行家算法用于分配资源，以确保不会发生死锁。</p>
</li>
<li><p><strong>避免饥饿</strong>：确保所有线程都有机会获得它们需要的资源。避免一个线程长时间占用资源，导致其他线程饥饿。</p>
</li>
<li><p><strong>使用死锁检测工具</strong>：一些编程语言和工具提供死锁检测工具，可以帮助你发现和解决潜在的死锁问题。</p>
</li>
<li><p><strong>仔细测试和分析</strong>：在多线程或多进程程序中，进行仔细的测试和代码审查，以识别和解决潜在的死锁问题</p>
</li>
</ul>
<h4 id="程序运行流程"><a href="#程序运行流程" class="headerlink" title="程序运行流程"></a><strong>程序运行流程</strong></h4><p>预编译、编译、汇编、链接、装载、运行</p>
<ul>
<li><p>预编译</p>
<ul>
<li>预编译主要是做一些代码文本的替换工作</li>
<li>#define、#include、 条件编译</li>
<li>代码注释</li>
</ul>
</li>
<li><p>编译</p>
<ul>
<li><code>g++ -c test.cpp -o test.o</code>  生成<code>.o</code>的文件   <code>test.cpp ----&gt;  test.o</code></li>
</ul>
</li>
<li><p>汇编</p>
<ul>
<li>将代码转换为机器码</li>
</ul>
</li>
<li><p>链接</p>
<ul>
<li>目标文件仅仅是当前的源码文件编译成的二进制文件</li>
<li>并没有经过链接过程，是不能够执行的</li>
</ul>
</li>
</ul>
<h4 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h4><blockquote>
<p><a href="https://blog.csdn.net/qq_53162179/article/details/125004093" target="_blank" rel="noopener">https://blog.csdn.net/qq_53162179/article/details/125004093</a></p>
</blockquote>
<p>一个数组存储一亿个元素，内存是连续的吗</p>
<ul>
<li>一亿个元素内存大概400M</li>
</ul>
<h4 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h4><p>一个32核的机器，跑5个进程，如何使得每个进程不会占用太多核，也不会使用太少核</p>
<ul>
<li>可以通过操作系统的调度算法，控制每个进程在cpu上的时间片，实现相对公平</li>
</ul>
<h2 id="数据库-1"><a href="#数据库-1" class="headerlink" title="数据库"></a>数据库</h2><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>B树和B+树的区别</p>
<ul>
<li>B+树数据都存储在叶子节点上</li>
<li>B+树叶子节点通过链表链接</li>
</ul>
<h2 id="大数据量"><a href="#大数据量" class="headerlink" title="大数据量"></a>大数据量</h2><p>有限内存对大量数据排序</p>
<ul>
<li>利用桶排序的方式，先划分好桶，一个桶对应一个磁盘上的文件</li>
<li>读入数据，放到相应的文件中</li>
<li>读出每个文件，进行文件内排序</li>
<li>最终合并文件得到大文件</li>
</ul>
<h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><p>查询去重</p>
<blockquote>
<p><a href="https://blog.csdn.net/m0_67402026/article/details/126117902" target="_blank" rel="noopener">https://blog.csdn.net/m0_67402026/article/details/126117902</a></p>
<p><a href="https://blog.csdn.net/qq_35091353/article/details/127805844" target="_blank" rel="noopener">https://blog.csdn.net/qq_35091353/article/details/127805844</a></p>
</blockquote>
<ul>
<li>distinct</li>
<li>group by</li>
<li>row_number</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">19.2、将之前的关键字全部组合在一起，来看一下他们的执行顺序？</span><br><span class="line">	select</span><br><span class="line">		...</span><br><span class="line">	from</span><br><span class="line">		...</span><br><span class="line">	where</span><br><span class="line">		...</span><br><span class="line">	group by</span><br><span class="line">		...</span><br><span class="line">	order by</span><br><span class="line">		...</span><br><span class="line">	</span><br><span class="line">	以上关键字的顺序不能颠倒，需要记忆。</span><br><span class="line">	执行顺序是什么？</span><br><span class="line">		1. from</span><br><span class="line">		2. where</span><br><span class="line">		3. group by</span><br><span class="line">		4. select</span><br><span class="line">		5. order by</span><br><span class="line">	</span><br><span class="line">	为什么分组函数不能直接使用在where后面？</span><br><span class="line">		select ename,sal from emp where sal &gt; min(sal);&#x2F;&#x2F;报错。</span><br><span class="line">		因为分组函数在使用的时候必须先分组之后才能使用。</span><br><span class="line">		where执行的时候，还没有分组。所以where后面不能出现分组函数。</span><br><span class="line"></span><br><span class="line">		select sum(sal) from emp; </span><br><span class="line">		这个没有分组，为啥sum()函数可以用呢？</span><br><span class="line">			因为select在group by之后执行。</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">20、大总结（单表的查询学完了）</span><br><span class="line">	select </span><br><span class="line">		...</span><br><span class="line">	from</span><br><span class="line">		...</span><br><span class="line">	where</span><br><span class="line">		...</span><br><span class="line">	group by</span><br><span class="line">		...</span><br><span class="line">	having</span><br><span class="line">		...</span><br><span class="line">	order by</span><br><span class="line">		...</span><br><span class="line">	</span><br><span class="line">	以上关键字只能按照这个顺序来，不能颠倒。</span><br><span class="line"></span><br><span class="line">	执行顺序？</span><br><span class="line">		1. from</span><br><span class="line">		2. where</span><br><span class="line">		3. group by</span><br><span class="line">		4. having</span><br><span class="line">		5. select</span><br><span class="line">		6. order by</span><br><span class="line">	</span><br><span class="line">	从某张表中查询数据，</span><br><span class="line">	先经过where条件筛选出有价值的数据。</span><br><span class="line">	对这些有价值的数据进行分组。</span><br><span class="line">	分组之后可以使用having继续筛选。</span><br><span class="line">	select查询出来。</span><br><span class="line">	最后排序输出！</span><br><span class="line"></span><br><span class="line">	找出每个岗位的平均薪资，要求显示平均薪资大于1500的，除MANAGER岗位之外，</span><br><span class="line">	要求按照平均薪资降序排。</span><br><span class="line">		select </span><br><span class="line">			job, avg(sal) as avgsal</span><br><span class="line">		from</span><br><span class="line">			emp</span><br><span class="line">		where</span><br><span class="line">			job &lt;&gt; &#39;MANAGER&#39;</span><br><span class="line">		group by</span><br><span class="line">			job</span><br><span class="line">		having</span><br><span class="line">			avg(sal) &gt; 1500</span><br><span class="line">		order by</span><br><span class="line">			avgsal desc;</span><br><span class="line"></span><br><span class="line">		+-----------+-------------+</span><br><span class="line">		| job       | avgsal      |</span><br><span class="line">		+-----------+-------------+</span><br><span class="line">		| PRESIDENT | 5000.000000 |</span><br><span class="line">		| ANALYST   | 3000.000000 |</span><br><span class="line">		+-----------+-------------+</span><br><span class="line"></span><br><span class="line">		select </span><br><span class="line">			job, avg(sal) as avgsal</span><br><span class="line">		from</span><br><span class="line">			emp</span><br><span class="line">		where</span><br><span class="line">			job not in(&#39;MANAGER&#39;)</span><br><span class="line">		group by</span><br><span class="line">			job</span><br><span class="line">		having</span><br><span class="line">			avg(sal) &gt; 1500</span><br><span class="line">		order by</span><br><span class="line">			avgsal desc;</span><br></pre></td></tr></table></figure>

<p>子查询</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.3</span>、where子句中的子查询</span><br><span class="line"></span><br><span class="line">	案例：找出比最低工资高的员工姓名和工资？</span><br><span class="line">		select </span><br><span class="line">			ename,sal</span><br><span class="line">		from</span><br><span class="line">			emp </span><br><span class="line">		where</span><br><span class="line">			sal &gt; <span class="built_in">min</span>(sal);</span><br><span class="line"></span><br><span class="line">		ERROR <span class="number">1111</span> (HY000): Invalid use of group function</span><br><span class="line">		where子句中不能直接使用分组函数。</span><br><span class="line">	</span><br><span class="line">	实现思路：</span><br><span class="line">		第一步：查询最低工资是多少</span><br><span class="line">			<span class="function">select <span class="title">min</span><span class="params">(sal)</span> from emp</span>;</span><br><span class="line">			+----------+</span><br><span class="line">			| <span class="built_in">min</span>(sal) |</span><br><span class="line">			+----------+</span><br><span class="line">			|   <span class="number">800.00</span> |</span><br><span class="line">			+----------+</span><br><span class="line">		第二步：找出&gt;<span class="number">800</span>的</span><br><span class="line">			select ename,sal from emp where sal &gt; <span class="number">800</span>;</span><br><span class="line">		</span><br><span class="line">		第三步：合并</span><br><span class="line">			select ename,sal from emp where sal &gt; (select <span class="built_in">min</span>(sal) from emp);</span><br><span class="line">			+--------+---------+</span><br><span class="line">			| ename  | sal     |</span><br><span class="line">			+--------+---------+</span><br><span class="line">			| ALLEN  | <span class="number">1600.00</span> |</span><br><span class="line">			| WARD   | <span class="number">1250.00</span> |</span><br><span class="line">			| JONES  | <span class="number">2975.00</span> |</span><br><span class="line">			| MARTIN | <span class="number">1250.00</span> |</span><br><span class="line">			| BLAKE  | <span class="number">2850.00</span> |</span><br><span class="line">			| CLARK  | <span class="number">2450.00</span> |</span><br><span class="line">			| SCOTT  | <span class="number">3000.00</span> |</span><br><span class="line">			| KING   | <span class="number">5000.00</span> |</span><br><span class="line">			| TURNER | <span class="number">1500.00</span> |</span><br><span class="line">			| ADAMS  | <span class="number">1100.00</span> |</span><br><span class="line">			| JAMES  |  <span class="number">950.00</span> |</span><br><span class="line">			| FORD   | <span class="number">3000.00</span> |</span><br><span class="line">			| MILLER | <span class="number">1300.00</span> |</span><br><span class="line">			+--------+---------+</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">3.4、from子句中的子查询</span><br><span class="line">	注意：from后面的子查询，可以将子查询的查询结果当做一张临时表。（技巧）</span><br><span class="line"></span><br><span class="line">	案例：找出每个岗位的平均工资的薪资等级。</span><br><span class="line"></span><br><span class="line">	第一步：找出每个岗位的平均工资（按照岗位分组求平均值）</span><br><span class="line">		select job,avg(sal) from emp group by job;</span><br><span class="line">		+-----------+-------------+</span><br><span class="line">		| job       | avgsal      |</span><br><span class="line">		+-----------+-------------+</span><br><span class="line">		| ANALYST   | 3000.000000 |</span><br><span class="line">		| CLERK     | 1037.500000 |</span><br><span class="line">		| MANAGER   | 2758.333333 |</span><br><span class="line">		| PRESIDENT | 5000.000000 |</span><br><span class="line">		| SALESMAN  | 1400.000000 |</span><br><span class="line">		+-----------+-------------+t表</span><br><span class="line"></span><br><span class="line">	第二步：克服心理障碍，把以上的查询结果就当做一张真实存在的表t。</span><br><span class="line">	mysql&gt; select * from salgrade; s表</span><br><span class="line">	+-------+-------+-------+</span><br><span class="line">	| GRADE | LOSAL | HISAL |</span><br><span class="line">	+-------+-------+-------+</span><br><span class="line">	|     1 |   700 |  1200 |</span><br><span class="line">	|     2 |  1201 |  1400 |</span><br><span class="line">	|     3 |  1401 |  2000 |</span><br><span class="line">	|     4 |  2001 |  3000 |</span><br><span class="line">	|     5 |  3001 |  9999 |</span><br><span class="line">	+-------+-------+-------+</span><br><span class="line">	t表和s表进行表连接，条件：t表avg(sal) between s.losal and s.hisal;</span><br><span class="line">		</span><br><span class="line">		select </span><br><span class="line">			t.*, s.grade</span><br><span class="line">		from</span><br><span class="line">			(select job,avg(sal) as avgsal from emp group by job) t</span><br><span class="line">		join</span><br><span class="line">			salgrade s</span><br><span class="line">		on</span><br><span class="line">			t.avgsal between s.losal and s.hisal;</span><br><span class="line">		</span><br><span class="line">		+-----------+-------------+-------+</span><br><span class="line">		| job       | avgsal      | grade |</span><br><span class="line">		+-----------+-------------+-------+</span><br><span class="line">		| CLERK     | 1037.500000 |     1 |</span><br><span class="line">		| SALESMAN  | 1400.000000 |     2 |</span><br><span class="line">		| ANALYST   | 3000.000000 |     4 |</span><br><span class="line">		| MANAGER   | 2758.333333 |     4 |</span><br><span class="line">		| PRESIDENT | 5000.000000 |     5 |</span><br><span class="line">		+-----------+-------------+-------+</span><br></pre></td></tr></table></figure>

<h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><h5 id="查看内存使用情况"><a href="#查看内存使用情况" class="headerlink" title="查看内存使用情况"></a>查看内存使用情况</h5><blockquote>
<p>free: <a href="https://blog.csdn.net/xp178171640/article/details/123634439" target="_blank" rel="noopener">https://blog.csdn.net/xp178171640/article/details/123634439</a></p>
</blockquote>
<ul>
<li>命令<ul>
<li>-h  单位更有好的显示</li>
<li>-s  3 没间隔3秒显示一次</li>
</ul>
</li>
<li>概念<ul>
<li>buff/cache  将磁盘缓存到内存，占用内存大小</li>
<li>swap： 将内存不常用的数据记录在磁盘，缓解内存开销</li>
<li>available = free + buffer + cache</li>
</ul>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wangyj@node1:~/learn$ free -h -s 3</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           251G        5.0G         52G        2.5M        194G        244G</span><br><span class="line">Swap:          8.0G        3.0M        8.0G</span><br></pre></td></tr></table></figure>

<p>/proc/meminfo</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/meminfo</span><br></pre></td></tr></table></figure>

<h5 id="查看进程内存使用情况"><a href="#查看进程内存使用情况" class="headerlink" title="查看进程内存使用情况"></a>查看进程内存使用情况</h5><blockquote>
<p><a href="https://blog.csdn.net/weixin_40482816/article/details/118385737#:~:text=%E9%80%9A%E8%BF%87%EF%BC%9A%20ps%20aux%20%7C%20sort%20-k4%2C4nr%20%7C%20head,%E7%9A%84%20%E5%8D%A0%E7%94%A8%20%E7%8E%87%EF%BC%8C%E7%84%B6%E5%90%8E%E6%8C%89q%E9%94%AE%E5%9B%9E%E5%88%B0%E5%91%BD%E4%BB%A4%E8%A1%8C%E3%80%82%20%E5%8F%A6%E5%A4%96%E8%BF%98%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%20top%20%E5%91%BD%E4%BB%A4%E5%8A%A8%E6%80%81%20%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%20%E3%80%82" target="_blank" rel="noopener">top/ps</a></p>
</blockquote>
<ul>
<li>-d 1 每隔一秒显示一次</li>
<li>查看可执行程序为main的程序</li>
<li>top 中的RES表示物理内存使用情况</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">top -d 1 | grep main</span><br><span class="line">top -d 1 | grep 57166  &#x2F;&#x2F; 57166进程id</span><br><span class="line">top -p 57166 &#x2F;&#x2F; 可以查看全局内存使用情况和57166这个进程的内存使用情况和cpu使用情况</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a href="https://blog.csdn.net/yzf279533105/article/details/107041674" target="_blank" rel="noopener">ps/top</a></p>
</blockquote>
<ul>
<li>{2765180}表示内存使用情况，单位为k</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | grep main&#x2F;57166  &#x2F;&#x2F; 在BSD风格的系统上常用，如macOS</span><br><span class="line">ps -ef | grep main&#x2F;57166   &#x2F;&#x2F; 在SysV风格的系统上常用，如Linux</span><br><span class="line"></span><br><span class="line">wangyj@node1:~&#x2F;learn$ ps aux | grep 57166</span><br><span class="line">wangyj   50538  0.0  0.0  13140  1012 pts&#x2F;306  S+   03:03   0:00 grep --color&#x3D;auto 57166</span><br><span class="line">wangz    57166  118  1.0 7664844 &#123;2765180&#125; ?     Rl   May20 8226:59 .&#x2F;main inde_2_11000_rtree_5.txt query_inde_3.txt opt</span><br></pre></td></tr></table></figure>

<ul>
<li>VmRSS表示内存使用情况</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;57166&#x2F;status  &#x2F;&#x2F;57166进程id</span><br></pre></td></tr></table></figure>

<h5 id="查看设备负载情况"><a href="#查看设备负载情况" class="headerlink" title="查看设备负载情况"></a>查看设备负载情况</h5><blockquote>
<p><a href="https://blog.csdn.net/ylz_yg/article/details/128323631" target="_blank" rel="noopener">https://blog.csdn.net/ylz_yg/article/details/128323631</a></p>
</blockquote>
<ul>
<li>uptime<ul>
<li>当前时间是 “14:32:17”。</li>
<li>系统已经运行了 3 天 5 小时 45 分钟。</li>
<li>有 4 个用户登录到系统。</li>
<li>平均负载值为 0.12（1分钟平均）、0.25（5分钟平均）和 0.30（15分钟平均），这表示系统的负载处于轻负载状态。<ul>
<li>对于计算密集型，平均负载基本等于CPU利用率，例如开启28线程，平均负载可能为28，表示CPU利用率为2800%</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">14:32:17 up 3 days, 5:45, 4 users, load average: 0.12, 0.25, 0.30</span><br></pre></td></tr></table></figure>



<ul>
<li>w<ul>
<li>第一行</li>
</ul>
</li>
<li>top<ul>
<li>第一行</li>
</ul>
</li>
</ul>
<h5 id="过滤所有以abc开头的文件名"><a href="#过滤所有以abc开头的文件名" class="headerlink" title="过滤所有以abc开头的文件名"></a>过滤所有以abc开头的文件名</h5><blockquote>
<p>正则表达式： <a href="https://www.runoob.com/regexp/regexp-syntax.html" target="_blank" rel="noopener">https://www.runoob.com/regexp/regexp-syntax.html</a></p>
</blockquote>
<ul>
<li>ls + grep 的方式</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ls | grep "^L*"</span><br><span class="line"></span><br><span class="line">^ : 以开头</span><br><span class="line"><span class="meta">$</span><span class="bash"> : 以结尾</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 查找以字母 "s" 开头且以字母 "y" 结尾的文件名  .*表示匹配多个任意字符</span><br><span class="line">ls | grep "^s.*y$"</span><br></pre></td></tr></table></figure>

<ul>
<li>find的方式<ul>
<li><code>/path/to/search</code> 是你要搜索的目录的路径。将其替换为你实际希望搜索的目录路径。</li>
<li><code>-type f</code> 表示只搜索文件，不包括目录。<ul>
<li><code>-type f</code>：搜索普通文件（regular files）。</li>
<li><code>-type d</code>：搜索目录（directories）。</li>
<li><code>-type l</code>：搜索符号链接（symbolic links）。</li>
<li><code>-type b</code>：搜索块设备文件（block special files）。</li>
<li><code>-type c</code>：搜索字符设备文件（character special files）。</li>
<li><code>-type p</code>：搜索具名管道（FIFOs，也称为命名管道）。</li>
<li><code>-type s</code>：搜索套接字（sockets)</li>
</ul>
</li>
<li><code>-name &quot;s*y&quot;</code> 指定了文件名的模式。这里使用通配符 <code>*</code> 来匹配以 “s” 开头且以 “y” 结尾的文件名</li>
<li><code>find</code> 将会在指定目录下递归搜索文件，并列出符合条件的文件的路径</li>
</ul>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /path/to/search -type f -name "s*y"</span><br></pre></td></tr></table></figure>



<h5 id="linux的设备有哪几种"><a href="#linux的设备有哪几种" class="headerlink" title="linux的设备有哪几种"></a>linux的设备有哪几种</h5><ol>
<li><strong>字符设备（Character Devices）</strong>：<ul>
<li>这类设备以字符为单位进行输入和输出，通常不考虑数据的结构。例如，键盘、鼠标、终端等字符设备。</li>
</ul>
</li>
<li><strong>块设备（Block Devices）</strong>：<ul>
<li>块设备以块（通常是固定大小的数据块）为单位进行输入和输出。典型的块设备包括硬盘驱动器（HDD）、固态硬盘（SSD）等。</li>
</ul>
</li>
<li><strong>网络设备（Network Devices）</strong>：<ul>
<li>网络设备用于网络通信，包括以太网接口卡（NIC）和无线网卡。它们用于数据包的收发和网络连接。</li>
</ul>
</li>
<li><strong>虚拟设备（Virtual Devices）</strong>：<ul>
<li>虚拟设备是在内核中模拟的设备，用于执行特定任务或提供接口。例如，/dev/null（用于丢弃输出）、/dev/random（生成随机数）等。</li>
</ul>
</li>
</ol>
<h5 id="查看一个进程的运行时间"><a href="#查看一个进程的运行时间" class="headerlink" title="查看一个进程的运行时间"></a>查看一个进程的运行时间</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">top 查看 PID</span><br><span class="line">ps -o etime= -p &lt;PID&gt;</span><br></pre></td></tr></table></figure>



<h4 id="GDB调试"><a href="#GDB调试" class="headerlink" title="GDB调试"></a>GDB调试</h4><blockquote>
<p>查看变量值（结构体、数组，对象等）：<a href="https://blog.csdn.net/wohu1104/article/details/125069987" target="_blank" rel="noopener">https://blog.csdn.net/wohu1104/article/details/125069987</a></p>
<p>GDB处理core dumped: <a href="https://www.freesion.com/article/20821302350/" target="_blank" rel="noopener">https://www.freesion.com/article/20821302350/</a></p>
<p><a href="https://blog.csdn.net/jackhh1/article/details/124434307" target="_blank" rel="noopener">https://blog.csdn.net/jackhh1/article/details/124434307</a></p>
</blockquote>
<blockquote>
<p>概要：<a href="https://blog.csdn.net/challenglistic/article/details/128109026" target="_blank" rel="noopener">https://blog.csdn.net/challenglistic/article/details/128109026</a></p>
<p>具体使用： <a href="https://blog.csdn.net/xubaocai0379/article/details/125876595" target="_blank" rel="noopener">https://blog.csdn.net/xubaocai0379/article/details/125876595</a></p>
<p><a href="https://blog.csdn.net/brahmsjiang/article/details/79318149" target="_blank" rel="noopener">https://blog.csdn.net/brahmsjiang/article/details/79318149</a></p>
<p>查看变量值：<a href="https://blog.csdn.net/wohu1104/article/details/125069987" target="_blank" rel="noopener">https://blog.csdn.net/wohu1104/article/details/125069987</a></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    num += <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"current number is : %d\n"</span>, func(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -g -o test</span><br><span class="line">gdb test</span><br><span class="line">b <span class="number">31</span> <span class="comment">// 31行打断点</span></span><br><span class="line">b fun <span class="comment">// 在函数位置打断点</span></span><br><span class="line"><span class="built_in">run</span> <span class="comment">// 开始调试</span></span><br><span class="line"><span class="built_in">print</span> num <span class="comment">// 显示函数中num的值，必须在打断点，run到断点位置停住后才能查看变量值</span></span><br><span class="line">next <span class="comment">//单步执行 (在停止之后); 跳过函数调用</span></span><br><span class="line"><span class="built_in">step</span> <span class="comment">//单步执行 (在停止之后); 进入函数调用</span></span><br><span class="line">kill <span class="comment">//结束调试</span></span><br><span class="line"><span class="built_in">list</span> <span class="number">8</span><span class="comment">//显示第八行 </span></span><br><span class="line"><span class="built_in">list</span> add <span class="comment">//显示add函数</span></span><br><span class="line">quit <span class="comment">//推出gdb</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">g++ test.cpp -g -o test</span><br><span class="line">gdb test</span><br></pre></td></tr></table></figure>



<h5 id="GDB检查内存泄漏"><a href="#GDB检查内存泄漏" class="headerlink" title="GDB检查内存泄漏"></a>GDB检查内存泄漏</h5><blockquote>
<p>使用Valgrind</p>
</blockquote>
<p><strong>安装Valgrind</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install valgrind</span><br></pre></td></tr></table></figure>

<p><strong>查看内存泄漏</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内存泄漏程序</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 分配内存但没有释放</span></span><br><span class="line">    <span class="keyword">int</span>* dynamicArray = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟程序执行其他操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        dynamicArray[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 程序退出时没有释放分配的内存</span></span><br><span class="line">    <span class="comment">// delete[] dynamicArray;  // 这一行应该被添加来修复内存泄漏</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ test.cpp -g -o test</span><br></pre></td></tr></table></figure>

<p>使用<code>--leak-check=full</code>查看内存泄漏情况</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valgrind --leak-check=full ./test</span><br></pre></td></tr></table></figure>

<p>执行结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 有内存泄漏的输出</span><br><span class="line">&#x3D;&#x3D;6978&#x3D;&#x3D; Memcheck, a memory error detector</span><br><span class="line">&#x3D;&#x3D;6978&#x3D;&#x3D; Copyright (C) 2002-2017, and GNU GPL&#39;d, by Julian Seward et al.</span><br><span class="line">&#x3D;&#x3D;6978&#x3D;&#x3D; Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info</span><br><span class="line">&#x3D;&#x3D;6978&#x3D;&#x3D; Command: .&#x2F;test</span><br><span class="line">&#x3D;&#x3D;6978&#x3D;&#x3D; </span><br><span class="line">&#x3D;&#x3D;6978&#x3D;&#x3D; </span><br><span class="line">&#x3D;&#x3D;6978&#x3D;&#x3D; HEAP SUMMARY:</span><br><span class="line">&#x3D;&#x3D;6978&#x3D;&#x3D;     in use at exit: 40 bytes in 1 blocks  </span><br><span class="line">&#x3D;&#x3D;6978&#x3D;&#x3D;   total heap usage: 2 allocs, 1 frees, 72,744 bytes allocated</span><br><span class="line">&#x3D;&#x3D;6978&#x3D;&#x3D; </span><br><span class="line">&#x3D;&#x3D;6978&#x3D;&#x3D; 40 bytes in 1 blocks are definitely lost in loss record 1 of 1   &#x2F;&#x2F; 提示有40字节数据没有释放内存</span><br><span class="line">&#x3D;&#x3D;6978&#x3D;&#x3D;    at 0x4C3289F: operator new[](unsigned long) (in &#x2F;usr&#x2F;lib&#x2F;valgrind&#x2F;vgpreload_memcheck-amd64-linux.so)</span><br><span class="line">&#x3D;&#x3D;6978&#x3D;&#x3D;    by 0x10879B: main (test.cpp:6)  &#x2F;&#x2F; 申请内存的位置 man函数第6行</span><br><span class="line">&#x3D;&#x3D;6978&#x3D;&#x3D; </span><br><span class="line">&#x3D;&#x3D;6978&#x3D;&#x3D; LEAK SUMMARY:</span><br><span class="line">&#x3D;&#x3D;6978&#x3D;&#x3D;    definitely lost: 40 bytes in 1 blocks</span><br><span class="line">&#x3D;&#x3D;6978&#x3D;&#x3D;    indirectly lost: 0 bytes in 0 blocks</span><br><span class="line">&#x3D;&#x3D;6978&#x3D;&#x3D;      possibly lost: 0 bytes in 0 blocks</span><br><span class="line">&#x3D;&#x3D;6978&#x3D;&#x3D;    still reachable: 0 bytes in 0 blocks</span><br><span class="line">&#x3D;&#x3D;6978&#x3D;&#x3D;         suppressed: 0 bytes in 0 blocks</span><br><span class="line">&#x3D;&#x3D;6978&#x3D;&#x3D; </span><br><span class="line">&#x3D;&#x3D;6978&#x3D;&#x3D; For counts of detected and suppressed errors, rerun with: -v</span><br><span class="line">&#x3D;&#x3D;6978&#x3D;&#x3D; ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 没有内存泄漏的输出</span><br><span class="line">&#x3D;&#x3D;7084&#x3D;&#x3D; Memcheck, a memory error detector</span><br><span class="line">&#x3D;&#x3D;7084&#x3D;&#x3D; Copyright (C) 2002-2017, and GNU GPL&#39;d, by Julian Seward et al.</span><br><span class="line">&#x3D;&#x3D;7084&#x3D;&#x3D; Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info</span><br><span class="line">&#x3D;&#x3D;7084&#x3D;&#x3D; Command: .&#x2F;test</span><br><span class="line">&#x3D;&#x3D;7084&#x3D;&#x3D; </span><br><span class="line">&#x3D;&#x3D;7084&#x3D;&#x3D; </span><br><span class="line">&#x3D;&#x3D;7084&#x3D;&#x3D; HEAP SUMMARY:</span><br><span class="line">&#x3D;&#x3D;7084&#x3D;&#x3D;     in use at exit: 0 bytes in 0 blocks</span><br><span class="line">&#x3D;&#x3D;7084&#x3D;&#x3D;   total heap usage: 2 allocs, 2 frees, 72,744 bytes allocated</span><br><span class="line">&#x3D;&#x3D;7084&#x3D;&#x3D; </span><br><span class="line">&#x3D;&#x3D;7084&#x3D;&#x3D; All heap blocks were freed -- no leaks are possible</span><br><span class="line">&#x3D;&#x3D;7084&#x3D;&#x3D; </span><br><span class="line">&#x3D;&#x3D;7084&#x3D;&#x3D; For counts of detected and suppressed errors, rerun with: -v</span><br><span class="line">&#x3D;&#x3D;7084&#x3D;&#x3D; ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)</span><br></pre></td></tr></table></figure>

<h5 id="GDB查看死锁"><a href="#GDB查看死锁" class="headerlink" title="GDB查看死锁"></a>GDB查看死锁</h5><p>存在死锁的程序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::mutex mutex1;</span><br><span class="line"><span class="built_in">std</span>::mutex mutex2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadFunction1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock1</span><span class="params">(mutex1)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">1</span>));</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock2</span><span class="params">(mutex2)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread 1: Got both locks"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadFunction2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock2</span><span class="params">(mutex2)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">1</span>));</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock1</span><span class="params">(mutex1)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread 2: Got both locks"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(threadFunction1)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t2</span><span class="params">(threadFunction2)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ test.cpp -g -lpthread -o test</span><br></pre></td></tr></table></figure>

<p>执行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb ./test</span><br></pre></td></tr></table></figure>

<p>进入GDB并运行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(gdb) run</span><br><span class="line">Starting program: /home/chuckie/learn/test </span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".</span><br><span class="line">[New Thread 0x7ffff6dff700 (LWP 7285)]</span><br><span class="line">[New Thread 0x7ffff65fe700 (LWP 7286)]</span><br><span class="line"></span><br><span class="line">此时需要ctrl+c退出</span><br></pre></td></tr></table></figure>

<p>显示所有线程信息</p>
<ul>
<li>info thread</li>
<li>存在__lll_lock_wait()的线程大概率是有死锁的线程</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info thread</span><br><span class="line">  Id   Target Id         Frame </span><br><span class="line">* 1    Thread 0x7ffff7fdb740 (LWP 7281) "test" 0x00007ffff7bbcd2d in __GI___pthread_timedjoin_ex (threadid=140737335260928, thread_return=0x0, abstime=0x0, block=&lt;optimized out&gt;)</span><br><span class="line">    at pthread_join_common.c:89</span><br><span class="line">  2    Thread 0x7ffff6dff700 (LWP 7285) "test" __lll_lock_wait () at ../sysdeps/unix/sysv/linux/x86_64/lowlevellock.S:135</span><br><span class="line">  3    Thread 0x7ffff65fe700 (LWP 7286) "test" __lll_lock_wait () at ../sysdeps/unix/sysv/linux/x86_64/lowlevellock.S:135</span><br></pre></td></tr></table></figure>

<p>切换到指定线程查看详情</p>
<ul>
<li>thread 2 : 切换到2号线程</li>
<li>bt(backtrace) ： 查看线程的堆栈跟踪<ul>
<li>可以看到线程2在等待mutex2， 等待位置是test.cpp的11行</li>
<li>线程3在等待mutex1，等待位置是test.cpp的18行</li>
</ul>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">(gdb) thread 2</span><br><span class="line">[Switching to thread 2 (Thread 0x7ffff6dff700 (LWP 7285))]</span><br><span class="line"><span class="meta">#</span><span class="bash">0  __lll_lock_wait () at ../sysdeps/unix/sysv/linux/x86_64/lowlevellock.S:135</span></span><br><span class="line">135     ../sysdeps/unix/sysv/linux/x86_64/lowlevellock.S: No such file or directory.</span><br><span class="line">(gdb) bt</span><br><span class="line"><span class="meta">#</span><span class="bash">0  __lll_lock_wait () at ../sysdeps/unix/sysv/linux/x86_64/lowlevellock.S:135</span></span><br><span class="line"><span class="meta">#</span><span class="bash">1  0x00007ffff7bbe025 <span class="keyword">in</span> __GI___pthread_mutex_lock (mutex=0x5555557581a0 &lt;mutex2&gt;) at ../nptl/pthread_mutex_lock.c:80</span></span><br><span class="line"><span class="meta">#</span><span class="bash">2  0x00005555555550bf <span class="keyword">in</span> __gthread_mutex_lock (__mutex=0x5555557581a0 &lt;mutex2&gt;) at /usr/include/x86_64-linux-gnu/c++/7/bits/gthr-default.h:748</span></span><br><span class="line"><span class="meta">#</span><span class="bash">3  0x0000555555555518 <span class="keyword">in</span> std::mutex::lock (this=0x5555557581a0 &lt;mutex2&gt;) at /usr/include/c++/7/bits/std_mutex.h:103</span></span><br><span class="line"><span class="meta">#</span><span class="bash">4  0x0000555555555594 <span class="keyword">in</span> std::lock_guard&lt;std::mutex&gt;::lock_guard (this=0x7ffff6dfedc0, __m=...) at /usr/include/c++/7/bits/std_mutex.h:162</span></span><br><span class="line"><span class="meta">#</span><span class="bash">5  0x000055555555515b <span class="keyword">in</span> threadFunction1 () at test.cpp:11 // 等待位置是test.cpp的11行</span></span><br><span class="line"><span class="meta">#</span><span class="bash">6  0x0000555555555c6b <span class="keyword">in</span> std::__invoke_impl&lt;void, void (*)()&gt; (__f=@0x55555576ae78: 0x5555555550f7 &lt;threadFunction1()&gt;) at /usr/include/c++/7/bits/invoke.h:60</span></span><br><span class="line"><span class="meta">#</span><span class="bash">7  0x0000555555555a78 <span class="keyword">in</span> std::__invoke&lt;void (*)()&gt; (__fn=@0x55555576ae78: 0x5555555550f7 &lt;threadFunction1()&gt;) at /usr/include/c++/7/bits/invoke.h:95</span></span><br><span class="line"><span class="meta">#</span><span class="bash">8  0x0000555555556146 <span class="keyword">in</span> std::thread::_Invoker&lt;std::tuple&lt;void (*)()&gt; &gt;::_M_invoke&lt;0ul&gt; (this=0x55555576ae78) at /usr/include/c++/7/thread:234</span></span><br><span class="line"><span class="meta">#</span><span class="bash">9  0x0000555555556102 <span class="keyword">in</span> std::thread::_Invoker&lt;std::tuple&lt;void (*)()&gt; &gt;::operator() (this=0x55555576ae78) at /usr/include/c++/7/thread:243</span></span><br><span class="line"><span class="meta">#</span><span class="bash">10 0x00005555555560d2 <span class="keyword">in</span> std::thread::_State_impl&lt;std::thread::_Invoker&lt;std::tuple&lt;void (*)()&gt; &gt; &gt;::_M_run (this=0x55555576ae70) at /usr/include/c++/7/thread:186</span></span><br><span class="line"><span class="meta">#</span><span class="bash">11 0x00007ffff787b4c0 <span class="keyword">in</span> ?? () from /usr/lib/x86_64-linux-gnu/libstdc++.so.6</span></span><br><span class="line"><span class="meta">#</span><span class="bash">12 0x00007ffff7bbb6db <span class="keyword">in</span> start_thread (arg=0x7ffff6dff700) at pthread_create.c:463</span></span><br><span class="line"><span class="meta">#</span><span class="bash">13 0x00007ffff72bf61f <span class="keyword">in</span> <span class="built_in">clone</span> () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:95</span></span><br><span class="line">(gdb) thread 3</span><br><span class="line">[Switching to thread 3 (Thread 0x7ffff65fe700 (LWP 7286))]</span><br><span class="line"><span class="meta">#</span><span class="bash">0  __lll_lock_wait () at ../sysdeps/unix/sysv/linux/x86_64/lowlevellock.S:135</span></span><br><span class="line">135     in ../sysdeps/unix/sysv/linux/x86_64/lowlevellock.S</span><br><span class="line">(gdb) bt</span><br><span class="line"><span class="meta">#</span><span class="bash">0  __lll_lock_wait () at ../sysdeps/unix/sysv/linux/x86_64/lowlevellock.S:135</span></span><br><span class="line"><span class="meta">#</span><span class="bash">1  0x00007ffff7bbe025 <span class="keyword">in</span> __GI___pthread_mutex_lock (mutex=0x555555758160 &lt;mutex1&gt;) at ../nptl/pthread_mutex_lock.c:80</span></span><br><span class="line"><span class="meta">#</span><span class="bash">2  0x00005555555550bf <span class="keyword">in</span> __gthread_mutex_lock (__mutex=0x555555758160 &lt;mutex1&gt;) at /usr/include/x86_64-linux-gnu/c++/7/bits/gthr-default.h:748</span></span><br><span class="line"><span class="meta">#</span><span class="bash">3  0x0000555555555518 <span class="keyword">in</span> std::mutex::lock (this=0x555555758160 &lt;mutex1&gt;) at /usr/include/c++/7/bits/std_mutex.h:103</span></span><br><span class="line"><span class="meta">#</span><span class="bash">4  0x0000555555555594 <span class="keyword">in</span> std::lock_guard&lt;std::mutex&gt;::lock_guard (this=0x7ffff65fddc0, __m=...) at /usr/include/c++/7/bits/std_mutex.h:162</span></span><br><span class="line"><span class="meta">#</span><span class="bash">5  0x0000555555555248 <span class="keyword">in</span> threadFunction2 () at test.cpp:18 //等待位置是test.cpp的18行</span></span><br><span class="line"><span class="meta">#</span><span class="bash">6  0x0000555555555c6b <span class="keyword">in</span> std::__invoke_impl&lt;void, void (*)()&gt; (__f=@0x55555576afc8: 0x5555555551e4 &lt;threadFunction2()&gt;) at /usr/include/c++/7/bits/invoke.h:60</span></span><br><span class="line"><span class="meta">#</span><span class="bash">7  0x0000555555555a78 <span class="keyword">in</span> std::__invoke&lt;void (*)()&gt; (__fn=@0x55555576afc8: 0x5555555551e4 &lt;threadFunction2()&gt;) at /usr/include/c++/7/bits/invoke.h:95</span></span><br><span class="line"><span class="meta">#</span><span class="bash">8  0x0000555555556146 <span class="keyword">in</span> std::thread::_Invoker&lt;std::tuple&lt;void (*)()&gt; &gt;::_M_invoke&lt;0ul&gt; (this=0x55555576afc8) at /usr/include/c++/7/thread:234</span></span><br><span class="line"><span class="meta">#</span><span class="bash">9  0x0000555555556102 <span class="keyword">in</span> std::thread::_Invoker&lt;std::tuple&lt;void (*)()&gt; &gt;::operator() (this=0x55555576afc8) at /usr/include/c++/7/thread:243</span></span><br><span class="line"><span class="meta">#</span><span class="bash">10 0x00005555555560d2 <span class="keyword">in</span> std::thread::_State_impl&lt;std::thread::_Invoker&lt;std::tuple&lt;void (*)()&gt; &gt; &gt;::_M_run (this=0x55555576afc0) at /usr/include/c++/7/thread:186</span></span><br><span class="line"><span class="meta">#</span><span class="bash">11 0x00007ffff787b4c0 <span class="keyword">in</span> ?? () from /usr/lib/x86_64-linux-gnu/libstdc++.so.6</span></span><br><span class="line"><span class="meta">#</span><span class="bash">12 0x00007ffff7bbb6db <span class="keyword">in</span> start_thread (arg=0x7ffff65fe700) at pthread_create.c:463</span></span><br><span class="line"><span class="meta">#</span><span class="bash">13 0x00007ffff72bf61f <span class="keyword">in</span> <span class="built_in">clone</span> () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:95</span></span><br></pre></td></tr></table></figure>

<h5 id="GDB查看调用堆栈"><a href="#GDB查看调用堆栈" class="headerlink" title="GDB查看调用堆栈"></a>GDB查看调用堆栈</h5><p>测试程序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">innerFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> inner_variable = <span class="number">42</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Inside innerFunction()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outerFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> outer_variable = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Inside outerFunction()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    innerFunction();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> main_variable = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Inside main()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    outerFunction();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译执行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">g++ test.cpp -g -o test</span><br><span class="line">gdb ./test</span><br><span class="line">b innerFunction //打断点，便于观察堆栈情况</span><br><span class="line">run</span><br><span class="line">bt</span><br></pre></td></tr></table></figure>

<p>堆栈信息</p>
<ul>
<li>#后是每一个函数调用的唯一的帧编号</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) bt</span><br><span class="line">#0  innerFunction () at test.cpp:4</span><br><span class="line">#1  0x0000555555554930 in outerFunction () at test.cpp:11</span><br><span class="line">#2  0x000055555555496f in main () at test.cpp:17</span><br></pre></td></tr></table></figure>

<p>查看特定帧的信息</p>
<ul>
<li>frame 帧编号</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) frame 1</span><br><span class="line">#1  0x0000555555554930 in outerFunction () at test.cpp:11</span><br><span class="line">11          innerFunction();</span><br></pre></td></tr></table></figure>



<h5 id="GDB处理core"><a href="#GDB处理core" class="headerlink" title="GDB处理core"></a>GDB处理core</h5><p>源码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* ptr = <span class="literal">nullptr</span>; <span class="comment">// 故意将指针设置为 nullptr</span></span><br><span class="line">    *ptr = <span class="number">42</span>;          <span class="comment">// 尝试在空指针上解引用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译并执行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -g -o test test.cpp</span><br><span class="line">./test   // 程序将崩溃，并且在当前工作目录中生成一个名为 core 的核心转储文件</span><br></pre></td></tr></table></figure>

<p>使用GDB加载程序和核心转储文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb ./test core   // 这将启动GDB并加载程序和 core 文件</span><br></pre></td></tr></table></figure>

<p>查看崩溃时的堆栈跟踪</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) bt</span><br></pre></td></tr></table></figure>

<p>这将显示堆栈跟踪，显示了程序崩溃的地方。在这种情况下，您应该看到类似以下的输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#0  0x0000555555555162 in main () at test.cpp:5</span><br><span class="line">这表明程序在 main 函数的第5行崩溃</span><br></pre></td></tr></table></figure>

<p>查看变量状态（可选）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) print ptr</span><br></pre></td></tr></table></figure>



<p><strong>核心文件生成路径问题</strong></p>
<p>查看核心文件生成是否启用</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ulimit -c</span><br><span class="line">// 没启用返回0</span><br><span class="line">// 启用返回unlimited</span><br></pre></td></tr></table></figure>

<p>设置为启用，默认情况下core生成在当前目录下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -c unlimited</span><br></pre></td></tr></table></figure>

<p>若当前目录下没有生成core文件，则需要设置core文件的生成路径</p>
<ul>
<li><code>/home/chuckie/learn/</code> 就是指定的路径,生成的文件名为core</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sh -c 'echo "/home/chuckie/learn/core" &gt; /proc/sys/kernel/core_pattern'</span><br></pre></td></tr></table></figure>



<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h5 id="出现3次的元素"><a href="#出现3次的元素" class="headerlink" title="出现3次的元素"></a>出现3次的元素</h5><p>一个数字一个元素出现一次，其它元素出现3次，找到出现1次的元素</p>
<ul>
<li>记录每个比特位1出现的次数，用32大小的数组存储，每个位对3取余，余1则这个1一定是出现一次的数字的</li>
</ul>
<h5 id="移动k位"><a href="#移动k位" class="headerlink" title="移动k位"></a>移动k位</h5><p>一个数组，左移k位， 1 2 3 4 5 6 7 –&gt; 3 4 5 6 7 1 2 (k = 2) O（1）时间复杂度 O(n)空间复杂度</p>
<ul>
<li>[0-k-1]反转，[k, n-1]反转， 整个数组反转</li>
</ul>
<h5 id="找高频元素"><a href="#找高频元素" class="headerlink" title="找高频元素"></a>找高频元素</h5><p>给定一个有序数组，问是否存在出现次数大于1/3的元素</p>
<ul>
<li>因为出现次数大于1/3 所以这个元素一定出现在1/3位置或2/3位置，再二分查找该元素起始位置，确定范围</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 0 1 2 3 4 5 6 7 8  n = 9</span></span><br><span class="line">  <span class="comment">// 1 2 3 4 5 6 7 8 9</span></span><br><span class="line">  <span class="comment">//       *   *</span></span><br><span class="line">  <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">int</span> left = arr[n/<span class="number">3</span>]; <span class="comment">// 9/3 = 3 正好是1/3位置索引</span></span><br><span class="line">  <span class="keyword">int</span> right = arr[n - n/<span class="number">3</span>]; <span class="comment">// 9 - 3 - 1 = 5  正好2/3位置的索引</span></span><br><span class="line">  <span class="comment">// lower_bound找到大于等于该值的第一个元素的位置的迭代器</span></span><br><span class="line">  <span class="keyword">auto</span> itll = lower_bound(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), left); <span class="comment">// 找到1/3元素左边的起始位置，包含该位置</span></span><br><span class="line">  <span class="comment">// upper_bound找到大于该值的第一个元素的位置的迭代器</span></span><br><span class="line">  <span class="keyword">auto</span> itlr = upper_bound(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), left); <span class="comment">// 找到1/3元素右边的结束位置，不包含该位置</span></span><br><span class="line">  <span class="keyword">if</span>( itlr - itll &gt; n/<span class="number">3</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// lower_bound找到大于等于该值的第一个元素的位置的迭代器</span></span><br><span class="line">  <span class="keyword">auto</span> itrl = lower_bound(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), right); <span class="comment">// 找到2/3元素左边的起始位置，包含该位置</span></span><br><span class="line">  <span class="comment">// upper_bound找到大于该值的第一个元素的位置的迭代器</span></span><br><span class="line">  <span class="keyword">auto</span> itrr = upper_bound(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), right); <span class="comment">// 找到2/3元素右边的结束位置，不包含该位置</span></span><br><span class="line">  <span class="keyword">if</span>( itrr - itrl &gt; n/<span class="number">3</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(check(arr1))&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"yes"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"no"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="约瑟夫环"><a href="#约瑟夫环" class="headerlink" title="约瑟夫环"></a>约瑟夫环</h5><blockquote>
<p><a href="https://blog.csdn.net/melonyzzZ/article/details/127787472" target="_blank" rel="noopener">约瑟夫环</a></p>
<p><a href="https://blog.csdn.net/K346K346/article/details/50992397?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169537162716800186592545%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=169537162716800186592545&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-50992397-null-null.142^v94^insert_down1&utm_term=%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92&spm=1018.2226.3001.4187" target="_blank" rel="noopener">动态规划处理与瑟夫环</a></p>
</blockquote>
<ul>
<li><p>阿里优酷一面算法</p>
<ul>
<li>输入n表示n个人, 从0到n-1编号，输入m, 从0编号开始报数，报数从1开始，报数到m则退出，再从1开始报数，最终留下的人获胜</li>
<li>仍然输入m，输入任意n，输出获胜的编号，时间复杂度要O(n)</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastRemainingDP</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n, <span class="keyword">unsigned</span> <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">1</span>||m&lt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> last=<span class="number">0</span>; <span class="comment">//n=1,最后移出环的元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)</span><br><span class="line">        last=(last+m)%i;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>得物笔试<ul>
<li>输入n表示n个人, 从1到n编号，输入m, 从1编号开始报数，报数从1开始，报数到m则退出，再从1开始报数，报到最右边则再往左报数，报到最左边则再继续往右报数，最终留下的人获胜</li>
<li>例如 n = 3, m = 4<ul>
<li>1 2 3 再往左报数 2  则2先被剔除  变为1 3</li>
<li>继续从删除的位置2往左报数  1 再往右 3 再往左1 再往右 3  则3被剔除，剩余1</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="快速幂溢出问题"><a href="#快速幂溢出问题" class="headerlink" title="快速幂溢出问题"></a>快速幂溢出问题</h5><blockquote>
<p><a href="https://blog.csdn.net/liangllhahaha/article/details/82119378" target="_blank" rel="noopener">快速幂/快速乘</a></p>
<p><a href="https://blog.csdn.net/m0_62556295/article/details/127211930" target="_blank" rel="noopener">快速幂溢出</a></p>
<p>重要定理：(a*b)%p = (a%p) *( b%p)%p</p>
<p>重要定理：(a+b)%p = ((a%p) + ( b%p))%p</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; mp + x</span><br><span class="line">b &#x3D; np + y</span><br><span class="line">(a*b)%p &#x3D; ((mp + x)*(np + y))%p &#x3D; (mnp^2 + mpy + npx + xy)%p &#x3D; xy%p</span><br><span class="line">(a%p) *( b%p)%p &#x3D; x * y %p &#x3D; xy%p</span><br><span class="line"></span><br><span class="line">(a+b)%p &#x3D; ((mp + x)+(np + y))%p &#x3D; (mp + np + x + y)%p &#x3D; (x+y)%p</span><br><span class="line">((a%p) + ( b%p))%p &#x3D; (x + y)%p</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速幂</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> a,b,p,ans;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;p;</span><br><span class="line">    </span><br><span class="line">    a%=p;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b%<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans=(ans*a)%p;</span><br><span class="line">        &#125;</span><br><span class="line">        a = (a*a)%p;</span><br><span class="line">        b/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a^b = a^2^0 * a^2^1 * .... * a^2^n</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">ksm</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b, <span class="keyword">long</span> <span class="keyword">long</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>, base = a%p;</span><br><span class="line">    <span class="keyword">while</span>(b != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            ans = (ans*base)%p;</span><br><span class="line">        &#125;</span><br><span class="line">        base = (base*base)%p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速乘</span></span><br><span class="line"><span class="comment">// a*b = a*2^0 + a*2^1+....+a*2^n</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">ksc</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>, base = a;</span><br><span class="line">    <span class="keyword">while</span>(b != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            ans = ans + base;</span><br><span class="line">        &#125;</span><br><span class="line">        base = base + base;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 防止溢出</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">ksc</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b, <span class="keyword">long</span> <span class="keyword">long</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>, base = a;</span><br><span class="line">    <span class="keyword">while</span>(b != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            ans = (ans + base)%p;</span><br><span class="line">        &#125;</span><br><span class="line">        base = (base + base)%p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h5><ul>
<li>宽度优先，深度优先可能爆空间</li>
<li>华为4.19 第二题</li>
</ul>
<h5 id="差分数组"><a href="#差分数组" class="headerlink" title="差分数组"></a>差分数组</h5><ul>
<li>华为4.19 第一题</li>
</ul>
<h5 id="有序集合求交"><a href="#有序集合求交" class="headerlink" title="有序集合求交"></a>有序集合求交</h5><blockquote>
<p>多个有序数组排序也用优先队列</p>
</blockquote>
<ul>
<li>多个有序集合求交<ul>
<li>用优先队列</li>
<li>和堆顶相同<ul>
<li>计数</li>
<li>计数达到m(m个队列)则是交集元素<ul>
<li>堆顶出队，堆顶下一个元素入队，计数归零</li>
</ul>
</li>
</ul>
</li>
<li>大于堆顶元素<ul>
<li>则入队, 堆顶出队，计数归0</li>
</ul>
</li>
<li>小于堆顶元素<ul>
<li>则抛弃，继续考察下一个元素</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> cmp = [](ListNode* l1, ListNode* l2)&#123;</span><br><span class="line">            <span class="keyword">return</span> l1-&gt;val &gt; l2-&gt;val;</span><br><span class="line">        &#125;;</span><br><span class="line">        priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, decltype(cmp)&gt; q(cmp);</span><br><span class="line">        <span class="comment">// int val = lists[0]-&gt;val;</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode* p = dummy;</span><br><span class="line">        <span class="keyword">int</span> n = lists.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!lists[i])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>; <span class="comment">// 有空数组，不可能有交集</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        q.push(lists[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">while</span>(flag &amp;&amp; !q.empty())&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"--------------"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="comment">// 每一轮for都试图找到n个相同的元素</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">                <span class="keyword">auto</span> cur = q.top();</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">"  "</span>&lt;&lt;cur-&gt;val&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">while</span>(lists[i] &amp;&amp; lists[i]-&gt;val &lt; cur-&gt;val)&#123;</span><br><span class="line">                    lists[i] = lists[i]-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!lists[i])&#123; <span class="comment">// 已经有数组为空，且count还小于n, 不可能再有交集直接结束循环</span></span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(lists[i]-&gt;val == cur-&gt;val)&#123;</span><br><span class="line">                    ++count;</span><br><span class="line">                    <span class="keyword">if</span>(count == n)&#123;</span><br><span class="line">                        p-&gt;next = cur;</span><br><span class="line">                        p = p-&gt;next;</span><br><span class="line">                        q.pop();</span><br><span class="line">                        count = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">if</span>(cur-&gt;next) q.push(cur-&gt;next);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(lists[i]-&gt;val &gt; cur-&gt;val)&#123;</span><br><span class="line">                    q.push(lists[i]);</span><br><span class="line">                    q.pop();</span><br><span class="line">                    count = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"========"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h5 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">list</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; ls;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">list</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;::iterator&gt; mp;</span><br><span class="line">    <span class="keyword">int</span> cap;</span><br><span class="line">    LRUCache(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        cap = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(mp.count(key) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">auto</span> temp = *mp[key];</span><br><span class="line">            ls.erase(mp[key]);</span><br><span class="line">            ls.push_front(temp);</span><br><span class="line">            mp[key] = ls.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">return</span> temp.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(mp.count(key) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            ls.erase(mp[key]);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ls.<span class="built_in">size</span>() == cap)&#123;</span><br><span class="line">            <span class="keyword">int</span> key = ls.back().first;</span><br><span class="line">            ls.pop_back();</span><br><span class="line">            mp.erase(key);</span><br><span class="line">        &#125;</span><br><span class="line">        ls.push_front(&#123;key, value&#125;);</span><br><span class="line">        mp[key] = ls.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="华为-1"><a href="#华为-1" class="headerlink" title="华为"></a>华为</h5><p><a href="https://leetcode.cn/problems/maximum-subarray/" target="_blank" rel="noopener">53. 最大子数组和</a></p>
<p><a href="https://leetcode.cn/problems/advantage-shuffle/" target="_blank" rel="noopener">870. 优势洗牌</a></p>
<h5 id="int数字反转"><a href="#int数字反转" class="headerlink" title="int数字反转"></a>int数字反转</h5><ul>
<li>要求在32为系统上实现反转，反转越界则丢弃高位</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 案例</span></span><br><span class="line"><span class="number">123</span> --&gt; <span class="number">321</span></span><br><span class="line"><span class="number">-123</span> --&gt; <span class="number">-321</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 思路，直接使用int：通常占用4字节，范围是-2,147,483,648到2,147,483,647</span></span><br><span class="line"><span class="comment">// 用数组存储每一位，并反转，然后比较，越界则丢弃</span></span><br></pre></td></tr></table></figure>



<h2 id="node-js"><a href="#node-js" class="headerlink" title="node.js"></a>node.js</h2><p>导入库的语法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="built_in">require</span>(<span class="string">"./main.js"</span>)</span><br></pre></td></tr></table></figure>

<p>Node.js可以使用ES6的导入语法，来引入模块。ES6中提供了import和export两种方式来实现模块的导入和导出</p>
<h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">熟练使用c++基础语言进行研发，多线程、多进程、内存共享、网络通信编程技术；</span><br><span class="line"></span><br><span class="line">熟练使用脚本语言（Perl&#x2F;python&#x2F;php，至少一种），有丰富的Unix&#x2F;Linux环境下开发经验</span><br></pre></td></tr></table></figure>

<h2 id="开放问题"><a href="#开放问题" class="headerlink" title="开放问题"></a>开放问题</h2><p>主管：<strong>当你和上级意见不一的时候怎么处理。</strong></p>
<p>我：平时会和组员同学有分歧，通过协商基本都能解决，但是我们是平级关系。现实中我没有遇到过和上级产生矛盾的情形，因为遇到的上级最多也就是老师。那我假想有这样一个情形，我认为我会分析上级态度，如果不是商量的态度就先执行，然后另找机会和上级谈自己的看法；如果上级本身是举棋不定的商量态度，我会当场和他/她分享我的不同意见。</p>
<h2 id="RTMP"><a href="#RTMP" class="headerlink" title="RTMP"></a>RTMP</h2><p>交互流程</p>
<ul>
<li><p>三次握手</p>
<ul>
<li>协商协议版本</li>
<li>身份验证<ul>
<li>简单：随机数</li>
<li>复杂：加密</li>
</ul>
</li>
</ul>
</li>
<li><p>创建网络链接</p>
<ul>
<li>connect (命令消息)</li>
<li>交互控制信息 (协议控制消息)<ul>
<li>设置块大小（Set Chunk Size ，Message Type ID = 1）</li>
<li>应答窗口大小（Window Acknowledgement Size，Message Type ID = 5）</li>
<li>设置流带宽（Set Peer Bandwidth，Message Type ID = 6）</li>
</ul>
</li>
</ul>
</li>
<li><p>创建流</p>
<ul>
<li>createStream (网络链接命令消息)<ul>
<li>对端用_result应答</li>
</ul>
</li>
<li>publish (网络流命令)<ul>
<li>对端用onStatus应答</li>
</ul>
</li>
</ul>
</li>
<li><p>传输数据</p>
</li>
<li><p>删除流</p>
<ul>
<li>deleteStream(网络流命令)<ul>
<li>对端用onStatus应答</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>协议控制信息</p>
<ul>
<li>设置块大小（Set Chunk Size ，Message Type ID = 1）</li>
<li>中断消息（Abort Message，Message Type ID = 2）</li>
<li>应答消息（Acknowledgement，Message Type ID = 3）</li>
<li>应答窗口大小（Window Acknowledgement Size，Message Type ID = 5）</li>
<li>设置流带宽（Set Peer Bandwidth，Message Type ID = 6）</li>
</ul>
<p>命令消息（Command Message）</p>
<ul>
<li>网络连接命令（NetConnection Commands）<ul>
<li>connect</li>
<li>call</li>
<li>createStream</li>
<li>网络链接命令对端的应答一般为：<code>_result，_error</code></li>
</ul>
</li>
<li>网络流命令（NetStream）<ul>
<li>网络流命令对端的应答一般为：onStatus</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>play</td>
<td>播放</td>
</tr>
<tr>
<td>play2</td>
<td>播放2</td>
</tr>
<tr>
<td>deleteStream</td>
<td>删除流</td>
</tr>
<tr>
<td>closeStream</td>
<td>关闭流</td>
</tr>
<tr>
<td>receiveAudio</td>
<td>接收音频</td>
</tr>
<tr>
<td>receiveVideo</td>
<td>接收视频</td>
</tr>
<tr>
<td>publish</td>
<td>推流</td>
</tr>
<tr>
<td>seek</td>
<td>定位</td>
</tr>
<tr>
<td>pause</td>
<td>暂停</td>
</tr>
</tbody></table>
<p>用户控制信息</p>
<ul>
<li>Stream Begin 1</li>
</ul>
<p>Chunk类型</p>
<ul>
<li>chunk type = 0<ul>
<li>Length</li>
<li>Timestamp</li>
<li>Message Type Id</li>
<li>Message Stream Id</li>
</ul>
</li>
<li>chunk type = 1<ul>
<li>Length</li>
<li>Timestamp delta</li>
<li>Message Type Id</li>
</ul>
</li>
<li>chunk type = 2<ul>
<li>Timestamp delta</li>
</ul>
</li>
<li>chunk type = 3<ul>
<li>无</li>
<li>一个message拆分成多个chunk时</li>
</ul>
</li>
</ul>
<h2 id="实习"><a href="#实习" class="headerlink" title="实习"></a>实习</h2><ol>
<li>中心汇聚循环回源检测</li>
<li>原子函数配置鉴权链可视化，java环境的搭建<ol>
<li>看论坛，请教同事，请教导师，主要问题是华为环境</li>
<li>学习SpringBoot, MonogoDB</li>
</ol>
</li>
<li>RTMP<ol>
<li>配置开关，找案例，c模块的动态和静态配置，lua模块的配置解析</li>
</ol>
</li>
<li>I帧重复SPS/PPS去重<ol>
<li>处理Annexb格式时，在处理的位置没有数据，发现是前面模块的判断有问题，在判断是Annexb格式时就直接return了，本质原本的代码写的很有局限性，不通用</li>
<li>有的sps/pps可以识别到，有的就不行，发现是原本的代码在解析nale时，只解析了第一个nale，如果时sps/pps/vps则判断为是携带这些信息的I帧，但是其实应该遍历查找所有nale是否携带sps/pps/vps来判断</li>
</ol>
</li>
</ol>
<p>tcpdump、wireshark、flv</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/01/26/C++/c++algo/" rel="prev" title="C++algorithm">
      <i class="fa fa-chevron-left"></i> C++algorithm
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/01/26/C++/c++bagu/" rel="next" title="C++八股总结">
      C++八股总结 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#todo"><span class="nav-text">todo</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#c"><span class="nav-text">c++</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#对象开辟堆区注意事项"><span class="nav-text">对象开辟堆区注意事项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#移动构造函数导致默认”-”构造不能用"><span class="nav-text">移动构造函数导致默认”&#x3D;”构造不能用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#返回值const引用-待解决"><span class="nav-text">返回值const引用  待解决</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#八股文"><span class="nav-text">八股文</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#面试宝典"><span class="nav-text">面试宝典</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#操作系统"><span class="nav-text">操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#prelearn"><span class="nav-text">prelearn</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#马士兵操作系统"><span class="nav-text">马士兵操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#内存管理"><span class="nav-text">内存管理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#分布式"><span class="nav-text">分布式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#STL"><span class="nav-text">STL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#六大部件"><span class="nav-text">六大部件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#array"><span class="nav-text">array</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vector"><span class="nav-text">vector</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stack"><span class="nav-text">stack</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map"><span class="nav-text">map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#unordered-map"><span class="nav-text">unordered_map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#priority-queue"><span class="nav-text">priority_queue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#set、map"><span class="nav-text">set、map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#相关知识点"><span class="nav-text">相关知识点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#move-左值-右值"><span class="nav-text">move 左值 右值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#迭代器移动"><span class="nav-text">迭代器移动</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数据库"><span class="nav-text">数据库</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#设计模式"><span class="nav-text">设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#单例模式"><span class="nav-text">单例模式</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#多线程"><span class="nav-text">多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#线程池"><span class="nav-text">线程池</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#面试问题"><span class="nav-text">面试问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#c-1"><span class="nav-text">c++</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#智能指针"><span class="nav-text">智能指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vector存储对象"><span class="nav-text">vector存储对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#虚函数表和虚函数指针"><span class="nav-text">虚函数表和虚函数指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#placement-new"><span class="nav-text">placement new</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#delete-与-delete"><span class="nav-text">delete[] 与 delete</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#shared-ptr与析构"><span class="nav-text">shared_ptr与析构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#智能指针的使用场景"><span class="nav-text">智能指针的使用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多态指针转型"><span class="nav-text">多态指针转型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内存共享"><span class="nav-text">内存共享</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#宏、const和static"><span class="nav-text">宏、const和static</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#STL内存分配"><span class="nav-text">STL内存分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类如何只能静态分配和只能动态分配"><span class="nav-text">类如何只能静态分配和只能动态分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#单例模式-1"><span class="nav-text">单例模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#运算符重载"><span class="nav-text">运算符重载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#c-11对象自带的函数"><span class="nav-text">c++11对象自带的函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#const修饰成员函数"><span class="nav-text">const修饰成员函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#A-p-NULL"><span class="nav-text">A* p &#x3D; NULL</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#阿里二面"><span class="nav-text">阿里二面</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#华为"><span class="nav-text">华为</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#计算机上网络"><span class="nav-text">计算机上网络</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#网络编程"><span class="nav-text">网络编程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP与UDP"><span class="nav-text">TCP与UDP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP通信流程"><span class="nav-text">TCP通信流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UDP通信流程"><span class="nav-text">UDP通信流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tcp第三次握手失败"><span class="nav-text">tcp第三次握手失败</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#拥塞控制-流量控制"><span class="nav-text">拥塞控制&#x2F;流量控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tcp粘包和拆包"><span class="nav-text">tcp粘包和拆包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#select"><span class="nav-text">select</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#poll"><span class="nav-text">poll</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#epoll"><span class="nav-text">epoll</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ET-LT"><span class="nav-text">ET&#x2F;LT</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#epoll反应堆"><span class="nav-text">epoll反应堆</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基础问题"><span class="nav-text">基础问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#http1-0-1-1-2-3区别"><span class="nav-text">http1.0&#x2F;1.1&#x2F;2&#x2F;3区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#https握手过程"><span class="nav-text">https握手过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#浏览器输入url"><span class="nav-text">浏览器输入url</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#reset使用场景"><span class="nav-text">reset使用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么情况下会断开tcp"><span class="nav-text">什么情况下会断开tcp</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#操作系统-1"><span class="nav-text">操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#进程同步方式："><span class="nav-text">进程同步方式：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程间通信方式："><span class="nav-text">进程间通信方式：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程间同步方式："><span class="nav-text">线程间同步方式：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#乐观锁和悲观锁"><span class="nav-text">乐观锁和悲观锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#死锁条件"><span class="nav-text">死锁条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#程序运行流程"><span class="nav-text">程序运行流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#局部性原理"><span class="nav-text">局部性原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#调度算法"><span class="nav-text">调度算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据库-1"><span class="nav-text">数据库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据结构"><span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#大数据量"><span class="nav-text">大数据量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SQL"><span class="nav-text">SQL</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#linux"><span class="nav-text">linux</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#查看内存使用情况"><span class="nav-text">查看内存使用情况</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#查看进程内存使用情况"><span class="nav-text">查看进程内存使用情况</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#查看设备负载情况"><span class="nav-text">查看设备负载情况</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#过滤所有以abc开头的文件名"><span class="nav-text">过滤所有以abc开头的文件名</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#linux的设备有哪几种"><span class="nav-text">linux的设备有哪几种</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#查看一个进程的运行时间"><span class="nav-text">查看一个进程的运行时间</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GDB调试"><span class="nav-text">GDB调试</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#GDB检查内存泄漏"><span class="nav-text">GDB检查内存泄漏</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#GDB查看死锁"><span class="nav-text">GDB查看死锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#GDB查看调用堆栈"><span class="nav-text">GDB查看调用堆栈</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#GDB处理core"><span class="nav-text">GDB处理core</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法"><span class="nav-text">算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#出现3次的元素"><span class="nav-text">出现3次的元素</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#移动k位"><span class="nav-text">移动k位</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#找高频元素"><span class="nav-text">找高频元素</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#约瑟夫环"><span class="nav-text">约瑟夫环</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#快速幂溢出问题"><span class="nav-text">快速幂溢出问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#最短路径"><span class="nav-text">最短路径</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#差分数组"><span class="nav-text">差分数组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#有序集合求交"><span class="nav-text">有序集合求交</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#LRU"><span class="nav-text">LRU</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#华为-1"><span class="nav-text">华为</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#int数字反转"><span class="nav-text">int数字反转</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#node-js"><span class="nav-text">node.js</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#要求"><span class="nav-text">要求</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#开放问题"><span class="nav-text">开放问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RTMP"><span class="nav-text">RTMP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实习"><span class="nav-text">实习</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Chuckie"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Chuckie</p>
  <div class="site-description" itemprop="description">Bright future</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">116</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">57</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">100</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/ChuckieWill" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ChuckieWill" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/codewyj.163.com" title="E-Mail → codewyj.163.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.jianshu.com/u/de627226656c" title="https:&#x2F;&#x2F;www.jianshu.com&#x2F;u&#x2F;de627226656c" rel="noopener" target="_blank">简书</a>
        </li>
    </ul>
  </div>

      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="/images/me.png"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chuckie</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">1.1m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">17:04</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
