<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="hot 100 1  两数之和  时间复杂度O（n）,空间O（n） 哈希map, find, count(时间复杂度都为O(1), 最坏情况为O(n))   2 两数相加 链表  初始化pre,每次相加包括pre, 整除10更新pre   3 无重复字符的最长子串  滑动窗口+hashset   4 寻找两个正序数组的中位数  二分查找，边界，各种情况分析，易错，复习   5  最长回文子串  从">
<meta property="og:type" content="article">
<meta property="og:title" content="算法总结c++版本">
<meta property="og:url" content="http://yoursite.com/2022/01/26/C++/hot100/index.html">
<meta property="og:site_name" content="Chuckie&#39;s Blog">
<meta property="og:description" content="hot 100 1  两数之和  时间复杂度O（n）,空间O（n） 哈希map, find, count(时间复杂度都为O(1), 最坏情况为O(n))   2 两数相加 链表  初始化pre,每次相加包括pre, 整除10更新pre   3 无重复字符的最长子串  滑动窗口+hashset   4 寻找两个正序数组的中位数  二分查找，边界，各种情况分析，易错，复习   5  最长回文子串  从">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/hot100/image-20221117203645300.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/hot100/image-20221117203736258.png">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/20260225-f580a07018d6c8c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/627/format/webp">
<meta property="article:published_time" content="2022-01-26T06:43:17.000Z">
<meta property="article:modified_time" content="2024-11-13T14:07:00.161Z">
<meta property="article:author" content="Chuckie">
<meta property="article:tag" content="算法总结">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2022/01/26/C++/hot100/image-20221117203645300.png">

<link rel="canonical" href="http://yoursite.com/2022/01/26/C++/hot100/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>算法总结c++版本 | Chuckie's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Chuckie's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/01/26/C++/hot100/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Chuckie">
      <meta itemprop="description" content="Bright future">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chuckie's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          算法总结c++版本
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-26 14:43:17" itemprop="dateCreated datePublished" datetime="2022-01-26T14:43:17+08:00">2022-01-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-13 22:07:00" itemprop="dateModified" datetime="2024-11-13T22:07:00+08:00">2024-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>27k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>24 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="hot-100"><a href="#hot-100" class="headerlink" title="hot 100"></a>hot 100</h1><ul>
<li><p>1  两数之和</p>
<ul>
<li>时间复杂度O（n）,空间O（n）</li>
<li>哈希map, find, count(时间复杂度都为O(1), 最坏情况为O(n))</li>
</ul>
</li>
<li><p>2 两数相加 链表</p>
<ul>
<li>初始化pre,每次相加包括pre, 整除10更新pre</li>
</ul>
</li>
<li><p>3 无重复字符的最长子串</p>
<ul>
<li>滑动窗口+hashset</li>
</ul>
</li>
<li><p>4 寻找两个正序数组的中位数</p>
<ul>
<li>二分查找，边界，各种情况分析，易错，复习</li>
</ul>
</li>
<li><p>5  最长回文子串</p>
<ul>
<li>从中心往两边扩展，分为偶数和奇数情况</li>
</ul>
</li>
<li><p>10 正则表达式匹配</p>
<ul>
<li>动态规划</li>
</ul>
</li>
<li><p>11 盛最多水的容器</p>
<ul>
<li>双指针，策略：矮的往前走可能变大，高的往前走，由于高度还是矮的决定所以只能变小，所以最终，每次选择矮的一侧往前走，并更新面积</li>
</ul>
</li>
<li><p>15  三数之和</p>
<ul>
<li>排序+双指针， 三层循环的内两层可以改为相向逼近的双指针</li>
<li>注意内层元素大于等于外层，但内外层可以可以元素相同，同层不能元素相同，还有双指针相遇时可以提前结束循环，细节很多，易错，复习</li>
</ul>
</li>
<li><p>17 电话号码的字母组合</p>
<ul>
<li>回溯，递归</li>
</ul>
</li>
<li><p>19 删除链表的倒数第 N 个结点</p>
<ul>
<li>官方要求一次遍历，但官方解答却是快慢指针，仍然是两次遍历</li>
<li>直接遍历一次，并用数组存下每个节点指针，最有用数组直接O(1)就可以索引到倒数n+1个节点，实现删除了</li>
</ul>
</li>
<li><p>20 有效的括号</p>
<ul>
<li>栈，奇数个直接return false</li>
</ul>
</li>
<li><p>21 合并两个有序链表</p>
<ul>
<li>归并，注意定义一个空的节点pre，便于编程</li>
</ul>
</li>
<li><p>22 括号生成</p>
<ul>
<li>回溯，需要强化思路，复习</li>
</ul>
</li>
<li><p>23 并K个升序链表</p>
<ul>
<li>优先队列</li>
</ul>
</li>
<li><p>31 下一个排列</p>
</li>
<li><p>32 最长有效括号</p>
</li>
<li><p>33 搜索旋转排序数组</p>
<ul>
<li>看官方二分搜索的写法，更加清晰</li>
<li>每次二分，总有一部分是有序的，若target在有序中，则正常二分，若不在，则是一个子问题，继续二分</li>
</ul>
</li>
<li><p>34 在排序数组中查找元素的第一个和最后一个位置</p>
<ul>
<li>学习如何二分查找找到第一个大于等于target的位置，第一个大于target的位置</li>
</ul>
</li>
<li><p>39 组合总和</p>
<ul>
<li>回溯</li>
</ul>
</li>
<li><p>42 接雨水</p>
<ul>
<li>不会，看解析，先理解动态规划，再理解双指针</li>
<li>复习复习复习</li>
</ul>
</li>
<li><p>46  全排列</p>
<ul>
<li>回溯，swap方式动态维护数组，递归到底，维护的数组就是最终结果，直接加入res即可，不用额外维护一个排序结果的数组</li>
</ul>
</li>
<li><p>48 旋转图像</p>
</li>
<li><p>49 字母异位词分组</p>
<ul>
<li>字母排序+ hashmap</li>
</ul>
</li>
<li><p>53 最大子数组和</p>
<ul>
<li>动态规划: f[i] = max(nums[i], f[i-1]) // 如果此时取了nums[i]则表示前面的舍弃，新的区间从i开始</li>
</ul>
</li>
<li><p>55 跳跃游戏</p>
<ul>
<li>贪心，看代码更易理解</li>
</ul>
</li>
<li><p>56 合并区间</p>
</li>
<li><p>62 不同路径</p>
<ul>
<li>坐标型动态规划</li>
</ul>
</li>
<li><p>64 最小路径和</p>
<ul>
<li>坐标型动态规划</li>
</ul>
</li>
<li><p>70  爬楼梯</p>
<ul>
<li>动态规划</li>
</ul>
</li>
<li><p>72 编辑距离</p>
<ul>
<li>动态规划</li>
</ul>
</li>
<li><p>75 颜色分类</p>
<ul>
<li>三路快排思想</li>
</ul>
</li>
<li><p>76 最小覆盖子串</p>
<ul>
<li>滑动窗口 + hashmap记录字符满足个数，并记录</li>
</ul>
</li>
<li><p>78 子集</p>
<ul>
<li>回溯</li>
</ul>
</li>
<li><p>79 单词搜索</p>
<ul>
<li>递归回溯，开标记数组</li>
</ul>
</li>
<li><p>84 柱状图中最大的矩形</p>
<ul>
<li>单调栈，第一次学习，复习</li>
</ul>
</li>
<li><p>85 最大矩形</p>
<ul>
<li>84升级版，复习</li>
</ul>
</li>
<li><p>94 二叉树的中序遍历</p>
<ul>
<li>递归和非递归，栈</li>
</ul>
</li>
<li><p>96 不同的二叉搜索树</p>
<ul>
<li>动态规划，不太懂，复习</li>
</ul>
</li>
<li><p>98 验证二叉搜索树</p>
<ul>
<li>注意利用性质<ul>
<li>二叉搜索树中序遍历正好是升序</li>
<li>递归，自顶向下，传递左子树和右子树的范围</li>
</ul>
</li>
</ul>
</li>
<li><p>101 对称二叉树</p>
<ul>
<li>递归和迭代写法都不是很熟悉，需要复习复习</li>
</ul>
</li>
<li><p>102 二叉树的层序遍历</p>
<ul>
<li>用队列长度记录每层的元素个数，从而分层</li>
</ul>
</li>
<li><p>104 二叉树的最大深度</p>
<ul>
<li>dfs,bfs</li>
</ul>
</li>
<li><p>105 从前序与中序遍历序列构造二叉树 待写</p>
<ul>
<li>递归构建，有难度，不熟悉，复习<ul>
<li>先序遍历的第一个元素就是中序遍历的中间位置，定位到中序遍历的中间位置，则可以将左右分为左子树和右子树，而左子树确定后可以确定长度，又可以反过来让先序遍历的数组明确左子树和右子树的区间，然后进行递归划分</li>
</ul>
</li>
<li>非递归写法待学习</li>
</ul>
</li>
<li><p>114 二叉树展开为链表 待写</p>
<ul>
<li>先前序遍历搜集顺序到数组中，再通过数组顺序构建链表</li>
<li>先序遍历过程中展开为链表，利用栈</li>
</ul>
</li>
<li><p>121 买卖股票的最佳时机</p>
<ul>
<li>记录左边最小值，遍历一次</li>
</ul>
</li>
<li><p>124 二叉树中的最大路径和</p>
<ul>
<li>递归,官方解答思路更清晰</li>
</ul>
</li>
<li><p>128 最长连续序列 待写</p>
<ul>
<li>哈希</li>
</ul>
</li>
<li><p>136 只出现一次的数字 待写</p>
<ul>
<li>异或运算，性质，，，学习，记忆，异或运算符号</li>
</ul>
</li>
<li><p>139 单词拆分</p>
<ul>
<li>动态规划</li>
</ul>
</li>
<li><p>141 环形链表</p>
<ul>
<li>快慢指针</li>
</ul>
</li>
<li><p>142 环形链表 II</p>
<ul>
<li>141升级，巧妙，记忆</li>
</ul>
</li>
<li><p>146 LRU 缓存</p>
<ul>
<li>直接用list，stl的list就是双向指针</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mp.erase(ls.back().first); <span class="comment">// 先mp移除，因为先ls，这里还要使用ls</span></span><br><span class="line">ls.pop_back();</span><br></pre></td></tr></table></figure>



<ul>
<li><a href="https://leetcode.cn/problems/sort-list/" target="_blank" rel="noopener">148 排序链表</a><ul>
<li>归并排序，注意指针的移动，易错，复习</li>
</ul>
</li>
<li>152 <a href="https://leetcode.cn/problems/maximum-product-subarray/" target="_blank" rel="noopener"> 乘积最大子数组</a><ul>
<li>动态规划，类似53最大子数组和</li>
</ul>
</li>
<li>153 <a href="https://leetcode.cn/problems/min-stack/" target="_blank" rel="noopener">最小栈</a><ul>
<li>两个栈</li>
</ul>
</li>
<li>160 <a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener"> 相交链表</a><ul>
<li>只考虑了相交则相交之后完全共用的情况，但答案解析比较巧妙，待复习</li>
</ul>
</li>
<li>169 <a href="https://leetcode.cn/problems/majority-element/" target="_blank" rel="noopener">多数元素</a><ul>
<li>巧妙，复习</li>
<li>核心点：任意删除一对不同的数字，删除后的数组仍然满足存在多数元素的性质</li>
</ul>
</li>
<li>198 <a href="https://leetcode.cn/problems/house-robber/" target="_blank" rel="noopener">打家劫舍</a><ul>
<li>动态规划 思路没有理清楚，复习</li>
</ul>
</li>
<li>200 <a href="https://leetcode.cn/problems/number-of-islands/" target="_blank" rel="noopener">岛屿数量</a><ul>
<li>递归标记，不用回溯</li>
</ul>
</li>
<li>206 <a href="https://leetcode.cn/problems/reverse-linked-list/" target="_blank" rel="noopener">反转链表</a><ul>
<li>定义一个pre便于操作</li>
</ul>
</li>
<li>207 <a href="https://leetcode.cn/problems/course-schedule/" target="_blank" rel="noopener">课程表</a><ul>
<li>先看210，构建拓扑结构，利用深度优先或广度优先构建</li>
</ul>
</li>
<li>208 <a href="https://leetcode.cn/problems/implement-trie-prefix-tree/" target="_blank" rel="noopener"> 实现 Trie (前缀树)</a><ul>
<li>看答案，复习</li>
</ul>
</li>
<li>215 <a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">数组中的第K个最大元素</a><ul>
<li>快排方式：O(n)</li>
<li>最小堆：O(nlogk)</li>
</ul>
</li>
<li>221 <a href="https://leetcode.cn/problems/maximal-square/" target="_blank" rel="noopener">最大正方形</a><ul>
<li>动态规划</li>
</ul>
</li>
<li>226 <a href="https://leetcode.cn/problems/invert-binary-tree/" target="_blank" rel="noopener">翻转二叉树</a><ul>
<li>递归和先序遍历和后续遍历一样</li>
</ul>
</li>
<li>234 <a href="https://leetcode.cn/problems/palindrome-linked-list/" target="_blank" rel="noopener">回文链表</a><ul>
<li>快慢指针找到中点，后半部分反转，前后对比</li>
</ul>
</li>
<li>236 <a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener"> 二叉树的最近公共祖先</a><ul>
<li>递归，不熟悉，复习</li>
</ul>
</li>
<li>238 <a href="https://leetcode.cn/problems/product-of-array-except-self/" target="_blank" rel="noopener">除自身以外数组的乘积</a><ul>
<li>左右乘积，不熟悉，复习</li>
</ul>
</li>
<li>239 <a href="https://leetcode.cn/problems/sliding-window-maximum/" target="_blank" rel="noopener">滑动窗口最大值</a><ul>
<li>最大堆， 用pair处理索引的问题</li>
<li>单调队列，不熟悉，复习</li>
<li>分块+预处理，待学习实践</li>
</ul>
</li>
<li>240 <a href="https://leetcode.cn/problems/search-a-2d-matrix-ii/" target="_blank" rel="noopener">搜索二维矩阵 II</a><ul>
<li>z字形，巧妙，复习</li>
</ul>
</li>
<li>279 <a href="https://leetcode.cn/problems/perfect-squares/" target="_blank" rel="noopener"> 完全平方数</a><ul>
<li>动态规划，不要用递归</li>
</ul>
</li>
<li>283 <a href="https://leetcode.cn/problems/move-zeroes/" target="_blank" rel="noopener"> 移动零</a><ul>
<li>双指针更直观，但是自己的时间开销似乎更小，可能是双指针的swap次数太多，且swap是三次赋值且有临时变量</li>
</ul>
</li>
<li>287 <a href="https://leetcode.cn/problems/find-the-duplicate-number/" target="_blank" rel="noopener">寻找重复数</a><ul>
<li>快慢指针，巧妙，注意理解，从0开始，而0不参与，只有有指向自己或重复指向则存在环，则这个点是重复的元素，复习</li>
</ul>
</li>
<li>297 <a href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/" target="_blank" rel="noopener">二叉树的序列化与反序列化</a><ul>
<li>考察递归思想，复习</li>
</ul>
</li>
<li>300 <a href="https://leetcode.cn/problems/longest-increasing-subsequence/" target="_blank" rel="noopener"> 最长递增子序列</a><ul>
<li>动态规划： O(n*n)</li>
<li>贪心+二分查找： O(nlogn), 有难度，不太理解，复习</li>
</ul>
</li>
<li>309 <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener"> 最佳买卖股票时机含冷冻期</a><ul>
<li>动态规划</li>
</ul>
</li>
<li>312 <a href="https://leetcode.cn/problems/burst-balloons/" target="_blank" rel="noopener">戳气球</a><ul>
<li>区间型动态规划， 不熟悉，复习</li>
</ul>
</li>
<li>322 <a href="https://leetcode.cn/problems/coin-change/" target="_blank" rel="noopener"> 零钱兑换</a><ul>
<li>动态规划</li>
</ul>
</li>
<li>337 <a href="https://leetcode.cn/problems/house-robber-iii/" target="_blank" rel="noopener">打家劫舍 III</a><ul>
<li>动态规划，状态的定义可以有效的简化问题</li>
</ul>
</li>
<li>338 <a href="https://leetcode.cn/problems/counting-bits/" target="_blank" rel="noopener">比特位计数</a><ul>
<li>关于二进制的计算不是很熟悉，需要多练习，复习</li>
<li>最高有效位和最低有效位，巧妙</li>
</ul>
</li>
<li>394 <a href="https://leetcode.cn/problems/decode-string/" target="_blank" rel="noopener">字符串解码</a><ul>
<li>self 递归</li>
</ul>
</li>
<li>399 <a href="https://leetcode.cn/problems/evaluate-division/" target="_blank" rel="noopener">除法求值</a><ul>
<li>注意递推关系的推导和find函数内部各操作的执行顺序，复习</li>
</ul>
</li>
<li>406 <a href="https://leetcode.cn/problems/queue-reconstruction-by-height/" target="_blank" rel="noopener">根据身高重建队列</a><ul>
<li>从大到小考虑，更容易理解，先排序，复习</li>
</ul>
</li>
<li>416 <a href="https://leetcode.cn/problems/partition-equal-subset-sum/" target="_blank" rel="noopener"> 分割等和子集</a><ul>
<li>先将问题简化为一个动态规划问题，同494</li>
<li>动态规划，不熟悉，复习</li>
</ul>
</li>
<li>437 <a href="https://leetcode.cn/problems/path-sum-iii/" target="_blank" rel="noopener"> 路径总和 III</a><ul>
<li>前缀和，复习</li>
<li>注意int求和可能越界，要用long</li>
</ul>
</li>
<li>438 <a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noopener"> 找到字符串中所有字母异位词</a><ul>
<li>对即将发生变化的情况处理，简洁巧妙，复习</li>
</ul>
</li>
<li>448 <a href="https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/" target="_blank" rel="noopener">找到所有数组中消失的数字</a><ul>
<li>原地修改，取模找到原来的数，巧妙，复习</li>
</ul>
</li>
<li>461 <a href="https://leetcode.cn/problems/hamming-distance/" target="_blank" rel="noopener"> 汉明距离</a><ul>
<li>二进制相关操作，复习</li>
</ul>
</li>
<li>494 <a href="https://leetcode.cn/problems/target-sum/" target="_blank" rel="noopener">目标和</a><ul>
<li>先将问题简化为一个动态规划问题，同416</li>
<li>将问题简化为动态规划问题不会，复习</li>
</ul>
</li>
<li>538 <a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/" target="_blank" rel="noopener">把二叉搜索树转换为累加树</a><ul>
<li>递归还是不熟，复习</li>
<li>方法2待学习</li>
</ul>
</li>
<li>543 <a href="https://leetcode.cn/problems/diameter-of-binary-tree/" target="_blank" rel="noopener">二叉树的直径</a><ul>
<li>结合538理解递归，复习</li>
</ul>
</li>
<li>560 <a href="https://leetcode.cn/problems/subarray-sum-equals-k/" target="_blank" rel="noopener"> 和为 K 的子数组</a><ul>
<li>注意k可以为负数，所以用不了滑动窗口</li>
</ul>
</li>
<li>581 <a href="https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/" target="_blank" rel="noopener"> 最短无序连续子数组</a><ul>
<li>理解有难度，复习</li>
</ul>
</li>
<li>617 <a href="https://leetcode.cn/problems/merge-two-binary-trees/" target="_blank" rel="noopener">合并二叉树</a><ul>
<li>递归</li>
</ul>
</li>
<li>621 <a href="https://leetcode.cn/problems/task-scheduler/" target="_blank" rel="noopener">任务调度器</a><ul>
<li>看答案，复习</li>
<li>方法二待学习</li>
</ul>
</li>
<li>647 <a href="https://leetcode.cn/problems/palindromic-substrings/" target="_blank" rel="noopener">回文子串</a><ul>
<li>中心扩展</li>
<li>方法2带学习</li>
</ul>
</li>
</ul>
<h1 id="hot-100（add）"><a href="#hot-100（add）" class="headerlink" title="hot 100（add）"></a>hot 100（add）</h1><ul>
<li><p>3</p>
<ul>
<li>复习，容易错</li>
</ul>
</li>
<li><p>4 <a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">寻找两个正序数组的中位数</a></p>
<ul>
<li>二分查找</li>
<li>复习，思路分析，代码逻辑</li>
</ul>
</li>
<li><p>5 <a href="https://leetcode.cn/problems/longest-palindromic-substring/" target="_blank" rel="noopener">最长回文子串</a></p>
<ul>
<li>lint 108 加强版</li>
</ul>
</li>
<li><p>10 <a href="https://leetcode.cn/problems/regular-expression-matching/" target="_blank" rel="noopener">正则表达式匹配</a></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// f[i][j] 记录s前i个元素是否可以被p的前j个元素匹配  记录bool</span></span><br><span class="line">    <span class="comment">// f[i][j] = f[i-1][j-1]  s[i-1] == p[j-1] || p[j-1] == '.'</span></span><br><span class="line">    <span class="comment">//         = f[i-1][j]    p[j-1] == '*' &amp;&amp; (p[j-2] == s[i-1] || p[j-2] == '.')</span></span><br><span class="line">    <span class="comment">//         = f[i][j-2]    p[j-1] == '*'  // 因为".*" "s[i-1]*"可以匹配0个，即可以不用</span></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="comment">// f[0][0] = true;</span></span><br><span class="line">    <span class="comment">// f[0][1---m] = f[0][j-2] &amp;&amp; p[j-1] == '*' // 可以匹配0个</span></span><br><span class="line">    <span class="comment">// f[1---n][0] = false;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> m = p.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">f</span><span class="params">(n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(m+<span class="number">1</span>, <span class="literal">false</span>))</span></span>;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">      f[i][<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)&#123;</span><br><span class="line">      <span class="keyword">if</span>(p[j<span class="number">-1</span>] == <span class="string">'*'</span>)&#123;</span><br><span class="line">        f[<span class="number">0</span>][j] = f[<span class="number">0</span>][j<span class="number">-2</span>];</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        f[<span class="number">0</span>][j] = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p[j<span class="number">-1</span>] == <span class="string">'*'</span>)&#123;</span><br><span class="line">          f[i][j] = f[i][j<span class="number">-2</span>];</span><br><span class="line">          <span class="keyword">if</span>(p[j<span class="number">-2</span>] == s[i<span class="number">-1</span>] || p[j<span class="number">-2</span>] == <span class="string">'.'</span>)&#123;</span><br><span class="line">            f[i][j] = f[i][j] || f[i<span class="number">-1</span>][j];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          f[i][j] = f[i<span class="number">-1</span>][j<span class="number">-1</span>] &amp;&amp; (s[i<span class="number">-1</span>] == p[j<span class="number">-1</span>] || p[j<span class="number">-1</span>] == <span class="string">'.'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[n][m];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>11</p>
</li>
<li><p>15</p>
</li>
<li><p>17</p>
</li>
<li><p>19</p>
</li>
<li><p>20</p>
</li>
<li><p>21</p>
</li>
<li><p>22 <a href="https://leetcode.cn/problems/generate-parentheses/" target="_blank" rel="noopener">括号生成</a></p>
</li>
<li><p>23 </p>
</li>
<li><p>31 <a href="https://leetcode.cn/problems/next-permutation/" target="_blank" rel="noopener">下一个排列</a></p>
<ul>
<li>策略：要变大，且变为大的中最小的<ul>
<li>变大，则得在后面元素中找到比当前元素大的元素</li>
<li>变为大的中最小的则当前元素尽可能靠右</li>
</ul>
</li>
</ul>
</li>
<li><p>32 <a href="https://leetcode.cn/problems/longest-valid-parentheses/" target="_blank" rel="noopener"> 最长有效括号</a></p>
<ul>
<li>巧妙，待复习，看解析</li>
<li>栈方法和非栈方法都很巧妙</li>
</ul>
</li>
<li><p>33 <a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">搜索旋转排序数组</a></p>
<ul>
<li>二分，待优化，代码不简洁</li>
</ul>
</li>
<li><p>34 <a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">在排序数组中查找元素的第一个和最后一个位置</a></p>
<ul>
<li>学习如何二分查找找到第一个大于等于target的位置，第一个大于target的位置</li>
</ul>
</li>
<li><p>39</p>
</li>
<li><p>42 <a href="https://leetcode.cn/problems/trapping-rain-water/" target="_blank" rel="noopener">接雨水</a></p>
<ul>
<li>不会，看解析，先理解动态规划，再理解双指针</li>
<li>复习复习复习</li>
</ul>
</li>
<li><p>46</p>
</li>
<li><p>48 <a href="https://leetcode.cn/problems/rotate-image/" target="_blank" rel="noopener">旋转图像</a></p>
<ul>
<li>巧妙，记忆</li>
</ul>
</li>
<li><p>49</p>
</li>
<li><p>53 <a href="https://leetcode.cn/problems/maximum-subarray/" target="_blank" rel="noopener"> 最大子数组和</a></p>
<ul>
<li>不会，看解析，动态规划不会</li>
</ul>
</li>
<li><p>55 <a href="https://leetcode.cn/problems/jump-game/" target="_blank" rel="noopener">跳跃游戏</a></p>
<ul>
<li>贪心，看代码更易理解</li>
</ul>
</li>
<li><p>56 <a href="https://leetcode.cn/problems/merge-intervals/" target="_blank" rel="noopener">合并区间</a></p>
</li>
<li><p>62</p>
</li>
<li><p>64</p>
</li>
<li><p>70</p>
</li>
<li><p>72 <a href="https://leetcode.cn/problems/edit-distance/" target="_blank" rel="noopener"> 编辑距离</a></p>
<ul>
<li>初始化放在外面单独处理性能更好</li>
<li>min时用临时变量记录比每次使用f[i][j]性能更好</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> w1, <span class="built_in">string</span> w2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = w1.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> m = w2.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// f[i][j] 记录w1的前i个元素变为w2的前j个元素的最少操作次数</span></span><br><span class="line">    <span class="comment">// f[i][j] =  min(f[i-1][j-1] 相等 ,f[i-1][j] +1 删除, f[i-1][j-1]+1 替换, f[i][j-1]+1 插入) </span></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="comment">// f[0][0,,j,,m] = j  插入</span></span><br><span class="line">    <span class="comment">// f[0,,i,,n][0] = i  删除</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">f</span><span class="params">(n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m+<span class="number">1</span>))</span></span>;</span><br><span class="line">    <span class="comment">// 放在外面单独处理性能更好</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;=n; ++i)&#123;</span><br><span class="line">        f[i][<span class="number">0</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;=m; ++j)&#123;</span><br><span class="line">        f[<span class="number">0</span>][j] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= m; ++j)&#123;</span><br><span class="line">        <span class="comment">// if(i == 0)&#123;</span></span><br><span class="line">        <span class="comment">//   f[i][j] = j;</span></span><br><span class="line">        <span class="comment">//   continue;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// if(j == 0)&#123;</span></span><br><span class="line">        <span class="comment">//   f[i][j] = i;</span></span><br><span class="line">        <span class="comment">//   continue;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// 用临时变量记录比每次使用f[i][j]性能更好</span></span><br><span class="line">        <span class="keyword">int</span> left = f[i<span class="number">-1</span>][j] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = f[i][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> lr = f[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(w1[i<span class="number">-1</span>] == w2[j<span class="number">-1</span>]) lr -= <span class="number">1</span>;</span><br><span class="line">        f[i][j] = <span class="built_in">min</span>(lr, <span class="built_in">min</span>(left, right));</span><br><span class="line">        <span class="comment">// f[i][j] = f[i-1][j] + 1;</span></span><br><span class="line">        <span class="comment">// f[i][j] = min(f[i][j], f[i-1][j-1]+1);</span></span><br><span class="line">        <span class="comment">// f[i][j] = min(f[i][j], f[i][j-1]+1);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// if(w1[i-1] == w2[j-1])&#123;</span></span><br><span class="line">        <span class="comment">//   f[i][j] = min(f[i][j], f[i-1][j-1]);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[n][m];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>75</p>
</li>
<li><p>76</p>
</li>
<li><p>78</p>
</li>
<li><p>79</p>
</li>
<li><p>84 <a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener"> 柱状图中最大的矩形</a></p>
<ul>
<li>单调栈，第一次学习，复习</li>
</ul>
</li>
<li><p>85 <a href="https://leetcode.cn/problems/maximal-rectangle/" target="_blank" rel="noopener">最大矩形</a></p>
<ul>
<li>84升级版，复习</li>
</ul>
</li>
<li><p>94</p>
</li>
<li><p>96 <a href="https://leetcode.cn/problems/unique-binary-search-trees/" target="_blank" rel="noopener">不同的二叉搜索树</a></p>
<ul>
<li>动态规划，不太懂，复习</li>
</ul>
</li>
</ul>
<h1 id="剑指offer-专项突破"><a href="#剑指offer-专项突破" class="headerlink" title="剑指offer(专项突破)"></a>剑指offer(专项突破)</h1><ul>
<li>001 <a href="https://leetcode.cn/problems/xoh6Oh/" target="_blank" rel="noopener"> 整数除法</a><ul>
<li><a href="https://blog.csdn.net/liangllhahaha/article/details/82119378" target="_blank" rel="noopener">快速幂/快速乘</a></li>
<li>除法结果溢出的处理<ul>
<li>先考虑边界情况</li>
<li>所有输入的数都是满足范围是 <code>[−2^31, 2^31−1]</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入范围[−2^31, 2^31−1]</span><br><span class="line">考虑边界情况，可能溢出的情况</span><br><span class="line">1 a &#x3D; -2^31  b &#x3D; -1   res &#x3D; 2^31 溢出  return 2^31-1</span><br><span class="line">2 a &#x3D; -2^31  b &#x3D; 1  res &#x3D; -2^31</span><br><span class="line">3 b &#x3D; -2^31  a &#x3D; -2^31 res &#x3D; 1</span><br><span class="line">4 b &#x3D; -2^31  a &#x3D; any  res &#x3D; 0</span><br><span class="line">5 a,b符号都调整为负后  if(a &gt; b) return 0</span><br><span class="line">  a &#x3D; -2^31 调为正则会溢出  所以都统一调为负</span><br></pre></td></tr></table></figure>

<ul>
<li>002 <a href="https://leetcode.cn/problems/JFETK5/" target="_blank" rel="noopener">二进制加法</a><ul>
<li>注意使用reverse函数，可以简化问题</li>
</ul>
</li>
<li>003 <a href="https://leetcode.cn/problems/w3tCBm/" target="_blank" rel="noopener">前 n 个数字二进制中 1 的个数</a><ul>
<li>动态规划，最低位</li>
</ul>
</li>
<li>004 <a href="https://leetcode.cn/problems/WGki4K/" target="_blank" rel="noopener">只出现一次的数字 </a><ul>
<li>从方法2开始理解，巧妙，记忆，但这种方式感觉没有锻炼意义</li>
<li>还是用哈希表，常规方法</li>
</ul>
</li>
<li>005 <a href="https://leetcode.cn/problems/aseY1I/" target="_blank" rel="noopener">单词长度的最大乘积</a><ul>
<li><a href="https://www.cnblogs.com/Jojo-L/p/16274091.html" target="_blank" rel="noopener">位掩码</a></li>
<li>利用位掩码计算两个字符串是否有公共字符，学习，复习</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// masks[i]记录第i个单词的位掩码  </span></span><br><span class="line"><span class="comment">// int 型有32个比特位</span></span><br><span class="line"><span class="comment">// 26个英文字母就26个比特位就可以表示</span></span><br><span class="line"><span class="comment">// 所以 vector&lt;int&gt; masks, masks[i]就可以记录一个单词的位掩码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a  1</span></span><br><span class="line"><span class="comment">// b  10</span></span><br><span class="line"><span class="comment">// c  100</span></span><br><span class="line"><span class="comment">// abc 111</span></span><br><span class="line"><span class="comment">// af  100001</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// c  所在的位  1 &lt;&lt; 'c' - 'a'    1 左移 2位  即 100</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>006 <a href="https://leetcode.cn/problems/kLl5u1/" target="_blank" rel="noopener">排序数组中两个数字之和</a></p>
<ul>
<li>双指针，注意需要有序</li>
</ul>
</li>
<li><p>007 <a href="https://leetcode.cn/problems/1fGaJU/" target="_blank" rel="noopener">数组中和为 0 的三个数</a></p>
<ul>
<li>先排序，注意去重，内层用双指针</li>
</ul>
</li>
<li><p>008 <a href="https://leetcode.cn/problems/2VG8Kg/" target="_blank" rel="noopener"> 和大于等于 target 的最短子数组</a></p>
<ul>
<li>注意先加nums[r],再判断</li>
</ul>
</li>
<li><p>009 <a href="https://leetcode.cn/problems/ZVAVXX/" target="_blank" rel="noopener"> 乘积小于 K 的子数组</a></p>
<ul>
<li>每次记录以nums[r]结尾满足条件的个数</li>
<li>易错复习</li>
</ul>
</li>
<li><p>010 <a href="https://leetcode.cn/problems/QTMn0o/" target="_blank" rel="noopener">I 010. 和为 k 的子数组</a></p>
<ul>
<li>前缀和+哈希， 复习</li>
</ul>
</li>
<li><p>011 <a href="https://leetcode.cn/problems/A1NYOS/" target="_blank" rel="noopener"> 0 和 1 个数相同的子数组</a></p>
<ul>
<li>方法同010</li>
<li>记录1-0的差值</li>
</ul>
</li>
<li><p>012 <a href="https://leetcode.cn/problems/tvdfij/" target="_blank" rel="noopener">左右两边子数组的和相等</a></p>
</li>
<li><p>013 <a href="https://leetcode.cn/problems/O4NDxx/" target="_blank" rel="noopener">二维子矩阵的和</a></p>
<ul>
<li>二维前缀和</li>
</ul>
</li>
<li><p>014 <a href="https://leetcode.cn/problems/MPnaiL/" target="_blank" rel="noopener">字符串中的变位词</a></p>
<ul>
<li>滑动窗口</li>
<li>双指针，巧妙，复习</li>
</ul>
</li>
<li><p>015 <a href="https://leetcode.cn/problems/VabMRr/" target="_blank" rel="noopener"> 字符串中的所有变位词</a></p>
<ul>
<li>同014</li>
</ul>
</li>
<li><p>016 <a href="https://leetcode.cn/problems/wtcaE1/" target="_blank" rel="noopener">不含重复字符的最长子字符串</a></p>
<ul>
<li>滑动窗口</li>
<li>官方方法更直观，学习，复习</li>
</ul>
</li>
<li><p>017 <a href="https://leetcode.cn/problems/M1oyTv/" target="_blank" rel="noopener"> 含有所有字符的最短字符串</a></p>
<ul>
<li>滑动窗口</li>
<li>用范围索引记录结果，而不是直接记录满足条件的字符串，少用substr，性能开销非常大，复习</li>
</ul>
</li>
<li><p>018 <a href="https://leetcode.cn/problems/XltzEq/" target="_blank" rel="noopener">有效的回文</a></p>
<ul>
<li>isalnum的使用</li>
</ul>
</li>
<li><p>019 <a href="https://leetcode.cn/problems/RQku0D/" target="_blank" rel="noopener">最多删除一个字符得到回文</a></p>
<ul>
<li>递归</li>
<li>官方贪心，但思路很简单，不过需要把思路理清除，复习</li>
</ul>
</li>
<li><p>020 <a href="https://leetcode.cn/problems/a7VOhD/" target="_blank" rel="noopener">回文子字符串的个数</a></p>
</li>
<li><p>021 <a href="https://leetcode.cn/problems/SLwz0R/" target="_blank" rel="noopener">删除链表的倒数第 n 个结点</a></p>
<ul>
<li>双指针</li>
</ul>
</li>
<li><p>022 <a href="https://leetcode.cn/problems/c32eOV/" target="_blank" rel="noopener"> 链表中环的入口节点</a></p>
<ul>
<li>2(a+b) = a + b + n(b + c)</li>
</ul>
</li>
<li><p>023 <a href="https://leetcode.cn/problems/3u1WK4/" target="_blank" rel="noopener">两个链表的第一个重合节点</a></p>
</li>
<li><p>024 <a href="https://leetcode.cn/problems/UHnkqh/" target="_blank" rel="noopener">反转链表</a></p>
</li>
<li><p>025 <a href="https://leetcode.cn/problems/lMSNwu/" target="_blank" rel="noopener">链表中的两数相加</a></p>
<ul>
<li>先反转再求和</li>
</ul>
</li>
<li><p>026 <a href="https://leetcode.cn/problems/LGjMqU/" target="_blank" rel="noopener"> 重排链表</a></p>
<ul>
<li>找中点+反转+归并</li>
<li>学习官方归并的方式：一次执行两步操作</li>
</ul>
</li>
<li><p>027 <a href="https://leetcode.cn/problems/aMhZSa/" target="_blank" rel="noopener">回文链表</a></p>
<ul>
<li>找中点+反转+比较</li>
</ul>
</li>
<li><p>028 <a href="https://leetcode.cn/problems/Qv1Da2/" target="_blank" rel="noopener">展平多级双向链表</a></p>
<ul>
<li>递归</li>
</ul>
</li>
<li><p>029 <a href="https://leetcode.cn/problems/4ueAj6/" target="_blank" rel="noopener">排序的循环链表</a></p>
<ul>
<li>易出错</li>
<li>先找到升序的起始位置，然后按常规操作找到合适的位置</li>
</ul>
</li>
<li><p>030 <a href="https://leetcode.cn/problems/FortPu/" target="_blank" rel="noopener">插入、删除和随机访问都是 O(1) 的容器</a></p>
<ul>
<li>哈希表支持插入，删除 O(1)</li>
<li>数组支持随机访问 O(1)</li>
</ul>
</li>
<li><p>050 <a href="https://leetcode.cn/problems/6eUYwP/" target="_blank" rel="noopener"> 向下的路径节点之和</a></p>
<ul>
<li>易错，复习</li>
</ul>
</li>
<li><p>053 <a href="https://leetcode.cn/problems/P5rCT8/" target="_blank" rel="noopener">二叉搜索树中的中序后继</a></p>
<ul>
<li>不熟练，复习</li>
</ul>
</li>
<li><p>056 <a href="https://leetcode.cn/problems/opLdQZ/" target="_blank" rel="noopener">二叉搜索树中两个节点之和</a></p>
<ul>
<li>代码简化</li>
</ul>
</li>
<li><p>057 <a href="https://leetcode.cn/problems/7WqeDu/" target="_blank" rel="noopener">值和下标之差都在给定的范围内</a></p>
<ul>
<li>不会，看解析，复习</li>
<li>滑动窗口+哈希表： 越界问题，绝对值问题，lower_bound</li>
<li>桶： 学习<ul>
<li>注意编号时负数的处理</li>
</ul>
</li>
</ul>
</li>
<li><p>058 <a href="https://leetcode.cn/problems/fi9suh/" target="_blank" rel="noopener">日程表</a></p>
<ul>
<li>lower_bound, begin等迭代器使用，不熟悉，复习</li>
<li>线段树，学习</li>
</ul>
</li>
<li><p>061 <a href="https://leetcode.cn/problems/qn8gGX/" target="_blank" rel="noopener">和最小的 k 个数对</a></p>
<ul>
<li>不会，看解析</li>
<li>去重的巧妙性</li>
</ul>
</li>
<li><p>065 <a href="https://leetcode.cn/problems/iSwD2y/" target="_blank" rel="noopener">最短的单词编码</a></p>
<ul>
<li>用集合移除的方式效率更高</li>
</ul>
</li>
<li><p>067 <a href="https://leetcode.cn/problems/ms70jA/" target="_blank" rel="noopener"> 最大的异或</a></p>
<ul>
<li>二进制问题，转化为字典树</li>
<li>字典树处理，看解析，第一个评论解析比官方更易理解</li>
<li>复习复习复习！！！</li>
</ul>
</li>
</ul>
<h1 id="每日一题"><a href="#每日一题" class="headerlink" title="每日一题"></a>每日一题</h1><ul>
<li>1041 <a href="https://leetcode.cn/problems/robot-bounded-in-circle/" target="_blank" rel="noopener">困于环中的机器人</a><ul>
<li>模拟，考虑各种情况，总结每种情况的返回值，复习</li>
<li>++取模，–取模（–取模之前需要先加模长）</li>
</ul>
</li>
<li>2409 <a href="https://leetcode.cn/problems/count-days-spent-together/" target="_blank" rel="noopener">统计共同度过的日子数</a></li>
<li>1157 <a href="https://leetcode.cn/problems/online-majority-element-in-subarray/" target="_blank" rel="noopener">子数组中占绝大多数的元素</a><ul>
<li>不会，看解析</li>
</ul>
</li>
<li>1026 <a href="https://leetcode.cn/problems/maximum-difference-between-node-and-ancestor/" target="_blank" rel="noopener">节点与其祖先之间的最大差值</a><ul>
<li>递归</li>
<li>优化：只有记录前面的最大值和最小值，看解析证明</li>
</ul>
</li>
<li>1043 <a href="https://leetcode.cn/problems/partition-array-for-maximum-sum/" target="_blank" rel="noopener">分隔数组以得到最大和</a><ul>
<li>动态规划</li>
<li>问题的抽象不会，复习，，，</li>
</ul>
</li>
<li>1187 <a href="https://leetcode.cn/problems/make-array-strictly-increasing/" target="_blank" rel="noopener">使数组严格递增</a><ul>
<li>最多可以替换的次数为 min(<em>n</em>,<em>m</em>) ： 因为替换后是严格递增的，所以v2中的数只能使用一次，如果使用2次则v1中的就必定存在两个相同的数，则不严格递增了</li>
<li>不会，复习，锻炼思路</li>
</ul>
</li>
<li>2413 <a href="https://leetcode.cn/problems/smallest-even-multiple/" target="_blank" rel="noopener">最小偶倍数</a><ul>
<li>最小公倍数，最大公因数</li>
</ul>
</li>
<li>1105 <a href="https://leetcode.cn/problems/filling-bookcase-shelves/" target="_blank" rel="noopener">填充书架</a><ul>
<li>不会，复习，看解析：<a href="https://leetcode.cn/problems/filling-bookcase-shelves/solution/po-su-xiang-fa-dong-tai-gui-hua-by-zi-ji-5vr6/" target="_blank" rel="noopener">更好理解</a></li>
</ul>
</li>
<li>2418 <a href="https://leetcode.cn/problems/sort-the-people/" target="_blank" rel="noopener">按身高排序</a><ul>
<li>利用堆索引的思想</li>
</ul>
</li>
<li>1163 <a href="https://leetcode.cn/problems/last-substring-in-lexicographical-order/" target="_blank" rel="noopener">按字典序排在最后的子串</a><ul>
<li>不懂，看答案，复习</li>
<li><a href="https://leetcode.cn/problems/last-substring-in-lexicographical-order/solution/python3javacgotypescript-yi-ti-yi-jie-sh-3amj/" target="_blank" rel="noopener">易理解的解答</a></li>
</ul>
</li>
<li>1048 <a href="https://leetcode.cn/problems/longest-string-chain/" target="_blank" rel="noopener">最长字符串链</a></li>
<li>1015 <a href="https://leetcode.cn/problems/smallest-integer-divisible-by-k/" target="_blank" rel="noopener">可被 K 整除的最小整数</a><ul>
<li>数学: 取模，递推</li>
<li>优化：当 <em>k</em> 为 2 或者 5的倍数时，能够被 <em>k</em> 整除的数字末尾一定不为 1，所以此时一定无解</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// resid = 1 mod k</span></span><br><span class="line"><span class="comment">// nnew = nold * 10 + 1</span></span><br><span class="line"><span class="comment">// residnew = nnew mod k = (nold * 10 + 1) mod k = ((nold%k) * 10 + 1)%k</span></span><br><span class="line"><span class="comment">//          = (residold * 10 + 1)%k</span></span><br><span class="line"><span class="comment">// resid = (resid * 10 + 1)%k</span></span><br><span class="line"><span class="comment">// resid == 0 表示可以被整除</span></span><br><span class="line"><span class="comment">// resid 重复出现则表示进入循环 ********重要：退出判断*******</span></span><br></pre></td></tr></table></figure>

<ul>
<li>2611 <a href="https://leetcode.cn/problems/mice-and-cheese/" target="_blank" rel="noopener">老鼠和奶酪</a><ul>
<li>贪心+排序/优先队列</li>
<li>注意问题的转化，将问题转化为在n个数中选择k个数，使得和最大，也就是求n个中前k个大的数的和     巧妙！！！</li>
</ul>
</li>
</ul>
<h1 id="题型"><a href="#题型" class="headerlink" title="题型"></a>题型</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul>
<li><p><a href="https://leetcode.cn/problems/move-zeroes/" target="_blank" rel="noopener">283. 移动零</a></p>
<ul>
<li>双指针</li>
</ul>
</li>
<li><p><a href="https://leetcode.cn/problems/remove-element/" target="_blank" rel="noopener">27. 移除元素</a></p>
<ul>
<li>双指针 同上</li>
</ul>
</li>
<li><p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">26. 删除有序数组中的重复项</a></p>
<ul>
<li>双指针 同上</li>
</ul>
</li>
<li><p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/" target="_blank" rel="noopener">80. 删除有序数组中的重复项 II</a></p>
<ul>
<li>双指针   注意范围</li>
</ul>
</li>
</ul>
<p><strong>排序应用</strong></p>
<ul>
<li><p><a href="https://leetcode.cn/problems/sort-colors/" target="_blank" rel="noopener">75. 颜色分类</a></p>
<ul>
<li>计数排序</li>
<li>三路快排（适用于重复元素较多的情况）<ul>
<li>[0,lt] == 0    lt是闭区间 则lt初始=-1  如果初始lt=0  那么久默认0位置就是==0了</li>
<li>[lt+1, i) ==  1</li>
<li>[gt, n-1] == 2  同理 gt是闭区间 所以gt初始=n</li>
</ul>
</li>
</ul>
</li>
<li><p><a href="https://leetcode.cn/problems/merge-sorted-array/" target="_blank" rel="noopener">88. 合并两个有序数组</a></p>
<ul>
<li>逆向双指针</li>
</ul>
</li>
<li><p><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">215. 数组中的第K个最大元素</a></p>
<ul>
<li>三路快排</li>
</ul>
</li>
</ul>
<p><strong>对撞指针</strong></p>
<ul>
<li><p><a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">167. 两数之和 II - 输入有序数组</a></p>
</li>
<li><p><a href="https://leetcode.cn/problems/valid-palindrome/" target="_blank" rel="noopener">125. 验证回文串</a></p>
<ul>
<li>字符串操作  isalnum  tolower</li>
</ul>
</li>
<li><p><a href="https://leetcode.cn/problems/reverse-string/" target="_blank" rel="noopener">344. 反转字符串</a></p>
</li>
<li><p><a href="https://leetcode.cn/problems/container-with-most-water/" target="_blank" rel="noopener">11. 盛最多水的容器</a> </p>
<ul>
<li>有难度</li>
<li>看解析</li>
</ul>
</li>
</ul>
<p><strong>滑动窗口</strong></p>
<blockquote>
<p>定宽窗口和变宽窗口有区别</p>
</blockquote>
<ul>
<li><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/" target="_blank" rel="noopener">209. 长度最小的子数组</a></p>
<ul>
<li>在有效时记录窗口宽度</li>
</ul>
</li>
<li><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">3. 无重复字符的最长子串</a></p>
<ul>
<li>不方便while滑动时 就一步一步的滑动</li>
</ul>
</li>
<li><p><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noopener">438. 找到字符串中所有字母异位词</a></p>
<ul>
<li>方法值得再研究</li>
<li>记录每个需要字符的状态  对状态改变时修改need</li>
<li>定宽滑动</li>
</ul>
</li>
<li><p><a href="https://leetcode.cn/problems/minimum-window-substring/" target="_blank" rel="noopener">76. 最小覆盖子串</a></p>
<ul>
<li>变宽滑动</li>
</ul>
</li>
</ul>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><blockquote>
<p>set</p>
<p>map</p>
</blockquote>
<ul>
<li><p><a href="https://leetcode.cn/problems/intersection-of-two-arrays/" target="_blank" rel="noopener">349. 两个数组的交集</a></p>
</li>
<li><p><a href="https://leetcode.cn/problems/intersection-of-two-arrays-ii/" target="_blank" rel="noopener">350. 两个数组的交集 II</a></p>
</li>
<li><p><a href="https://leetcode.cn/problems/valid-anagram/" target="_blank" rel="noopener">242. 有效的字母异位词</a></p>
</li>
<li><p><a href="https://leetcode.cn/problems/happy-number/" target="_blank" rel="noopener">202. 快乐数</a></p>
</li>
<li><p><a href="https://leetcode.cn/problems/word-pattern/" target="_blank" rel="noopener">290. 单词规律</a></p>
</li>
<li><p><a href="https://leetcode.cn/problems/isomorphic-strings/" target="_blank" rel="noopener">205. 同构字符串</a></p>
</li>
<li><p><a href="https://leetcode.cn/problems/sort-characters-by-frequency/" target="_blank" rel="noopener">451. 根据字符出现频率排序</a></p>
</li>
<li><p><a href="https://leetcode.cn/problems/two-sum/" target="_blank" rel="noopener">1. 两数之和</a></p>
</li>
<li><p><a href="https://leetcode.cn/problems/3sum/" target="_blank" rel="noopener">15. 三数之和</a></p>
<ul>
<li>经典(看的解析)  时间复杂度高</li>
</ul>
</li>
<li><p><a href="https://leetcode.cn/problems/4sum/" target="_blank" rel="noopener">18. 四数之和</a></p>
<ul>
<li>经典(看的解析)  时间复杂度高</li>
</ul>
</li>
<li><p>16 <a href="https://leetcode.cn/problems/3sum-closest/" target="_blank" rel="noopener"> 最接近的三数之和</a></p>
</li>
<li><p><a href="https://leetcode.cn/problems/4sum-ii/" target="_blank" rel="noopener">454. 四数相加 II</a>  (看的解析)</p>
<ul>
<li>就是枚举  不要想复杂了</li>
<li>数学问题</li>
</ul>
</li>
<li><p><a href="https://leetcode.cn/problems/number-of-boomerangs/" target="_blank" rel="noopener">447. 回旋镖的数量</a></p>
<ul>
<li>数学问题</li>
</ul>
</li>
<li><p><a href="https://leetcode.cn/problems/max-points-on-a-line/" target="_blank" rel="noopener">149. 直线上最多的点数</a></p>
<ul>
<li>困难 优化点很多 多方考虑</li>
<li>键值：两个有范围的数 如何相加得到一个独一无二的数 计算之后的和分布在不同的区间</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x,y都是整数</span><br><span class="line">x: [-2*10^4, 2*10^4]  y: [0, 2*10^4] x+y后区间是连续的所以会重复</span><br><span class="line">x &#x3D; x * (2*10^4+1)后  x的间距变为2*10^4+1 正好可以容下y的区间  x+y就不会重复， 每个x加上y后区间都不和其它x加上y的区间重合</span><br><span class="line"></span><br><span class="line">-40002， -20001， 0 ， 20001， 40002 +y---&gt;[-60002,-40002] [-40001, -20001] [0, 20000] [20001,40001] [40002, 60002] q</span><br></pre></td></tr></table></figure>

<p><strong>查找表+滑动窗口</strong></p>
<ul>
<li><p><a href="https://leetcode.cn/problems/contains-duplicate-ii/" target="_blank" rel="noopener">219. 存在重复元素 II</a></p>
<ul>
<li>Unordered_map</li>
<li>滑动窗口</li>
</ul>
</li>
<li><p><a href="https://leetcode.cn/problems/contains-duplicate/" target="_blank" rel="noopener">217. 存在重复元素</a></p>
<ul>
<li>unordered_set</li>
</ul>
</li>
</ul>
<p><strong>二分搜索树+滑动窗口</strong></p>
<ul>
<li><a href="https://leetcode.cn/problems/contains-duplicate-iii/" target="_blank" rel="noopener">220. 存在重复元素 III</a><ul>
<li>使用set   复习</li>
<li>桶排序比较复杂</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th><a href="https://zh.cppreference.com/w/cpp/container/map/lower_bound" target="_blank" rel="noopener">lower_bound</a></th>
<th>返回指向首个<em>不小于</em>给定键的元素的迭代器 (公开成员函数)</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://zh.cppreference.com/w/cpp/container/map/upper_bound" target="_blank" rel="noopener">upper_bound</a></td>
<td>返回指向首个<em>大于</em>给定键的元素的迭代器</td>
</tr>
</tbody></table>
<h2 id="差分数组"><a href="#差分数组" class="headerlink" title="差分数组"></a>差分数组</h2><blockquote>
<p>注意对交点(增加和减少的汇聚点)的处理，根据业务情况确定在哪减</p>
</blockquote>
<ul>
<li>1109 <a href="https://leetcode.cn/problems/corporate-flight-bookings/" target="_blank" rel="noopener">航班预订统计</a><ul>
<li>交点处增加，交点后减少</li>
</ul>
</li>
<li>1094 <a href="https://leetcode.cn/problems/car-pooling/" target="_blank" rel="noopener">拼车</a><ul>
<li>交点处同时增加和减少</li>
</ul>
</li>
</ul>
<h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><ul>
<li>每日一题：<a href="https://leetcode.cn/problems/smallest-integer-divisible-by-k/" target="_blank" rel="noopener">1015. 可被 K 整除的最小整数</a><ul>
<li>重要等式: <a href="https://leetcode.cn/problems/smallest-integer-divisible-by-k/solutions/2263780/san-chong-suan-fa-you-hua-pythonjavacgo-tk4cj/" target="_blank" rel="noopener">证明</a><ul>
<li><code>(a+b)%m = (a%m+b%m)%m</code></li>
<li><code>(a*b)%m = ((a%m)*(b%m))%m</code></li>
</ul>
</li>
</ul>
</li>
<li>快速幂<a href="https://leetcode.cn/problems/powx-n/" target="_blank" rel="noopener">50. Pow(x, n)</a><ul>
<li><a href="https://blog.csdn.net/liangllhahaha/article/details/82119378" target="_blank" rel="noopener">快速幂/快速乘</a></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速幂</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ksm</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="comment">// 计算a^b</span></span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> base = a;</span><br><span class="line">  <span class="keyword">while</span> (b) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((b&amp;<span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 避免ans越界 可以用上线除以base 看是否小于ans  如果是则可以*base  否则不能</span></span><br><span class="line">      ans *= base;</span><br><span class="line">    &#125;</span><br><span class="line">    base *= base;</span><br><span class="line">    b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速乘</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ksc</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="comment">// 计算a*b</span></span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> base = a;</span><br><span class="line">  <span class="keyword">while</span> (b) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((b&amp;<span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">      ans += base;</span><br><span class="line">    &#125;</span><br><span class="line">    base += base;</span><br><span class="line">    b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>29 <a href="https://leetcode.cn/problems/divide-two-integers/" target="_blank" rel="noopener">两数相除</a></li>
</ul>
<p>快速幂/快速乘： 下面的面试部分有讲解</p>
<p>最大公因数： gcd(n,m)</p>
<blockquote>
<p><a href="https://blog.csdn.net/qq_36834256/article/details/79381912" target="_blank" rel="noopener">辗转相除法</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 辗转相除法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n%m == <span class="number">0</span> ? m : gcd(m, n%m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>最小公倍数:    clm(n,m)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = n/gcd(n,m);</span><br><span class="line">b = m/gcd(n,m);</span><br><span class="line"></span><br><span class="line">clm(n,m) = a * b * gcd(n,m) = n*m/gcd(n,m)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">int</span> clm(<span class="keyword">int</span> n, <span class="keyword">int</span> m)&#123;</span><br><span class="line">    <span class="keyword">return</span> n*m/gcd(n,m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>offer专项 071 <a href="https://leetcode.cn/problems/cuyjEf/" target="_blank" rel="noopener"> 按权重生成随机数</a><ul>
<li>就是在权重范围内生成随机数，随机数落在哪个区间，就返回那个区间对应的数</li>
</ul>
</li>
</ul>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><blockquote>
<p>对字符串排序</p>
<p>两个字符串是否相等，直接用s == t判断， 比自己比较快</p>
</blockquote>
<ul>
<li>offer 专项 033 <a href="https://leetcode.cn/problems/sfvd7V/" target="_blank" rel="noopener"> 变位词组</a></li>
<li>offer 专项 035 <a href="https://leetcode.cn/problems/569nqc/" target="_blank" rel="noopener"> 最小时间差</a><ul>
<li>时间格式转化： 各位操作比用substr+stoi的效率高</li>
</ul>
</li>
</ul>
<h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><blockquote>
<p><a href="https://www.bilibili.com/video/BV1QT4y1Z7rR/?spm_id_from=333.337.search-card.all.click&vd_source=7230a052308bbb41976f248d2c778e3a" target="_blank" rel="noopener">视频讲解</a></p>
</blockquote>
<ul>
<li><p><a href="https://leetcode.cn/problems/fi9suh/" target="_blank" rel="noopener">LCR 058. 我的日程安排表 I</a></p>
<ul>
<li><p>map + 二分查找，简洁，易懂</p>
<ul>
<li>容器查找为空则结果等于begin，容器为空的情况下begin == end   不熟悉，复习</li>
</ul>
</li>
<li><p>线段树</p>
<ul>
<li>lazy记录这个区间所有点都已预定 tree记录这个区间有至少一个点被预定过了</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h2><blockquote>
<p>异或性质</p>
<ul>
<li>a^b = b^a</li>
<li>x = a^b    —-&gt;  a = x^b</li>
</ul>
</blockquote>
<ul>
<li>offer专项 067 <a href="https://leetcode.cn/problems/ms70jA/" target="_blank" rel="noopener"> 最大的异或</a><ul>
<li>字典树处理，看解析，第一个评论解析比官方更易理解</li>
<li>复习 容易忘</li>
</ul>
</li>
</ul>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>offer专项 068 — 073</p>
<ul>
<li><p><a href="https://leetcode.cn/problems/N6YdxV/" target="_blank" rel="noopener">LCR 068. 搜索插入位置</a></p>
</li>
<li><p><a href="https://leetcode.cn/problems/B1IidL/" target="_blank" rel="noopener">LCR 069. 山脉数组的峰顶索引</a></p>
</li>
<li><p><a href="https://leetcode.cn/problems/skFtm2/" target="_blank" rel="noopener">LCR 070. 有序数组中的单一元素</a></p>
</li>
<li><p><a href="https://leetcode.cn/problems/cuyjEf/" target="_blank" rel="noopener">LCR 071. 按权重随机选择</a></p>
</li>
<li><p>offer 专项 072 <a href="https://leetcode.cn/problems/jJ0w9p/" target="_blank" rel="noopener">求平方根</a></p>
<ul>
<li>学习这种写法，多场景可用，记录可能满足的情况(and = mid)<ul>
<li>将可能满足条件的情况记录，另一种情况直接不满足条件，用l&lt;=r退出，或l&lt;r退出，根据具体情况而定</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = x, ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">long</span> <span class="keyword">long</span>)mid * mid &lt;= x) &#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://leetcode.cn/problems/nZZqjQ/" target="_blank" rel="noopener">LCR 073. 爱吃香蕉的狒狒</a></li>
</ul>
<h2 id="栈、队列"><a href="#栈、队列" class="headerlink" title="栈、队列"></a><strong>栈、队列</strong></h2><ul>
<li>20 <a href="https://leetcode.cn/problems/valid-parentheses/" target="_blank" rel="noopener">有效的括号</a></li>
<li>150 <a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/" target="_blank" rel="noopener">逆波兰表达式求值</a><ul>
<li>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中</li>
</ul>
</li>
<li>71 <a href="https://leetcode.cn/problems/simplify-path/" target="_blank" rel="noopener">简化路径</a></li>
</ul>
<p><strong>递归</strong></p>
<ul>
<li>144 <a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">二叉树的前序遍历</a></li>
<li>94 <a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">二叉树的中序遍历</a></li>
<li>145 <a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">二叉树的后序遍历</a></li>
<li>341 <a href="https://leetcode.cn/problems/flatten-nested-list-iterator/" target="_blank" rel="noopener"> 扁平化嵌套列表迭代器</a></li>
</ul>
<p><strong>队列</strong></p>
<ul>
<li>102 <a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">二叉树的层序遍历</a><ul>
<li>不记录层数的解决方案</li>
</ul>
</li>
<li>107 <a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/" target="_blank" rel="noopener">二叉树的层序遍历 II</a></li>
<li>103 <a href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="noopener">二叉树的锯齿形层序遍历</a><ul>
<li>双队列</li>
</ul>
</li>
<li>199 <a href="https://leetcode.cn/problems/binary-tree-right-side-view/" target="_blank" rel="noopener"> 二叉树的右视图</a></li>
</ul>
<p><strong>BFS最短路径</strong></p>
<ul>
<li>279 <a href="https://leetcode.cn/problems/perfect-squares/" target="_blank" rel="noopener">完全平方数</a><ul>
<li>因为是需要最少的平方数，所以就是最短路径，所以BFS效果好<ul>
<li>BFS倒着入队效果可能更好(最大的平方数先入队，例如对于15，第一层入队顺序：6(15-9)， 11(15-4)，14(15-1))</li>
</ul>
</li>
<li>数学方法效果最好  记忆结论</li>
<li>动态规划  待学习， 已学习，效果不如BFS，因为对于全是1的情况的都考虑了，换成递归的形式深度会很大，所以效果不如BFS</li>
<li>BFS 去重的理解（对于相同值，前面入队过的值至少深度是小于等于当前值的，所以当前值继续只会大于等于前面的值，所以可以不入队）</li>
</ul>
</li>
<li>127<a href="https://leetcode.cn/problems/word-ladder/" target="_blank" rel="noopener">单词接龙</a><ul>
<li>巧妙构建树</li>
<li>双向BFS的思想</li>
</ul>
</li>
<li>126 <a href="https://leetcode.cn/problems/word-ladder-ii/" target="_blank" rel="noopener">单词接龙 II</a><ul>
<li>回溯 待学习</li>
</ul>
</li>
</ul>
<p><strong>优先队列</strong></p>
<ul>
<li>347 <a href="https://leetcode.cn/problems/top-k-frequent-elements/" target="_blank" rel="noopener"> 前 K 个高频元素</a><ul>
<li>快排方式更快</li>
</ul>
</li>
<li>23 合并K个升序链表<ul>
<li>分治合并  待学习</li>
<li>优先队列</li>
</ul>
</li>
</ul>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><blockquote>
<p>1 <strong>快慢指针定位链表中点时，前面添加dummy，这样定位就正好在中间了</strong></p>
<p>-1 0 1 2 3 4 5   n = 6 中间位置：2</p>
<p>-1 0 1 2 3 4 5 6 n = 7 中间位置：3</p>
<p>2 不方便while的就直接用for确定移动的次数，这样不容易出错</p>
<p>3 充分利用滑动的指针：148 自底向上的cur的使用，复习</p>
</blockquote>
<ul>
<li><p>offer专项 021 <a href="https://leetcode.cn/problems/SLwz0R/" target="_blank" rel="noopener">删除链表的倒数第 n 个结点</a></p>
<ul>
<li>双指针，只遍历一遍，前后指针差为n，巧妙，记忆</li>
</ul>
</li>
<li><p>2 <a href="https://leetcode.cn/problems/add-two-numbers/" target="_blank" rel="noopener">两数相加</a></p>
<ul>
<li>不使用原链表，返回链表不算空间</li>
</ul>
</li>
<li><p><a href="https://leetcode.cn/problems/add-two-numbers-ii/" target="_blank" rel="noopener">445. 两数相加 II</a></p>
<ul>
<li>链表翻转则和2一样</li>
<li>链表不翻转，使用栈（要额外的空间）</li>
</ul>
</li>
<li><p>19  <a href="https://leetcode.cn/problems/SLwz0R/" target="_blank" rel="noopener">删除链表的倒数第 n 个结点</a></p>
</li>
<li><p>21 <a href="https://leetcode.cn/problems/merge-two-sorted-lists/" target="_blank" rel="noopener"> 合并两个有序链表</a></p>
<ul>
<li>类比数组归并，小的压入数组，就相当p-&gt;next = 小的</li>
</ul>
</li>
<li><p>23 <a href="https://leetcode.cn/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">合并 K 个升序链表</a></p>
<ul>
<li>熟悉优先队列的使用，复习</li>
</ul>
</li>
<li><p>114 <a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener">二叉树展开为链表</a></p>
<ul>
<li>递归思想，复习</li>
<li>压栈，复习</li>
</ul>
</li>
<li><p>141 <a href="https://leetcode.cn/problems/linked-list-cycle/" target="_blank" rel="noopener">环形链表</a></p>
<ul>
<li>快慢指针</li>
</ul>
</li>
<li><p>142 <a href="https://leetcode.cn/problems/linked-list-cycle-ii/" target="_blank" rel="noopener"> 环形链表 II</a></p>
</li>
<li><p>146 <a href="https://leetcode.cn/problems/lru-cache/" target="_blank" rel="noopener">LRU 缓存</a></p>
</li>
<li><p>148 <a href="https://leetcode.cn/problems/sort-list/" target="_blank" rel="noopener"> 排序链表</a></p>
<ul>
<li>自顶向下好写</li>
<li>自底向上复杂，复习</li>
</ul>
</li>
<li><p>206 <a href="https://leetcode.cn/problems/reverse-linked-list/" target="_blank" rel="noopener">反转链表</a></p>
</li>
<li><p>92 反转链表II 有难度</p>
<ul>
<li>只遍历一遍如何实现<ul>
<li>翻转不要抽离出去，直接就地翻转</li>
</ul>
</li>
</ul>
</li>
<li><p>25 <a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/" target="_blank" rel="noopener">K 个一组翻转链表</a>  困难</p>
<ul>
<li>也不是很难，关键在于定位要翻转的范围</li>
</ul>
</li>
<li><p>234 <a href="https://leetcode.cn/problems/palindrome-linked-list/" target="_blank" rel="noopener"> 回文链表</a></p>
<ul>
<li>找中心点，反转，比对，每个步骤都分开做，因为合在一起太复杂，容易错</li>
</ul>
</li>
<li><p>offer 专项077 <a href="https://leetcode.cn/problems/7WHec2/" target="_blank" rel="noopener">链表排序</a></p>
<ul>
<li>148</li>
<li>归并排序，复习复习复习！！！  考察归并和链表</li>
</ul>
</li>
<li><p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">83. 删除排序链表中的重复元素</a></p>
<ul>
<li><em>删除所有重复的元素，使每个元素只出现一次</em></li>
</ul>
</li>
<li><p>82 <a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/" target="_blank" rel="noopener">删除排序链表中的重复元素 II</a></p>
<ul>
<li><em>删除原始链表中所有重复数字的节点，只留下不同的数字</em></li>
</ul>
</li>
</ul>
<ul>
<li><a href="https://leetcode.cn/problems/partition-list/" target="_blank" rel="noopener">86. 分隔链表</a><ul>
<li>借用92中一次遍历的思想</li>
<li>官方解法： 维护两个链表也很简便</li>
</ul>
</li>
<li><a href="https://leetcode.cn/problems/odd-even-linked-list/" target="_blank" rel="noopener">328. 奇偶链表</a><ul>
<li>借用86中维护两个链表的思想</li>
<li>具体实现方式略有不同</li>
</ul>
</li>
<li><a href="https://leetcode.cn/problems/remove-linked-list-elements/" target="_blank" rel="noopener">203. 移除链表元素</a></li>
<li><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">24. 两两交换链表中的节点</a></li>
<li>143<a href="https://leetcode.cn/problems/reorder-list/" target="_blank" rel="noopener"> 重排链表</a><ul>
<li>考察点多  重做复习</li>
<li>快慢指针找中点</li>
<li>链表翻转</li>
<li>链表合并</li>
</ul>
</li>
<li><a href="https://leetcode.cn/problems/insertion-sort-list/" target="_blank" rel="noopener">147. 对链表进行插入排序</a><ul>
<li>模拟插入排序</li>
<li>满足升序 直接往后走 </li>
<li>不满足则该节点需要前移</li>
</ul>
</li>
<li>237 删除单链表节点</li>
<li>61 <a href="https://leetcode.cn/problems/rotate-list/" target="_blank" rel="noopener">旋转链表</a><ul>
<li>官方解法更好</li>
</ul>
</li>
</ul>
<p><strong>常见记录</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反转链表</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">  ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">while</span> (head)</span><br><span class="line">  &#123;</span><br><span class="line">    ListNode* temp = head-&gt;next;</span><br><span class="line">    head-&gt;next = pre;</span><br><span class="line">    pre = head;</span><br><span class="line">    head = temp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并两个单链表 l1长于l2的情况可以完全链接上  l2长于l1时，l2后半段会丢失</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeList</span><span class="params">(ListNode* l1, ListNode* l2)</span></span>&#123;</span><br><span class="line">  ListNode* ll1;</span><br><span class="line">  ListNode* ll2;</span><br><span class="line">  <span class="keyword">while</span> (l1 &amp;&amp; l2)</span><br><span class="line">  &#123;</span><br><span class="line">    ll1 = l1-&gt;next;</span><br><span class="line">    ll2 = l2-&gt;next;</span><br><span class="line">      </span><br><span class="line">    l1-&gt;next = l2;</span><br><span class="line">    l1 = ll1;</span><br><span class="line">      </span><br><span class="line">    l2-&gt;next = l1;</span><br><span class="line">    l2 = ll2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找链表的中点</span></span><br><span class="line"><span class="function">ListNode* <span class="title">midList</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">  ListNode* slow = head;</span><br><span class="line">  ListNode* fast = head;</span><br><span class="line">  <span class="keyword">while</span> (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next)</span><br><span class="line">  &#123;</span><br><span class="line">    slow = slow-&gt;next;</span><br><span class="line">    fast = fast-&gt;next-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><blockquote>
<p>通过空节点判断递归到底，判断更简洁</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(!root1 &amp;&amp; !root2)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!root1)&#123;</span><br><span class="line">            <span class="keyword">return</span> root2;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!root2)&#123;</span><br><span class="line">            <span class="keyword">return</span> root1;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            root1-&gt;val = root1-&gt;val + root2-&gt;val;</span><br><span class="line">            root1-&gt;left = mergeTrees(root1-&gt;left, root2-&gt;left);</span><br><span class="line">            root1-&gt;right = mergeTrees(root1-&gt;right, root2-&gt;right);</span><br><span class="line">            <span class="keyword">return</span> root1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面可简写为下面</span></span><br><span class="line"> 		<span class="keyword">if</span>(!root1) <span class="keyword">return</span> root2;</span><br><span class="line">        <span class="keyword">if</span>(!root2) <span class="keyword">return</span> root1;</span><br><span class="line">		<span class="comment">// 上面两行包括了都为空的情况</span></span><br><span class="line">        root1-&gt;val = root1-&gt;val + root2-&gt;val;</span><br><span class="line">        root1-&gt;left = mergeTrees(root1-&gt;left, root2-&gt;left);</span><br><span class="line">        root1-&gt;right = mergeTrees(root1-&gt;right, root2-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root1;</span><br></pre></td></tr></table></figure>

<ul>
<li>94 <a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">二叉树的中序遍历</a><ul>
<li>非递归，复习</li>
</ul>
</li>
<li>96 <a href="https://leetcode.cn/problems/unique-binary-search-trees/" target="_blank" rel="noopener">不同的二叉搜索树</a><ul>
<li><strong>不会，复习！！！</strong></li>
<li>动态规划，巧妙</li>
</ul>
</li>
<li>98 <a href="https://leetcode.cn/problems/validate-binary-search-tree/" target="_blank" rel="noopener">验证二叉搜索树</a><ul>
<li>中序遍历</li>
<li>递归，向下传递范围，复习</li>
</ul>
</li>
<li>101 <a href="https://leetcode.cn/problems/symmetric-tree/" target="_blank" rel="noopener">对称二叉树</a><ul>
<li>递归，控制传入的对称关系，复习</li>
</ul>
</li>
<li>102 <a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">二叉树的层序遍历</a><ul>
<li>利用q.size()</li>
</ul>
</li>
<li>104 <a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">二叉树的最大深度</a></li>
<li>105 <a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">从前序与中序遍历序列构造二叉树</a></li>
<li>114 <a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener">二叉树展开为链表</a><ul>
<li>递归思想</li>
</ul>
</li>
<li>124 <a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/" target="_blank" rel="noopener">二叉树中的最大路径和</a><ul>
<li>递归思想</li>
</ul>
</li>
<li>226 <a href="https://leetcode.cn/problems/invert-binary-tree/" target="_blank" rel="noopener">翻转二叉树</a><ul>
<li>递归思想</li>
</ul>
</li>
<li>236 <a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">二叉树的最近公共祖先</a><ul>
<li>递归思想</li>
</ul>
</li>
<li>297 <a href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/" target="_blank" rel="noopener">二叉树的序列化与反序列化</a><ul>
<li>递归思想</li>
<li>序列化，通过叶子节点的左右子树为空来判断递归到底</li>
<li>字符串转数字：stoi、atoi   负数也可以转换</li>
<li>数字转字符串：to_string</li>
<li>注意可以传引用的尽量传引用，字符串传值和传引用性能差距10倍</li>
</ul>
</li>
<li>337 <a href="https://leetcode.cn/problems/house-robber-iii/" target="_blank" rel="noopener">打家劫舍 III</a><ul>
<li>递归思想</li>
<li>通过空节点判断递归到底，更简洁</li>
</ul>
</li>
<li>437 <a href="https://leetcode.cn/problems/path-sum-iii/" target="_blank" rel="noopener">路径总和 III</a><ul>
<li>递归思想</li>
<li>前缀和</li>
<li>unordered_map中不使用的元素实时移除，性能更高</li>
<li>注意溢出</li>
<li>查看答案 待复习  <ul>
<li>方法1：巧妙  递归的嵌套</li>
<li>方法2：前缀和   注意：利用进入递归更新，推出递归还原</li>
</ul>
</li>
<li>注意考虑是否有负数</li>
</ul>
</li>
<li>538 <a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/" target="_blank" rel="noopener">把二叉搜索树转换为累加树</a><ul>
<li>递归思想</li>
<li>利用全局变量</li>
</ul>
</li>
<li>543 <a href="https://leetcode.cn/problems/diameter-of-binary-tree/" target="_blank" rel="noopener">二叉树的直径</a><ul>
<li>递归思想</li>
</ul>
</li>
<li>617 <a href="https://leetcode.cn/problems/merge-two-binary-trees/" target="_blank" rel="noopener">合并二叉树</a><ul>
<li>递归思想</li>
<li>判断优化</li>
</ul>
</li>
<li>111 <a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">二叉树的最小深度</a></li>
<li>100 <a href="https://leetcode.cn/problems/same-tree/" target="_blank" rel="noopener"> 相同的树</a></li>
<li>222 <a href="https://leetcode.cn/problems/count-complete-tree-nodes/" target="_blank" rel="noopener">完全二叉树的节点个数</a><ul>
<li>利用编号的巧妙性进行位运算   有难度待复习</li>
<li>二分搜索</li>
<li><strong>复习  理解位运算</strong></li>
</ul>
</li>
<li>110 <a href="https://leetcode.cn/problems/balanced-binary-tree/" target="_blank" rel="noopener">平衡二叉树</a></li>
<li>112 <a href="https://leetcode.cn/problems/path-sum/" target="_blank" rel="noopener"> 路径总和</a></li>
<li>404 <a href="https://leetcode.cn/problems/sum-of-left-leaves/" target="_blank" rel="noopener">左叶子之和</a></li>
<li>257 <a href="https://leetcode.cn/problems/binary-tree-paths/" target="_blank" rel="noopener">二叉树的所有路径</a></li>
<li>113 <a href="https://leetcode.cn/problems/path-sum-ii/" target="_blank" rel="noopener">路径总和 II</a></li>
<li>129 <a href="https://leetcode.cn/problems/sum-root-to-leaf-numbers/" target="_blank" rel="noopener">求根节点到叶节点数字之和</a></li>
<li>235 <a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/" target="_blank" rel="noopener">二叉搜索树的最近公共祖先</a><ul>
<li>注意是：二叉搜索树，是有大小关系的</li>
</ul>
</li>
<li>450 <a href="https://leetcode.cn/problems/delete-node-in-a-bst/" target="_blank" rel="noopener">删除二叉搜索树中的节点</a><ul>
<li>递归</li>
<li><strong>重要 复习 迭代 理解指针</strong></li>
</ul>
</li>
<li>108 <a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/" target="_blank" rel="noopener">将有序数组转换为二叉搜索树</a></li>
<li><strong>230</strong> <a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/" target="_blank" rel="noopener">二叉搜索树中第K小的元素</a><ul>
<li>进阶  红黑树</li>
<li><strong>重要 复习  迭代中序遍历</strong></li>
</ul>
</li>
</ul>
<h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><blockquote>
<p>栈存储索引，通过索引取值，就不用存键值对，空间开销更小</p>
<p>在一维数组中对每一个数找到第一个比自己小/大的元素。这类“在一维数组中找第一个满足某种条件的数”的场景就是典型的单调栈应用场景</p>
<ul>
<li>找到右边第一个比自己小的值   <ul>
<li>往右走<ul>
<li>cur比栈顶大则入栈</li>
<li>cur比栈顶小则while(cur比栈顶小)出栈，直到比栈顶大则继续入栈<ul>
<li>出栈元素右边第一个比自己小的元素就是cur, 进行记录</li>
<li><strong>技巧</strong>： cur左边第一个比自己大元素就是cur可以入栈时，栈顶的元素   （典型案例：84）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>典型案例：84</p>
</blockquote>
<ul>
<li><p>739 <a href="https://leetcode.cn/problems/daily-temperatures/" target="_blank" rel="noopener">每日温度</a></p>
<ul>
<li>栈存储index值，通过 t[st[i]]拿到值</li>
</ul>
</li>
<li><p>84 <a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener"> 柱状图中最大的矩形</a></p>
<ul>
<li>找到左边第一个比当前元素小的，找到右边第一个比当前元素小的</li>
<li>注意初始化</li>
</ul>
</li>
<li><p>85 <a href="https://leetcode.cn/problems/maximal-rectangle/" target="_blank" rel="noopener">最大矩形</a></p>
<ul>
<li>需要依赖84才能做出来，没有84的基础基本做不了</li>
</ul>
</li>
<li><p>581 <a href="https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/" target="_blank" rel="noopener">最短无序连续子数组</a></p>
<ul>
<li>感觉和单调栈没啥关系</li>
<li>双指针，模拟正常思考过程</li>
<li>往右走，则需要一直递增，若不满足则记录该位置，该位置是需要往左移动的，往右走完，记录的就是最右需要往左移的位置<ul>
<li>往左走，则需要一直低价，若满足，，，</li>
</ul>
</li>
</ul>
</li>
<li><p>42 <a href="https://leetcode.cn/problems/trapping-rain-water/" target="_blank" rel="noopener">接雨水</a></p>
<ul>
<li>动态规划易理解   推荐</li>
<li>双指针的策略没有理解透彻，复习，对动态规划的优化，不易理解</li>
<li>单调栈不简洁，不易理解</li>
</ul>
</li>
</ul>
<h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><blockquote>
<p>1 先排序有利于解决问题     有重复元素则排序</p>
<p>2 对于重复的元素，采用<strong>标记</strong>的方式，相同的元素只有在前面的元素使用后后面的元素才能使用，保证排列组合不会重复</p>
<p>3 尽可能在原数组上标记，不用额外开空间，节省了空间，性能也更好</p>
</blockquote>
<ul>
<li>17 <a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener"> 电话号码的字母组合</a></li>
<li>22 <a href="https://leetcode.cn/problems/generate-parentheses/" target="_blank" rel="noopener"> 括号生成</a><ul>
<li>不熟练，复习，，，，</li>
<li>每次有两个选择，要么加入’(‘、要么加入’)’, 所以需要回溯保证，每层只加入一种</li>
</ul>
</li>
<li>93 <a href="https://leetcode.cn/problems/restore-ip-addresses/" target="_blank" rel="noopener">复原 IP 地址</a>   重复做，考察细节</li>
<li>131<a href="https://leetcode.cn/problems/palindrome-partitioning/" target="_blank" rel="noopener">分割回文串</a><ul>
<li>回溯+动态规划  提前预处理所有可能的回文串  因为回溯过程中有重复计算</li>
<li>动态规划记录所有回文串  再学习<ul>
<li>从对角线开始往两边扩展</li>
<li>初始化顺序，根据下一步要是的情况，决定这一步先初始化哪里</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划记录所有回文串</span></span><br><span class="line"><span class="comment">// f[i][j] = f[i+1][j-1] &amp;&amp; s[i]==s[j]</span></span><br><span class="line"><span class="comment">// f[i][j] = true &amp;&amp; i &gt;= j</span></span><br><span class="line"><span class="comment">// "aa" f[0][0] = true, f[1][0]==true </span></span><br><span class="line"><span class="comment">// f[0][1] == f[1][0] &amp;&amp; s[0]==s[1]   只有f[1][0]==true 才能保证结果正确</span></span><br><span class="line"></span><br><span class="line">f.assign(n, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n,<span class="literal">true</span>));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;=<span class="number">0</span>; --i)&#123; <span class="comment">// 注意i是从大到小开始初始化，因为递推公式需要用f[i+1][j-1]所以需要先知道i+1</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j&lt;n; ++j)&#123;</span><br><span class="line">    f[i][j] = (s[i] == s[j]) &amp;&amp; f[i+<span class="number">1</span>][j<span class="number">-1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>排列组合</strong></p>
<blockquote>
<p>先排序有利于解决问题</p>
<p>对于重复的元素，采用<strong>标记</strong>的方式，相同的元素只有在前面的元素使用后后面的元素才能使用，保证排列组合不会重复</p>
</blockquote>
<p><strong>全排列</strong></p>
<ul>
<li><p>46 <a href="https://leetcode.cn/problems/permutations/" target="_blank" rel="noopener"> 全排列</a></p>
<ul>
<li>动态维护数组的方式 巧妙 学习</li>
</ul>
</li>
<li><p>47 <a href="https://leetcode.cn/problems/permutations-ii/" target="_blank" rel="noopener">全排列 II</a></p>
<ul>
<li>注意去重的方法  复习</li>
<li>有重复元素且每个元素只能使用一次<ul>
<li>解决方案： 排序，标记使用过的，相同的元素，只有前面一个使用过了后面的才能使用</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>组合</strong></p>
<ul>
<li><p>77 <a href="https://leetcode.cn/problems/combinations/" target="_blank" rel="noopener"> 组合</a></p>
</li>
<li><p>39 <a href="https://leetcode.cn/problems/combination-sum/" target="_blank" rel="noopener">组合总和</a></p>
</li>
<li><p>40 组合总和 II</p>
<ul>
<li>有重复元素且每个元素只能使用一次</li>
</ul>
</li>
<li><p>216 <a href="https://leetcode.cn/problems/combination-sum-iii/" target="_blank" rel="noopener">组合总和 III</a></p>
</li>
<li><p>78 <a href="https://leetcode.cn/problems/subsets/" target="_blank" rel="noopener">子集</a></p>
</li>
<li><p>90 <a href="https://leetcode.cn/problems/subsets-ii/" target="_blank" rel="noopener">子集 II</a></p>
</li>
<li><p>401<a href="https://leetcode.cn/problems/binary-watch/" target="_blank" rel="noopener">二进制手表</a></p>
<ul>
<li>注意官方解答，不要把问题复杂化， 复习</li>
</ul>
</li>
</ul>
<p><strong>二维平面的回溯</strong></p>
<blockquote>
<p>使用偏移量数组简化代码量，但可能影响性能，多了判断</p>
</blockquote>
<ul>
<li>79 <a href="https://leetcode.cn/problems/word-search/" target="_blank" rel="noopener"> 单词搜索</a><ul>
<li>在原数组上进行标记，不用额外开空间，节省了空间</li>
</ul>
</li>
</ul>
<p><strong>floodfill</strong></p>
<ul>
<li><p>200 <a href="https://leetcode.cn/problems/number-of-islands/" target="_blank" rel="noopener"> 岛屿数量</a></p>
<ul>
<li>原数组标记</li>
</ul>
</li>
<li><p>130 <a href="https://leetcode.cn/problems/surrounded-regions/" target="_blank" rel="noopener">被围绕的区域</a></p>
<ul>
<li>原数组标记</li>
<li>位移判断优化和代码简化优化</li>
<li>代码简化会导致压栈太多，可能导致性能不如原始版本</li>
</ul>
</li>
<li><p>417 <a href="https://leetcode.cn/problems/pacific-atlantic-water-flow/" target="_blank" rel="noopener">太平洋大西洋水流问题</a></p>
<ul>
<li>1 参考答案，待复习</li>
<li>2 参考答案内存开销更小</li>
</ul>
</li>
</ul>
<p><strong>n皇后问题</strong></p>
<ul>
<li>51 <a href="https://leetcode.cn/problems/n-queens/" target="_blank" rel="noopener">N 皇后</a><ul>
<li>看解析 看视频讲解8-8  待复习</li>
<li>下图的方式标记斜线是否可以放置，也可以用二进制数来标记(巧妙)<ul>
<li>二进制部分没懂 待学习</li>
</ul>
</li>
</ul>
</li>
<li>52 N皇后2</li>
</ul>
<p><img src="/2022/01/26/C++/hot100/image-20221117203645300.png" alt="image-20221117203645300"></p>
<p><img src="/2022/01/26/C++/hot100/image-20221117203736258.png" alt="image-20221117203736258"></p>
<ul>
<li>37 <a href="https://leetcode.cn/problems/sudoku-solver/" target="_blank" rel="noopener">解数独</a><ul>
<li>参考官方解答，对于3*3块的记录</li>
<li>位运算优化待学习</li>
</ul>
</li>
</ul>
<ul>
<li><p>301 <a href="https://leetcode.cn/problems/remove-invalid-parentheses/" target="_blank" rel="noopener"> 删除无效的括号</a></p>
<ul>
<li>困难，待做</li>
<li>广度优先，最短，最少就用广度优先</li>
<li>不会不会不会</li>
</ul>
</li>
<li><p>494 <a href="https://leetcode.cn/problems/target-sum/" target="_blank" rel="noopener">目标和</a></p>
</li>
<li><p>offer专项081- 087</p>
<ul>
<li>有重复元素则排序，并保证和前一个元素不同，如果和前一个元素相同则continue</li>
<li>无重复元素全排列可以用swap</li>
<li>有重复元素全排需要使用标记，不能用swap, 因为swap后会乱序，导致不能判断和前一个元素是否相同</li>
<li>排序<ul>
<li>保证和前一个元素不同</li>
<li>标记</li>
</ul>
</li>
</ul>
</li>
<li><p>offer专项<a href="https://leetcode.cn/problems/IDBivT/" target="_blank" rel="noopener">085. 生成匹配的括号</a></p>
<ul>
<li>不熟悉，复习</li>
</ul>
</li>
</ul>
<h2 id="广度深度优先"><a href="#广度深度优先" class="headerlink" title="广度深度优先"></a>广度深度优先</h2><blockquote>
<p>在递归开始或者在进入递归前进行标记，这样不容易出错</p>
<p>构建图：</p>
<ul>
<li>字符串等情况，先将字符串映射为数字，便于使用vector存储图结构</li>
</ul>
<p>广度优先：一般用于计算最短路径的场景题</p>
</blockquote>
<p>offer专项 105-</p>
<ul>
<li>106 <a href="https://leetcode.cn/problems/vEAB3K/" target="_blank" rel="noopener">二分图</a><ul>
<li>不熟悉，复习</li>
<li>用序号来标记两个分组</li>
</ul>
</li>
<li>107 <a href="https://leetcode.cn/problems/2bCMpM/" target="_blank" rel="noopener"> 矩阵中的距离</a><ul>
<li>动态规划和广度优先  复习 不熟悉</li>
<li>动态规划<ul>
<li>从某个0到某个1的距离计算，先向下再向右和先向右再向下是等价的</li>
</ul>
</li>
<li>广度优先<ul>
<li>关键点是每次只扩展一步，且对已经扩展的进行标记</li>
</ul>
</li>
</ul>
</li>
<li>108 <a href="https://leetcode.cn/problems/om3reC/" target="_blank" rel="noopener">单词演变</a><ul>
<li>不会， 复习</li>
<li>图的构建不熟悉，复习</li>
<li>遍历记得标记已经遍历的元素</li>
<li>广度优先，找最短路径，记录层数的方法</li>
</ul>
</li>
<li>111 <a href="https://leetcode.cn/problems/vlzXQL/" target="_blank" rel="noopener">计算除法</a><ul>
<li>构建图，不熟悉，复习</li>
<li>广度优先，<strong>记录路径</strong></li>
</ul>
</li>
</ul>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><blockquote>
<p><a href="https://chuckiewill.github.io/2022/01/26/C++/c++algo/" target="_blank" rel="noopener">https://chuckiewill.github.io/2022/01/26/C++/c++algo/</a></p>
</blockquote>
<ul>
<li>42 <a href="https://leetcode.cn/problems/trapping-rain-water/" target="_blank" rel="noopener">接雨水</a></li>
</ul>
<p>offer专项 088-105</p>
<ul>
<li><p>092 <a href="https://leetcode.cn/problems/cyJERH/" target="_blank" rel="noopener">翻转字符</a></p>
<ul>
<li>复习，记录状态简化问题</li>
</ul>
</li>
<li><p>093 <a href="https://leetcode.cn/problems/Q91FMA/" target="_blank" rel="noopener">最长斐波那契数列</a></p>
<ul>
<li>复习，不会</li>
</ul>
</li>
<li><p>094 <a href="https://leetcode.cn/problems/omKAoA/" target="_blank" rel="noopener">最少回文分割</a></p>
<ul>
<li>分两步<ul>
<li>预处理<strong>任意两点区间内是否是回文串</strong>，复习复习复习，巧妙解法</li>
<li>常规动态规划</li>
</ul>
</li>
</ul>
</li>
<li><p>096 <a href="https://leetcode.cn/problems/IY6buf/" target="_blank" rel="noopener"> 字符串交织</a></p>
<ul>
<li>不会，复习</li>
</ul>
</li>
<li><p>097 <a href="https://leetcode.cn/problems/21dk04/" target="_blank" rel="noopener">子序列的数目</a></p>
<ul>
<li>不会，复习</li>
</ul>
</li>
</ul>
<h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><ul>
<li>455</li>
<li>392</li>
<li>435 重叠子序列<ul>
<li>类似 动态规划中求最长递增子序列 300  (O(n^2))</li>
<li>此题用动态规划 不通过 运行时间过长</li>
<li>贪心思路 （O(n)）<ul>
<li>注意:每次选择中，每个区间的结尾很重要</li>
<li>结尾越小，留给了后面越大的空间，</li>
<li>后面越有可能容纳更多区间</li>
<li>按照区间的结尾排序，</li>
<li>每次选择结尾最早的，且和前一个区间不重叠的区间</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按照区间的结尾排序，</span></span><br><span class="line"><span class="comment">// 每次选择结尾最早的，且和前一个区间不重叠的区间</span></span><br></pre></td></tr></table></figure>

<h2 id="牛客面经"><a href="#牛客面经" class="headerlink" title="牛客面经"></a>牛客面经</h2><blockquote>
<p><a href="https://blog.csdn.net/u011386173/article/details/125295165" target="_blank" rel="noopener">有环或无环链表的相交问题</a></p>
<p>情况2：一个链表有环，一个链表无环，这种情况不可能相交     相交后共用  一个有环 另一个一定也有  可以相交在环之前  也可以相交在换上</p>
<p>两个链表相交，且两个链表的入环节点是同一个（loop1 = loop2，就认为 loop1 和 loop2 是终止节点，问题就变成了两个无环链表找第一个相交节点）       loop1 = loop2表示入环点相同 就可以确定是情况2了，，，</p>
<p>重要思想：如果两个单链表有共同的节点，那么从第一个共同节点开始，后面的节点都会重叠，直到链表结束。<br>因为两个链表中有一个共同节点，则这个节点里的指针域指向的下一个节点地址一样，所以下一个节点也会相交，依次类推</p>
</blockquote>
<ol>
<li>怎么判断链表相交</li>
<li>怎么判断链表有环</li>
<li>怎么找到环入口地址？为什么这么找？怎么证明</li>
<li>怎么判断两个有环链表是否相交？</li>
</ol>
<p>求链表的中间结点 </p>
<ul>
<li>快慢指针</li>
<li><a href="https://blog.csdn.net/xiaoyubuhuiqiche/article/details/128163249" target="_blank" rel="noopener">https://blog.csdn.net/xiaoyubuhuiqiche/article/details/128163249</a></li>
</ul>
<p>在二叉树中找路径最长的两个点</p>
<ul>
<li>dfs, 并维护一个长度为2的队列，每次递归到底，深度更深则将该点加入队首，并判断队列长度是否大于2，若大于则删除队尾</li>
</ul>
<h2 id="拼多多-3-12"><a href="#拼多多-3-12" class="headerlink" title="拼多多 3.12"></a>拼多多 3.12</h2><p>多多君最近在研疗一种编码期法、对于连境出机的字花，用变的长提来改元，发提这样可以有</p>
<h1 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h1><p>前缀和+哈希表</p>
<p>位掩码，字符串求交</p>
<p>双指针，有序</p>
<p>滑动窗口，用左右索引记录范围(offer 017 专项)</p>
<p>快慢指针</p>
<ul>
<li><strong>快慢指针定位链表中点时，前面添加dummy，这样定位就正好在中间了</strong></li>
</ul>
<h1 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h1><ul>
<li>注意可以传引用的尽量传引用，字符串传值和传引用性能差距10倍</li>
<li>unordered_map中不使用的元素实时移除，性能更高</li>
<li>多级索引查询，用临时变量存储， 性能快一倍</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=n; ++i)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = target; j &gt;= nums[i<span class="number">-1</span>]; --j)&#123;</span><br><span class="line">        f[j] = f[j] || f[j-nums[i<span class="number">-1</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=n; ++i)&#123;</span><br><span class="line">    <span class="keyword">int</span> a = nums[i<span class="number">-1</span>]; <span class="comment">// 临时变量存储</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = target; j &gt;= a; --j)&#123;</span><br><span class="line">        f[j] = f[j] || f[j-a];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>移除字符串中一个元素 code: 1048<ul>
<li>用substr拼接比erase快一倍，内存消耗也更小，内存消耗大，可能是函数调用</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// substr拼接</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">word</span>.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="built_in">string</span> prev = <span class="keyword">word</span>.substr(<span class="number">0</span>, i) + <span class="keyword">word</span>.substr(i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// erase</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">getEvery</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.erase(index, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">word</span>.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="built_in">string</span> prev = getEvery(<span class="keyword">word</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>存储26个字符<ul>
<li>用vector存储比用unordered_map效率高，开销小</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">mp</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; mp;</span><br></pre></td></tr></table></figure>

<ul>
<li>直接操作字符串各位效率更高</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s :  hh:mm  24小时时间格式，返回分钟数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">toInt</span><span class="params">(<span class="built_in">string</span>&amp; s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> sh = s.substr(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">string</span> sm = s.substr(<span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> h = stoi(sh);</span><br><span class="line">    <span class="keyword">int</span> m = stoi(sm);</span><br><span class="line">    <span class="keyword">return</span> h*<span class="number">60</span> + m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 下面写法效率更高</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">toInt</span><span class="params">(<span class="built_in">string</span>&amp; t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>(t[<span class="number">0</span>] - <span class="string">'0'</span>) * <span class="number">10</span> + <span class="keyword">int</span>(t[<span class="number">1</span>] - <span class="string">'0'</span>)) * <span class="number">60</span> + <span class="keyword">int</span>(t[<span class="number">3</span>] - <span class="string">'0'</span>) * <span class="number">10</span> + <span class="keyword">int</span>(t[<span class="number">4</span>] - <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><ul>
<li>isalnum函数用于判断字符是否为字母（a-z和A-Z）或数字（0-9）</li>
<li>reverse</li>
<li>字符串转数字：stoi、atoi   负数也可以转换  前缀0会剔除</li>
<li>数字转字符串：to_string</li>
<li>unique + erase  数组去重： <a href="https://blog.csdn.net/qq_40713201/article/details/126891262" target="_blank" rel="noopener">c++ unique函数</a></li>
<li>upper_bound(起始迭代器，结束迭代器，比较值a) ：返回严格大于a的元素的迭代器</li>
<li>lower_bound : 指向首个<em>不小于</em> <code>key</code> 的元素的迭代器。若找不到这种元素，则返回尾后迭代器</li>
<li>iota()  升序填充值</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;	</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;number(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	iota(number.<span class="built_in">begin</span>(), number.<span class="built_in">end</span>(), <span class="number">66</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; number[i] &lt;&lt; <span class="string">" "</span>;		<span class="comment">//输出：66 67 68 69 70 71 72 73 74 75</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://blog.csdn.net/VariatioZbw/article/details/125257536" target="_blank" rel="noopener">accumulate</a><ul>
<li>类似js中reduce</li>
</ul>
</li>
<li><a href="https://blog.csdn.net/weixin_44162361/article/details/115790452" target="_blank" rel="noopener">memset</a><ul>
<li><code>void *memset(void *s, int c, size_t n);</code><ul>
<li>s指向要填充的内存块。</li>
<li>c是要被设置的值。</li>
<li>n是要被设置该值的字符数。</li>
<li>返回类型是一个指向存储区s的指针。</li>
</ul>
</li>
</ul>
</li>
<li>reverse  </li>
<li>复杂度:恰好交换 <code>(last - first)/2</code> 次</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::reverse(<span class="built_in">std</span>::<span class="built_in">begin</span>(a), <span class="built_in">std</span>::<span class="built_in">end</span>(a));</span><br></pre></td></tr></table></figure>

<ul>
<li>find</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">auto</span> result1 = <span class="built_in">std</span>::<span class="built_in">find</span>(<span class="built_in">std</span>::<span class="built_in">begin</span>(v), <span class="built_in">std</span>::<span class="built_in">end</span>(v), n1);</span><br></pre></td></tr></table></figure>

<ul>
<li>sort</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::sort(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), <span class="built_in">std</span>::greater&lt;<span class="keyword">int</span>&gt;());<span class="comment">// 按降序，  默认是升序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义比较函数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(a[<span class="number">0</span>] != b[<span class="number">0</span>])&#123;</span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>]; <span class="comment">// 起始点小的在前</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>]; <span class="comment">// 起始点相同的情况下，终止点小的在前</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals;<span class="comment">// 存储的是顶点对  [[1,2],[2,3],[3,4],[1,3]]</span></span><br><span class="line">sort(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), compare);</span><br><span class="line"></span><br><span class="line"><span class="comment">// lambda写法</span></span><br><span class="line">sort(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), [](<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b)&#123;</span><br><span class="line">  <span class="keyword">if</span>(a[<span class="number">0</span>] != b[<span class="number">0</span>])&#123;</span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>]; <span class="comment">// 起始点小的在前</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>]; <span class="comment">// 起始点相同的情况下，终止点小的在前</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>C++中的__builtin_popcount()</li>
</ul>
<blockquote>
<p><a href="https://blog.csdn.net/weixin_44915226/article/details/105367005" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44915226/article/details/105367005</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">该函数是C++自带的库函数，内部实现是用查表实现的。</span><br><span class="line">作用：统计数字在二进制下“<span class="number">1</span>”的个数。</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>   </span><br><span class="line"><span class="keyword">int</span> num = __builtin_popcount(a)  <span class="comment">// num = 1   2的二进制是10</span></span><br></pre></td></tr></table></figure>

<ul>
<li>tie()<ul>
<li>解包，类似js中的解构</li>
</ul>
</li>
</ul>
<blockquote>
<p><a href="https://blog.csdn.net/lllzzzhhh2589/article/details/121584299" target="_blank" rel="noopener">https://blog.csdn.net/lllzzzhhh2589/article/details/121584299</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">float</span> d;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> S&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="comment">// 比较 n 与 rhs.n,</span></span><br><span class="line">        <span class="comment">// 而后为 s 与 rhs.s,</span></span><br><span class="line">        <span class="comment">// 而后为 d 与 rhs.d</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::tie(n, s, d) &lt; <span class="built_in">std</span>::tie(rhs.n, rhs.s, rhs.d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">S value&#123;<span class="number">42</span>, <span class="string">"Test"</span>, <span class="number">3.14</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">double</span> d;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"></span><br><span class="line">tie(i, d, s) = t3;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; d &lt;&lt; <span class="string">" "</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//打印： 42 3.14 Test</span></span><br></pre></td></tr></table></figure>

<ul>
<li>向上向下四舍五入取整（以下只针对浮点数的运算）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向上  </span></span><br><span class="line"><span class="built_in">ceil</span>()</span><br><span class="line"><span class="comment">// 向下</span></span><br><span class="line"><span class="built_in">floor</span>()</span><br><span class="line"><span class="comment">// 四舍五入</span></span><br><span class="line">round()</span><br></pre></td></tr></table></figure>

<ul>
<li>整数向上取整</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">int</span> curh = p%mode == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">curh += (p/mode);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">int</span> curh = (p + mode<span class="number">-1</span>)/mode;</span><br></pre></td></tr></table></figure>



<h1 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h1><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><h3 id="stack、vector、list、queue常用方法"><a href="#stack、vector、list、queue常用方法" class="headerlink" title="stack、vector、list、queue常用方法"></a>stack、vector、list、queue常用方法</h3><p>stack</p>
<ul>
<li><p>top</p>
</li>
<li><p>push</p>
</li>
<li><p>pop</p>
</li>
</ul>
<p>priority_queue</p>
<ul>
<li><p>top</p>
</li>
<li><p>push</p>
</li>
<li><p>pop</p>
</li>
</ul>
<p>queue</p>
<ul>
<li>front</li>
<li>back</li>
<li>push</li>
<li>pop</li>
</ul>
<p>vector</p>
<ul>
<li>front</li>
<li>back</li>
<li>push_back</li>
<li>pop_back</li>
<li>erase</li>
<li><a href="https://zh.cppreference.com/w/cpp/container/deque/shrink_to_fit" target="_blank" rel="noopener">shrink_to_fit</a></li>
</ul>
<p>deque</p>
<ul>
<li>front</li>
<li>back</li>
<li>push_front</li>
<li>pop_front</li>
<li>push_back</li>
<li>pop_back</li>
<li>erase</li>
<li><a href="https://zh.cppreference.com/w/cpp/container/deque/shrink_to_fit" target="_blank" rel="noopener">shrink_to_fit</a></li>
</ul>
<p>list</p>
<ul>
<li>front</li>
<li>back</li>
<li>push_front</li>
<li>pop_front</li>
<li>push_back</li>
<li>pop_back</li>
<li>erase</li>
</ul>
<h3 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h3><ul>
<li>默认是最大堆</li>
<li>改为最小堆</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>自定义比较函数</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 个位数大的在前</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCom</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a%<span class="number">10</span> &lt; b%<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;int, vector&lt;int&gt;, decltype(myCom)&gt; pq(myCom);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转为最小堆</span></span><br><span class="line"><span class="keyword">auto</span> cmp = [](ListNode* l1, ListNode* l2)&#123;</span><br><span class="line">  <span class="keyword">return</span> l1-&gt;val &gt; l2-&gt;val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, decltype(cmp)&gt; pq(cmp); // decltype 用于数据类型的推导</span><br></pre></td></tr></table></figure>

<h3 id><a href="#" class="headerlink" title></a></h3><h3 id="二分查找-1"><a href="#二分查找-1" class="headerlink" title="二分查找"></a>二分查找</h3><table>
<thead>
<tr>
<th><a href="https://zh.cppreference.com/w/cpp/container/map/lower_bound" target="_blank" rel="noopener">lower_bound</a></th>
<th>返回指向首个<em>不小于</em>给定键的元素的迭代器 (公开成员函数)</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://zh.cppreference.com/w/cpp/container/map/upper_bound" target="_blank" rel="noopener">upper_bound</a></td>
<td>返回指向首个<em>大于</em>给定键的元素的迭代器</td>
</tr>
</tbody></table>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>容器为空的情况下可以调用 mp.count(key)</p>
<p>容器为空的情况下查找返回的迭代器为 mp.end() ,   而容器为空的情况下mp.begin() == mp.end()</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; mp;  <span class="comment">// 报错</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; mp; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>





<h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><h5 id="数据对"><a href="#数据对" class="headerlink" title="数据对"></a>数据对</h5><ul>
<li>没有对数，没有结束标志</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入包括两个正整数a,b(<span class="number">1</span> &lt;= a, b &lt;= <span class="number">1000</span>),输入数据包括多组。</span><br><span class="line"></span><br><span class="line">输入例子：</span><br><span class="line"><span class="number">1</span> <span class="number">5</span></span><br><span class="line"><span class="number">10</span> <span class="number">20</span></span><br><span class="line">输出例子：</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b) &#123; <span class="comment">// 注意 while 处理多个 case</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a + b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>有结束标志</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">输入包括两个正整数a,b(<span class="number">1</span> &lt;= a, b &lt;= <span class="number">10</span>^<span class="number">9</span>),输入数据有多组, 如果输入为<span class="number">0</span> <span class="number">0</span>则结束输入</span><br><span class="line">输入例子：</span><br><span class="line"><span class="number">1</span> <span class="number">5</span></span><br><span class="line"><span class="number">10</span> <span class="number">20</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span>  </span><br><span class="line">输出例子：</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">30</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b) &#123; <span class="comment">// 注意 while 处理多个 case</span></span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">0</span> &amp;&amp; b == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a + b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="多行数据"><a href="#多行数据" class="headerlink" title="多行数据"></a>多行数据</h5><ul>
<li>有结束标志</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">输入数据包括多组。</span><br><span class="line">每组数据一行,每行的第一个整数为整数的个数n(<span class="number">1</span> &lt;= n &lt;= <span class="number">100</span>), n为<span class="number">0</span>的时候结束输入。</span><br><span class="line">接下来n个正整数,即需要求和的每个正整数。</span><br><span class="line"></span><br><span class="line">输入例子：</span><br><span class="line"><span class="number">4</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">5</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">输出例子：</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nums</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; nums[i];</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>有行数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">输入的第一行包括一个正整数t(<span class="number">1</span> &lt;= t &lt;= <span class="number">100</span>), 表示数据组数。</span><br><span class="line">接下来t行, 每行一组数据。</span><br><span class="line">每行的第一个整数为整数的个数n(<span class="number">1</span> &lt;= n &lt;= <span class="number">100</span>)。</span><br><span class="line">接下来n个正整数, 即需要求和的每个正整数。</span><br><span class="line"></span><br><span class="line">输入例子：</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">5</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">输出例子：</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nums</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; nums[i];</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>没有行数，没有结束标志</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">输入数据有多组, 每行表示一组输入数据。</span><br><span class="line">每行的第一个整数为整数的个数n(<span class="number">1</span> &lt;= n &lt;= <span class="number">100</span>)。</span><br><span class="line">接下来n个正整数, 即需要求和的每个正整数。</span><br><span class="line"></span><br><span class="line">输入例子：</span><br><span class="line"><span class="number">4</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">5</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">输出例子：</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> <span class="built_in">line</span>;</span><br><span class="line">    <span class="keyword">while</span> (getline(<span class="built_in">cin</span>, <span class="built_in">line</span>)) &#123;</span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(<span class="built_in">line</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> n ;</span><br><span class="line">        ss &gt;&gt; n;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">vec</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ss &gt;&gt; vec[i];</span><br><span class="line">            sum += vec[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>没有每行数据个数，没有行数，没有结束标志</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">输入数据有多组, 每行表示一组输入数据。</span><br><span class="line"></span><br><span class="line">每行不定有n个整数，空格隔开。(<span class="number">1</span> &lt;= n &lt;= <span class="number">100</span>)。</span><br><span class="line">    </span><br><span class="line">输入例子：</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">输出例子：</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> <span class="built_in">line</span>;</span><br><span class="line">    <span class="keyword">while</span> (getline(<span class="built_in">cin</span>, <span class="built_in">line</span>)) &#123;</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">iss</span><span class="params">(<span class="built_in">line</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> num;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">        <span class="keyword">while</span> (iss &gt;&gt; num) &#123;</span><br><span class="line">            vec.push_back(num);</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// for(int i = 0; i &lt; vec.size(); ++i)&#123;</span></span><br><span class="line">        <span class="comment">//     cout&lt;&lt;vec[i]&lt;&lt;" ";</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// cout&lt;&lt;endl;</span></span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="多个字符串"><a href="#多个字符串" class="headerlink" title="多个字符串"></a>多个字符串</h5><ul>
<li>给定个数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">输入有两行，第一行n</span><br><span class="line"></span><br><span class="line">第二行是n个字符串，字符串之间用空格隔开</span><br><span class="line"></span><br><span class="line">输入例子：</span><br><span class="line"><span class="number">5</span></span><br><span class="line">c d a bb e</span><br><span class="line">输出例子：</span><br><span class="line">a bb c d e</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">  <span class="built_in">cin</span>.ignore();</span><br><span class="line">  <span class="built_in">string</span> <span class="built_in">line</span>;</span><br><span class="line">  getline(<span class="built_in">cin</span>,<span class="built_in">line</span>);</span><br><span class="line">  <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(<span class="built_in">line</span>)</span></span>;</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">vec</span><span class="params">(n)</span></span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">    ss&gt;&gt;vec[i];</span><br><span class="line">  &#125;</span><br><span class="line">  sort(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n; ++i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i != n<span class="number">-1</span>)</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; vec[i]&lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt; vec[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>多行字符串</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">多个测试用例，每个测试用例一行。</span><br><span class="line"></span><br><span class="line">每行通过空格隔开，有n个字符，n＜<span class="number">100</span></span><br><span class="line"></span><br><span class="line">输入例子：</span><br><span class="line">a c bb</span><br><span class="line">f dddd</span><br><span class="line">nowcoder</span><br><span class="line">输出例子：</span><br><span class="line">a bb c</span><br><span class="line">dddd f</span><br><span class="line">nowcoder</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">string</span> <span class="built_in">line</span>;</span><br><span class="line">  <span class="keyword">while</span> (getline(<span class="built_in">cin</span>, <span class="built_in">line</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="built_in">istringstream</span> <span class="title">iss</span><span class="params">(<span class="built_in">line</span>)</span></span>;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vec;</span><br><span class="line">    <span class="keyword">while</span> (iss&gt;&gt;s)</span><br><span class="line">    &#123;</span><br><span class="line">      vec.push_back(s);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;vec.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">      <span class="keyword">if</span>(i!=vec.<span class="built_in">size</span>() <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;vec[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;vec[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>多行字符串，每个字符串用逗号隔开</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">多个测试用例，每个测试用例一行。</span><br><span class="line">每行通过,隔开，有n个字符，n＜<span class="number">100</span></span><br><span class="line"></span><br><span class="line">输入例子：</span><br><span class="line">a,c,bb</span><br><span class="line">f,dddd</span><br><span class="line">nowcoder</span><br><span class="line">输出例子：</span><br><span class="line">a,bb,c</span><br><span class="line">dddd,f</span><br><span class="line">nowcoder</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> <span class="built_in">line</span>;</span><br><span class="line">    <span class="keyword">while</span> (getline(<span class="built_in">cin</span>, <span class="built_in">line</span>)) &#123;</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">iss</span><span class="params">(<span class="built_in">line</span>)</span></span>;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vec;</span><br><span class="line">        <span class="keyword">while</span> (getline(iss, s, <span class="string">','</span>)) &#123;</span><br><span class="line">            vec.push_back(s);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; vec.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != vec.<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; vec[i] &lt;&lt; <span class="string">","</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; vec[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串-1"><a href="#字符串-1" class="headerlink" title="字符串"></a>字符串</h2><blockquote>
<p><a href="http://c.biancheng.net/c/ascii/" target="_blank" rel="noopener">ASCII码一览表</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INT_MAX = <span class="number">2</span>^<span class="number">31</span><span class="number">-1</span>;</span><br><span class="line">INT_MIN = <span class="number">-2</span>^<span class="number">31</span></span><br></pre></td></tr></table></figure>

<p><strong>字符串转int</strong></p>
<p>atoi()和stoi()</p>
<ul>
<li>atoi()和stoi()函数都是只转换字符串的数字部分，如果遇到其它字符的话则停止转换</li>
<li>只返回有效数字 0123返回123</li>
</ul>
<blockquote>
<p><a href="https://www.jianshu.com/p/e700ac920249" target="_blank" rel="noopener">atoi()和stoi()的区别</a></p>
</blockquote>
<ul>
<li><p>相同点</p>
<ul>
<li><p>都是C++的字符处理函数，把数字字符串转换成int输出</p>
</li>
<li><p>头文件都是<code>#include&lt;cstring&gt;</code></p>
</li>
</ul>
</li>
<li><p>不同点</p>
</li>
<li><p>&lt;1&gt;参数类型不同</p>
<ul>
<li><p><code>atoi()</code>的参数是 <code>const char*</code> ,因此对于一个字符串str我们必须调用 <code>c_str()</code>的方法把这个<code>string</code>转换成 <code>const char*</code>类型。</p>
</li>
<li><p><code>stoi()</code>的参数是<code>const string&amp;</code>,不需要转化为 <code>const char*</code></p>
</li>
</ul>
</li>
<li><p>&lt;2&gt;范围检查</p>
<ul>
<li><code>atoi()</code>不会做范围检查，如果超出范围的话，超出上界，则输出上界，超出下界，则输出下界；</li>
<li><code>stoi()</code>会做范围检查，默认范围是在int的范围内的，如果超出范围的话则会吐核超出范围。</li>
</ul>
</li>
</ul>
<p><img src="https:////upload-images.jianshu.io/upload_images/20260225-f580a07018d6c8c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/627/format/webp" alt="img"></p>
<p><strong>string转char</strong></p>
<p>c_str()</p>
<blockquote>
<p><a href="https://blog.csdn.net/YXXXYX/article/details/119957061" target="_blank" rel="noopener">C++中的 c_str() 函数</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *ptr;</span><br><span class="line">	<span class="built_in">string</span> s = <span class="string">"12345"</span>;</span><br><span class="line">    ptr = s.c_str();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"s改变前ptr为："</span> &lt;&lt; ptr &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    s = <span class="string">"66666"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"s改变后ptr为："</span> &lt;&lt; ptr &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>int转string</strong></p>
<p>to_string()</p>
<p><strong>大小写字符转换</strong></p>
<p><a href="https://blog.csdn.net/laozhuxinlu/article/details/51539737?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-51539737-blog-105710187.pc_relevant_3mothn_strategy_recovery&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-51539737-blog-105710187.pc_relevant_3mothn_strategy_recovery&utm_relevant_index=1" target="_blank" rel="noopener">tolower/toupper</a> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctype.h&gt;   // c++中使用不用引入头文件</span></span></span><br><span class="line"><span class="comment">// 只能单个字符转换</span></span><br></pre></td></tr></table></figure>

<p><strong>判断字符数字</strong></p>
<ul>
<li>isalnum函数用于判断字符是否为字母（a-z和A-Z）或数字（0-9）</li>
</ul>
<p>isalnum</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctype.h&gt; // c++中使用不用引入头文件</span></span></span><br></pre></td></tr></table></figure>

<p><strong>string移除最后一个元素</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">"string!"</span>;</span><br><span class="line">s.pop_back(); <span class="comment">// c++11 新语法</span></span><br></pre></td></tr></table></figure>

<p><strong>string追加char</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">"abc"</span>;</span><br><span class="line"><span class="keyword">char</span> c = <span class="string">'d'</span>;</span><br><span class="line"><span class="comment">// 方式1</span></span><br><span class="line">s += c;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// 方式2</span></span><br><span class="line">s.push_back(c);</span><br></pre></td></tr></table></figure>

<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><blockquote>
<p><a href="https://blog.csdn.net/m0_64183293/article/details/122519405" target="_blank" rel="noopener">https://blog.csdn.net/m0_64183293/article/details/122519405</a></p>
<p>GCC自带的一些builtin内建函数 ：<a href="https://blog.csdn.net/tjcwt2011/article/details/118154919" target="_blank" rel="noopener">https://blog.csdn.net/tjcwt2011/article/details/118154919</a></p>
</blockquote>
<ul>
<li>C++中的__builtin_popcount()</li>
</ul>
<blockquote>
<p><a href="https://blog.csdn.net/weixin_44915226/article/details/105367005" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44915226/article/details/105367005</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">该函数是C++自带的库函数，内部实现是用查表实现的。</span><br><span class="line">作用：统计数字在二进制下“<span class="number">1</span>”的个数。</span><br></pre></td></tr></table></figure>

<ul>
<li>__builtin_ctz<ul>
<li>这个函数作用是返回输入数二进制表示从最低位开始(右起)的连续的0的个数；如果传入0则行为未定义</li>
</ul>
</li>
</ul>
<p><strong>二进制1个数</strong></p>
<blockquote>
<p><a href="https://leetcode.cn/problems/hamming-distance/" target="_blank" rel="noopener">三种求二进制1个数的办法</a></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 __builtin_popcount</span><br><span class="line">2 x &gt;&gt; 1  x &amp; 1   右移，末尾和1与</span><br><span class="line">3 x &#x3D; x &amp; (x-1)</span><br></pre></td></tr></table></figure>

<p><strong>位与位异或位或</strong></p>
<blockquote>
<p><a href="https://blog.csdn.net/m0_37782602/article/details/122863949" target="_blank" rel="noopener">https://blog.csdn.net/m0_37782602/article/details/122863949</a></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">位与 &amp;  0&amp;0&#x3D;0; 0&amp;1&#x3D;0; 1&amp;0&#x3D;0; 1&amp;1&#x3D;1;</span><br><span class="line">位异或 ^ 0^0&#x3D;0； 0^1&#x3D;1； 1^0&#x3D;1； 1^1&#x3D;0；</span><br><span class="line">位或 |  0|0&#x3D;0； 0|1&#x3D;1； 1|0&#x3D;1； 1|1&#x3D;1；</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Brian Kernighan 算法的原理是：对于任意整数x, 令 x = x &amp; (x<span class="number">-1</span>) 该运算将 x 的二进制表示的最后一个 <span class="number">1</span> 变成 <span class="number">0</span></span><br></pre></td></tr></table></figure>



<h2 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1e9</span>+<span class="number">7</span> <span class="comment">// 10^9+7  一个比较大的质数</span></span><br></pre></td></tr></table></figure>

<p><strong>取绝对值</strong></p>
<p>abs()</p>
<p><strong>使用最大最小值</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;limits.h&gt;</span><br><span class="line">LONG_MIN</span><br><span class="line">L</span><br></pre></td></tr></table></figure>



<p>保留小数点后n位**</p>
<blockquote>
<p><a href="https://zhidao.baidu.com/question/1431242996370114299.html" target="_blank" rel="noopener">https://zhidao.baidu.com/question/1431242996370114299.html</a></p>
</blockquote>
<ul>
<li>setprecision(n) : 表示保留n位，整体保留的位数</li>
<li>fixed： 表示以小数点后开始记保留的位数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">double</span> cur = <span class="number">4.6666667</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;setprecision(<span class="number">4</span>)&lt;&lt;cur&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 4.667</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="number">4</span>)&lt;&lt;cur&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 4.6667</span></span><br></pre></td></tr></table></figure>




    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/" rel="tag"># 算法总结</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/01/26/C++/c++bagu/" rel="prev" title="C++八股总结">
      <i class="fa fa-chevron-left"></i> C++八股总结
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/01/26/C++/c++network/" rel="next" title="网络编程学习笔记">
      网络编程学习笔记 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#hot-100"><span class="nav-text">hot 100</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#hot-100（add）"><span class="nav-text">hot 100（add）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#剑指offer-专项突破"><span class="nav-text">剑指offer(专项突破)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#每日一题"><span class="nav-text">每日一题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#题型"><span class="nav-text">题型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#数组"><span class="nav-text">数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#查找"><span class="nav-text">查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#差分数组"><span class="nav-text">差分数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数学"><span class="nav-text">数学</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串"><span class="nav-text">字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线段树"><span class="nav-text">线段树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二进制"><span class="nav-text">二进制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二分查找"><span class="nav-text">二分查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#栈、队列"><span class="nav-text">栈、队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#链表"><span class="nav-text">链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#树"><span class="nav-text">树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#单调栈"><span class="nav-text">单调栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#回溯"><span class="nav-text">回溯</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#广度深度优先"><span class="nav-text">广度深度优先</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态规划"><span class="nav-text">动态规划</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#贪心"><span class="nav-text">贪心</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#牛客面经"><span class="nav-text">牛客面经</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#拼多多-3-12"><span class="nav-text">拼多多 3.12</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#PS"><span class="nav-text">PS</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#性能"><span class="nav-text">性能</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#函数"><span class="nav-text">函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#常用"><span class="nav-text">常用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#STL"><span class="nav-text">STL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#stack、vector、list、queue常用方法"><span class="nav-text">stack、vector、list、queue常用方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#priority-queue"><span class="nav-text">priority_queue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#"><span class="nav-text"></span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二分查找-1"><span class="nav-text">二分查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#注意点"><span class="nav-text">注意点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#输入输出"><span class="nav-text">输入输出</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#数据对"><span class="nav-text">数据对</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#多行数据"><span class="nav-text">多行数据</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#多个字符串"><span class="nav-text">多个字符串</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串-1"><span class="nav-text">字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#位运算"><span class="nav-text">位运算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数值"><span class="nav-text">数值</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Chuckie"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Chuckie</p>
  <div class="site-description" itemprop="description">Bright future</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">116</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">57</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">100</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/ChuckieWill" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ChuckieWill" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/codewyj.163.com" title="E-Mail → codewyj.163.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.jianshu.com/u/de627226656c" title="https:&#x2F;&#x2F;www.jianshu.com&#x2F;u&#x2F;de627226656c" rel="noopener" target="_blank">简书</a>
        </li>
    </ul>
  </div>

      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="/images/me.png"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chuckie</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">1.1m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">17:04</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
