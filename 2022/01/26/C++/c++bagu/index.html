<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="阿秀C&#x2F;C++">
<meta property="og:type" content="article">
<meta property="og:title" content="C++八股总结">
<meta property="og:url" content="http://yoursite.com/2022/01/26/C++/c++bagu/index.html">
<meta property="og:site_name" content="Chuckie&#39;s Blog">
<meta property="og:description" content="阿秀C&#x2F;C++">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/c++bagu/image-20230106145803859.png">
<meta property="og:image" content="http://yoursite.com/2022/01/26/C++/c++bagu/image-20230106150451923.png">
<meta property="article:published_time" content="2022-01-26T06:43:17.000Z">
<meta property="article:modified_time" content="2024-09-18T15:06:07.437Z">
<meta property="article:author" content="Chuckie">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2022/01/26/C++/c++bagu/image-20230106145803859.png">

<link rel="canonical" href="http://yoursite.com/2022/01/26/C++/c++bagu/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>C++八股总结 | Chuckie's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Chuckie's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/01/26/C++/c++bagu/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Chuckie">
      <meta itemprop="description" content="Bright future">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chuckie's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++八股总结
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-26 14:43:17" itemprop="dateCreated datePublished" datetime="2022-01-26T14:43:17+08:00">2022-01-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-09-18 23:06:07" itemprop="dateModified" datetime="2024-09-18T23:06:07+08:00">2024-09-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>15k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>14 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="阿秀"><a href="#阿秀" class="headerlink" title="阿秀"></a>阿秀</h1><h1 id="C-C"><a href="#C-C" class="headerlink" title="C/C++"></a>C/C++</h1><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><h5 id="1、-在main执行之前和之后执行的代码可能是什么？"><a href="#1、-在main执行之前和之后执行的代码可能是什么？" class="headerlink" title="1、 在main执行之前和之后执行的代码可能是什么？"></a>1、 在main执行之前和之后执行的代码可能是什么？</h5><ul>
<li>执行之前<ul>
<li>设置栈指针</li>
<li>初始化静态变量、全局变量  .data</li>
<li>将为初始化的静态变量和全局变量赋初值，.bss</li>
<li>全局对象构造函数</li>
</ul>
</li>
<li>执行之后<ul>
<li>全局对象析构函数</li>
</ul>
</li>
</ul>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><h5 id="2、结构体内存对齐问题？"><a href="#2、结构体内存对齐问题？" class="headerlink" title="2、结构体内存对齐问题？"></a>2、结构体内存对齐问题？</h5><ul>
<li><p><code>alignof</code>可以计算出类型的对齐方式，<code>alignas</code>可以指定结构体的对齐方式</p>
<ul>
<li>alignas设置的大小是整体的对齐大小</li>
</ul>
</li>
<li><p>如果想使用单字节对齐的方式，使用<code>alignas</code>是无效的。应该使用<code>#pragma pack(push,1)</code>或者使用<code>__attribute__((packed))</code></p>
</li>
</ul>
<h5 id="70、如何获得结构成员相对于结构开头的字节偏移量"><a href="#70、如何获得结构成员相对于结构开头的字节偏移量" class="headerlink" title="70、如何获得结构成员相对于结构开头的字节偏移量"></a>70、如何获得结构成员相对于结构开头的字节偏移量</h5><ul>
<li><pre><code class="cpp">offsetof(S, x)
&lt;!--￼<span class="number">0</span>--&gt;
<span class="keyword">int</span> *p[<span class="number">10</span>]
<span class="keyword">int</span> (*p)[<span class="number">10</span>]
<span class="function"><span class="keyword">int</span> *<span class="title">p</span><span class="params">(<span class="keyword">int</span>)</span></span>
<span class="function"><span class="title">int</span> <span class="params">(*p)</span><span class="params">(<span class="keyword">int</span>)</span></span>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 17、常量指针和指针常量区别</span><br><span class="line"></span><br><span class="line">* 指针常量是一个指针，指针指向可变，但指向的变量不可变，底层const : &#96;int const *p或const int *p&#96;</span><br><span class="line">* 常量指针是一个指针，指向不可变，顶层const：&#96;int *const p&#96;</span><br><span class="line"></span><br><span class="line">##### 18、a和&amp;a有什么区别</span><br><span class="line"></span><br><span class="line">&gt; [指针数组和数组指针](https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_48757526&#x2F;article&#x2F;details&#x2F;124686346)</span><br><span class="line">&gt;</span><br><span class="line">&gt; [重点看：关于指针数组与数组指针详解（知识点全面）](https:&#x2F;&#x2F;blog.csdn.net&#x2F;lirendada&#x2F;article&#x2F;details&#x2F;122931987?utm_medium&#x3D;distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-122931987-blog-124686346.235^v35^pc_relevant_anti_vip&amp;spm&#x3D;1001.2101.3001.4242.1&amp;utm_relevant_index&#x3D;3)</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;c++</span><br><span class="line">int main()&#123;</span><br><span class="line">    int a[10] &#x3D; &#123;1,2,3,4,5,6,7,8,9&#125;; </span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;  &#x2F;&#x2F; 0x7ffdc1d33c60</span><br><span class="line">    cout&lt;&lt;*a&lt;&lt;endl; &#x2F;&#x2F; 1</span><br><span class="line">    cout&lt;&lt;*(a+1)&lt;&lt;endl; &#x2F;&#x2F; 2</span><br><span class="line">    int (*p)[10] &#x3D; &amp;a; &#x2F;&#x2F; 二维数组的指针 *(p+1)就越界了</span><br><span class="line">    cout&lt;&lt;*p&lt;&lt;endl;  &#x2F;&#x2F; 0x7ffdc1d33c60  相当于a   就是首地址</span><br><span class="line">    cout&lt;&lt;(*p)[0]&lt;&lt;endl;  &#x2F;&#x2F; 1          相当于a[0]</span><br><span class="line">    cout&lt;&lt;*(*p)&lt;&lt;endl;  &#x2F;&#x2F; 1            相当于*a</span><br><span class="line">    &#x2F;&#x2F; cout&lt;&lt;*(*(p+1))&lt;&lt;endl; &#x2F;&#x2F; 越界  p+1: 这里+1的步长是数组的长度</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    int *p1 &#x3D; a;  &#x2F;&#x2F; 此时p1就等同于a      **关键点a就是一个指针， a给p赋值就是把a本身的值给p**  a和p1都是变量名，通过查表找到的地址就是数组的首地址，也就是他们本身就是数组的首地址</span><br><span class="line">    cout&lt;&lt;p1&lt;&lt;endl;  &#x2F;&#x2F; 0x7ffdc1d33c60</span><br><span class="line">    cout&lt;&lt;*p1&lt;&lt;endl; &#x2F;&#x2F; 1 </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int a[3][4] &#x3D; &#123; &#123;0, 1, 2, 3&#125;, &#123;4, 5, 6, 7&#125;, &#123;8, 9, 10, 11&#125; &#125;;</span><br><span class="line">    int (*p)[4] &#x3D; a;   &#x2F;&#x2F; 此时p就是a  相当于p就是a的别名</span><br><span class="line">    &#x2F;&#x2F; a[i][j] &#x3D;&#x3D; p[i][j] &#x3D;&#x3D; *(a[i]+j) &#x3D;&#x3D; *(p[i]+j) &#x3D;&#x3D; *(*(a+i)+j) &#x3D;&#x3D; *(*(p+i)+j)</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h5 id="26、数组名和指针（这里为指向数组首元素的指针）区别"><a href="#26、数组名和指针（这里为指向数组首元素的指针）区别" class="headerlink" title="26、数组名和指针（这里为指向数组首元素的指针）区别"></a>26、数组名和指针（这里为指向数组首元素的指针）区别</h5><ul>
<li>数组名相当于一个常量指针<ul>
<li>不过sizeof返回的数组长度</li>
<li>不能进行自增、自减操作（a++, a–）</li>
<li>可以进行增减偏移量操作（a+1, a-1）</li>
</ul>
</li>
<li><strong>当数组名当做形参传递给调用函数</strong>   此时数组名和指针完全一样<ul>
<li><strong>就失去了原有特性，退化成一般指针，多了自增、自减操作</strong></li>
<li><strong>但sizeof运算符不能再得到原数组的大小了,而是指针的大小</strong></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;; </span><br><span class="line">    <span class="keyword">int</span> b[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;; </span><br><span class="line">    <span class="comment">// a = b; // error a是一个常量指针，不能赋值</span></span><br><span class="line">    <span class="comment">// ++a; // 报错，不能自增，自减， 因为指向不可变</span></span><br><span class="line">    <span class="comment">// a++; // 报错，不能自增，自减， 因为指向不可变</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">// 0x7ffdc1d33c60</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*a&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*(a+<span class="number">1</span>)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="74、指针加减计算要注意什么？"><a href="#74、指针加减计算要注意什么？" class="headerlink" title="74、指针加减计算要注意什么？"></a>74、指针加减计算要注意什么？</h5><ul>
<li>加减的步长由数据类型确定</li>
</ul>
<h5 id="31、野指针和悬空指针"><a href="#31、野指针和悬空指针" class="headerlink" title="31、野指针和悬空指针"></a>31、野指针和悬空指针</h5><ul>
<li>野指针：定义后未初始化，指向不明</li>
<li>悬空指针：指向内存释放后，没有置为nullptr</li>
</ul>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><h5 id="22、C-中struct和class的区别"><a href="#22、C-中struct和class的区别" class="headerlink" title="22、C++中struct和class的区别"></a>22、C++中struct和class的区别</h5><ul>
<li>struct成员默认是公有、默认是public继承</li>
<li>class成员默认是私有、默认是private继承</li>
</ul>
<h5 id="28、拷贝初始化和直接初始化"><a href="#28、拷贝初始化和直接初始化" class="headerlink" title="28、拷贝初始化和直接初始化"></a>28、拷贝初始化和直接初始化</h5><ul>
<li>使用explicit修饰构造函数时：如果构造函数存在隐式转换，编译时会报错<ul>
<li>例如语句3和4就是隐式类型转换</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str1</span><span class="params">(<span class="string">"I am a string"</span>)</span></span>;<span class="comment">//语句1 直接初始化</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str2</span><span class="params">(str1)</span></span>;<span class="comment">//语句2 拷贝初始化</span></span><br><span class="line"><span class="built_in">string</span> str3 = <span class="string">"I am a string"</span>;<span class="comment">//语句3 拷贝初始化，先为字符串”I am a string“创建临时对象，再把临时对象作为参数，使用拷贝构造函数构造str3</span></span><br><span class="line"><span class="built_in">string</span> str4 = str1;<span class="comment">//语句4 拷贝初始化，这里相当于隐式调用拷贝构造函数，而不是调用赋值运算符函数</span></span><br></pre></td></tr></table></figure>

<h5 id="29、初始化和赋值的区别"><a href="#29、初始化和赋值的区别" class="headerlink" title="29、初始化和赋值的区别"></a>29、初始化和赋值的区别</h5><ul>
<li>对于简单类型来说，初始化和赋值没什么区别</li>
<li>对于类和复杂数据类型来说<ul>
<li>定义的时候初始化就是直接初始化</li>
<li>先定义（已经分配内存），后赋值就是赋值</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">1</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">    A a1 = a; <span class="comment">//拷贝初始化操作，调用拷贝构造函数</span></span><br><span class="line">    A b;</span><br><span class="line">    b = a;<span class="comment">//赋值操作，对象a中，num1 = 1，num2 = 1；对象b中，num1 = 2，num2 = 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="40、什么情况下会调用拷贝构造函数"><a href="#40、什么情况下会调用拷贝构造函数" class="headerlink" title="40、什么情况下会调用拷贝构造函数"></a>40、什么情况下会调用拷贝构造函数</h5><ul>
<li>用实例化对象初始化另一个对象</li>
<li>函数的参数对象（非引用传递），本质是实参对象去初始化形参对象</li>
<li>函数的返回值是对象<ul>
<li><strong>在Linux g++ 下则不会发生拷贝构造函数，不仅如此即使返回局部对象的引用，依然不会发生拷贝构造函数</strong></li>
<li><strong>Windows + VS2019在值返回的情况下发生拷贝构造函数，引用返回方式则不发生拷贝构造函数</strong><ul>
<li>在c++编译器发生NRV（Named return Value优化）优化，如果是引用返回的形式则不会调用拷贝构造函数，如果是值传递的方式依然会发生拷贝构造函数。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="69、C-中将临时变量作为返回值时的处理过程"><a href="#69、C-中将临时变量作为返回值时的处理过程" class="headerlink" title="69、C++中将临时变量作为返回值时的处理过程"></a>69、C++中将临时变量作为返回值时的处理过程</h5><ul>
<li>返回值被存储在寄存器中，接受函数返回值时，用寄存器的值初始化</li>
</ul>
<h5 id="34、C-有哪几种的构造函数"><a href="#34、C-有哪几种的构造函数" class="headerlink" title="34、C++有哪几种的构造函数"></a>34、C++有哪几种的构造函数</h5><ul>
<li>默认构造函数</li>
<li>初始化构造函数（有参数）</li>
<li>拷贝构造函数</li>
<li>移动构造函数（move和右值引用）</li>
<li>委托构造函数<ul>
<li>可在构造函数中调用构造函数</li>
</ul>
</li>
<li>转换构造函数<ul>
<li>转换构造函数用于将其他类型的变量，隐式转换为本类对象</li>
</ul>
</li>
</ul>
<h5 id="103、如果有一个空类，它会默认添加哪些函数？"><a href="#103、如果有一个空类，它会默认添加哪些函数？" class="headerlink" title="103、如果有一个空类，它会默认添加哪些函数？"></a>103、如果有一个空类，它会默认添加哪些函数？</h5><ul>
<li>默认构造函数</li>
<li>拷贝构造函数</li>
<li>析构函数</li>
<li>赋值运算符</li>
</ul>
<p>c++11</p>
<ul>
<li>默认构造</li>
<li>析构函数</li>
<li>拷贝构造</li>
<li>赋值构造</li>
<li>移动拷贝构造</li>
<li>移动赋值构造</li>
</ul>
<h5 id="116、-如何禁止程序自动生成拷贝构造函数"><a href="#116、-如何禁止程序自动生成拷贝构造函数" class="headerlink" title="116、 如何禁止程序自动生成拷贝构造函数"></a>116、 如何禁止程序自动生成拷贝构造函数</h5><blockquote>
<p>c++11 delete/default : <a href="https://zhuanlan.zhihu.com/p/374042021" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/374042021</a></p>
</blockquote>
<ul>
<li>自己重写拷贝构造和等号赋值</li>
<li>c++11 让拷贝构造 = delete<ul>
<li><code>Persion() = delete;</code></li>
</ul>
</li>
<li>若需要禁止访问拷贝构造和等号赋值<ul>
<li>将拷贝构造和等号赋值重载为private</li>
<li>类的成员函数和friend函数还是可以调用private函数<ul>
<li>定一个base类，在base类中将拷贝构造函数和拷贝赋值函数设置成private</li>
<li>son类中不再定义拷贝构造函数，此时son中将也不存在拷贝构造函数</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Base()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Base create..."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 拷贝构造函数</span></span><br><span class="line">  Base(Base&amp; b)&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Base copy..."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Son()&#123; </span></span><br><span class="line">  <span class="comment">//   cout&lt;&lt;"Son create..."&lt;&lt;endl;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Son s;</span><br><span class="line">  <span class="comment">// 此时就不能正常使用拷贝构造函数了</span></span><br><span class="line">  <span class="comment">// Son ss(s); // 提示：无法引用 函数 "Son::Son(Son &amp;)" (已隐式声明) -- 它是已删除的函数</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印</span></span><br><span class="line"><span class="comment">// Base create...</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果在son中重写拷贝构造函数，对于son的实例化还是可以调用拷贝构造函数的<ul>
<li>但是子类的拷贝构造函数还是不能使用的，即使为public，也不会调用base的拷贝构造函数，调用的仍然是base的构造函数</li>
<li>要实现base的拷贝构造函数的功能，则需要在son的构造函数中重写</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> num;</span><br><span class="line">  Base()&#123;</span><br><span class="line">    num = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Base create..."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setNUm</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    num = n;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 拷贝构造函数</span></span><br><span class="line">  Base(Base&amp; b)&#123;</span><br><span class="line">    num = b.num;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Base copy..."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Son()&#123; </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Son create..."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Son(Son&amp; s)&#123;</span><br><span class="line">    num = s.num;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Son copy..."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	Son s;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;s.num&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  s.setNUm(<span class="number">20</span>);</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;s.num&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="function">Son <span class="title">ss</span><span class="params">(s)</span></span>; <span class="comment">// 调用的是子类的构造函数 ======重要：注意======</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;ss.num&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印</span></span><br><span class="line"><span class="comment">// Base create...</span></span><br><span class="line"><span class="comment">// Son create...</span></span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"><span class="comment">// 20</span></span><br><span class="line"><span class="comment">// Base create...</span></span><br><span class="line"><span class="comment">// Son copy...</span></span><br><span class="line"><span class="comment">// 20</span></span><br></pre></td></tr></table></figure>



<h5 id="没有默认构造函数的情况"><a href="#没有默认构造函数的情况" class="headerlink" title="没有默认构造函数的情况"></a>没有默认构造函数的情况</h5><ul>
<li>只要定义了任何一种构造函数，默认构造函数就不会自动生成了，例如下面自定义了拷贝构造函数，则编译器不在提供默认构造函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 拷贝构造函数</span></span><br><span class="line">  Base(Base&amp; b)&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Base copy..."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Son()&#123; <span class="comment">// 报错，提示Base没有默认构造函数</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"son create"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>









<h5 id="58、类成员初始化方式？构造函数的执行顺序-？为什么用成员初始化列表会快一些？"><a href="#58、类成员初始化方式？构造函数的执行顺序-？为什么用成员初始化列表会快一些？" class="headerlink" title="58、类成员初始化方式？构造函数的执行顺序 ？为什么用成员初始化列表会快一些？"></a>58、类成员初始化方式？构造函数的执行顺序 ？为什么用成员初始化列表会快一些？</h5><ul>
<li>执行顺序<ul>
<li>虚拟基类的构造函数（多个虚拟基类则按照继承的顺序执行构造函数）</li>
<li>基类的构造函数（多个普通基类也按照继承的顺序执行构造函数）</li>
<li>成员对象的构造函数（按照成员对象在类中的定义顺序）</li>
<li>引用 ： 初始化列表</li>
<li>常量 ：初始化列表</li>
<li>派生类自己的构造函数</li>
</ul>
</li>
<li>初始化列表<ul>
<li>在对象初始化（分配空间）的时候就给成员赋值了</li>
<li><strong>只调用一次有参构造</strong></li>
</ul>
</li>
<li>构造函数体内的初始化<ul>
<li>在对象初始化（分配空间）的时候调用的是默认构造函数，先分配了空间</li>
<li>然后在构造函数体中通过赋值进行初始化</li>
<li><strong>这种方式对于值类型无所谓，但是对于对象成员就多了一次默认构造的调用</strong></li>
<li><strong>一次默认构造+拷贝构造</strong></li>
</ul>
</li>
</ul>
<h5 id="59、有哪些情况必须用到成员列表初始化？作用是什么？"><a href="#59、有哪些情况必须用到成员列表初始化？作用是什么？" class="headerlink" title="59、有哪些情况必须用到成员列表初始化？作用是什么？"></a>59、有哪些情况必须用到成员列表初始化？作用是什么？</h5><ul>
<li>当初始化一个引用成员时；</li>
<li>当初始化一个常量成员时；</li>
<li>当调用一个基类的构造函数，而它拥有一组参数时；</li>
<li>当调用一个成员类的构造函数，而它拥有一组参数时</li>
</ul>
<h5 id="115、如何阻止一个类被实例化？有哪些方法？"><a href="#115、如何阻止一个类被实例化？有哪些方法？" class="headerlink" title="115、如何阻止一个类被实例化？有哪些方法？"></a>115、如何阻止一个类被实例化？有哪些方法？</h5><ol>
<li>将类定义为抽象基类或者将构造函数声明为private；</li>
</ol>
<h3 id="string、char-、const-char"><a href="#string、char-、const-char" class="headerlink" title="string、char *、const char*"></a>string、<code>char *、const char*</code></h3><h5 id="16、strlen和sizeof区别？"><a href="#16、strlen和sizeof区别？" class="headerlink" title="16、strlen和sizeof区别？"></a>16、strlen和sizeof区别？</h5><ul>
<li>sizeof是运算符<ul>
<li>参数可以是任何数据的类型或者数据</li>
<li>因为sizeof值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小</li>
<li>注意字符指针，返回结果是指针的大小</li>
</ul>
</li>
<li>strlen是字符处理的库函数<ul>
<li>参数只能是字符指针且结尾是’\0’的字符串</li>
<li>返回长度不包括’\0’</li>
</ul>
</li>
</ul>
<h5 id="60、C-中新增了string，它与C语言中的-char-有什么区别吗？它是如何实现的"><a href="#60、C-中新增了string，它与C语言中的-char-有什么区别吗？它是如何实现的" class="headerlink" title="60、C++中新增了string，它与C语言中的 char *有什么区别吗？它是如何实现的"></a>60、C++中新增了string，它与C语言中的 char *有什么区别吗？它是如何实现的</h5><ul>
<li>string继承自basic_string,其实是对<code>char*</code>进行了封装，封装的string包含了<code>char*</code>数组，容量，长度等属性</li>
<li>string可动态扩容</li>
</ul>
<h5 id="105、你知道const-char-与string之间的关系是什么吗？"><a href="#105、你知道const-char-与string之间的关系是什么吗？" class="headerlink" title="105、你知道const char* 与string之间的关系是什么吗？"></a>105、你知道const char* 与string之间的关系是什么吗？</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//const char*、char*转string</span></span><br><span class="line">  <span class="keyword">char</span>* c = <span class="string">"abc"</span>;</span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(c)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* cc = <span class="string">"hello"</span>;</span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">ss</span><span class="params">(cc)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// string、char* 转const char*</span></span><br><span class="line">  <span class="built_in">string</span> s = <span class="string">"abc"</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* cc1 = s.c_str();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span>* c = <span class="string">"hello"</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* cc2 = c;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// string、const char* 转 char*</span></span><br><span class="line">  <span class="built_in">string</span> s = <span class="string">"abc"</span>;</span><br><span class="line">  <span class="keyword">char</span>* c1 = <span class="keyword">new</span> <span class="keyword">char</span>[s.length()+<span class="number">1</span>];</span><br><span class="line">  <span class="built_in">strcpy</span>(c1, s.c_str());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* cc = <span class="string">"hello"</span>; </span><br><span class="line">  <span class="keyword">char</span>* c2 = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(cc)+<span class="number">1</span>]; </span><br><span class="line">  <span class="built_in">strcpy</span>(c2, cc);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多态，虚函数"><a href="#多态，虚函数" class="headerlink" title="多态，虚函数"></a>多态，虚函数</h3><h5 id="27、final和override关键字"><a href="#27、final和override关键字" class="headerlink" title="27、final和override关键字"></a>27、final和override关键字</h5><h5 id="33、C-中的重载、重写（覆盖）和隐藏的区别"><a href="#33、C-中的重载、重写（覆盖）和隐藏的区别" class="headerlink" title="33、C++中的重载、重写（覆盖）和隐藏的区别"></a>33、C++中的重载、重写（覆盖）和隐藏的区别</h5><ul>
<li><p>重载</p>
<ul>
<li>参数个数不同</li>
<li>参数顺序不同</li>
<li>参数类型不同</li>
<li>不能是返回值不同来区分</li>
</ul>
</li>
<li><p>重写</p>
<ul>
<li>父类是虚函数，且函数名、参数类型、参数个数完全相同</li>
<li>父类指针可以正常调用子类的重写函数</li>
</ul>
</li>
<li><p>隐藏</p>
<ul>
<li>父类不是虚函数，且函数名、参数类型、参数个数完全相同</li>
<li><strong>两个函数参数不同，无论基类函数是不是虚函数，都会被隐藏。</strong></li>
<li>总结：函数名相同则父类同名函数被隐藏<ul>
<li>除了了重写的情况：父类是虚函数，且函数名、参数类型、参数个数完全相同</li>
</ul>
</li>
<li><em>父类指针<strong>不能</strong>正常调用子类的隐藏父类的函数，父类指针只能调用父类被隐藏的函数</em>   多态的情况下</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123; <span class="comment">// 虚函数</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"This is A fun "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"This is A add "</span> &lt;&lt; a + b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a)</span> <span class="keyword">override</span> </span>&#123;  <span class="comment">// 覆盖</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"this is B fun "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;   <span class="comment">// 隐藏</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"This is B add "</span> &lt;&lt; a + a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 基类指针指向派生类对象时，基类指针可以直接调用到派生类的覆盖函数，也可以通过 :: 调用到基类被覆盖</span></span><br><span class="line">    <span class="comment">// 的虚函数；而基类指针只能调用基类的被隐藏函数，无法识别派生类中的隐藏函数。</span></span><br><span class="line"></span><br><span class="line">    A *p = <span class="keyword">new</span> B();</span><br><span class="line">    p-&gt;fun(<span class="number">1</span>);      <span class="comment">// 调用子类 fun 覆盖函数</span></span><br><span class="line">    p-&gt;A::fun(<span class="number">1</span>);   <span class="comment">// 调用父类 fun</span></span><br><span class="line">    p-&gt;add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// p-&gt;add(1);      // 错误，识别的是 A 类中的 add 函数，参数不匹配</span></span><br><span class="line">    <span class="comment">// p-&gt;B::add(1);   // 错误，无法识别子类 add 函数</span></span><br><span class="line"></span><br><span class="line">    B b;</span><br><span class="line">    b.add(<span class="number">1</span>);       <span class="comment">// 调用子类 add 函数</span></span><br><span class="line">    <span class="comment">// b.add(1, 2);    // 调用父类 add 函数  不能正常调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="65、C-的四种强制转换reinterpret-cast-const-cast-static-cast-dynamic-cast"><a href="#65、C-的四种强制转换reinterpret-cast-const-cast-static-cast-dynamic-cast" class="headerlink" title="65、C++的四种强制转换reinterpret_cast/const_cast/static_cast /dynamic_cast"></a>65、C++的四种强制转换reinterpret_cast/const_cast/static_cast /dynamic_cast</h5><blockquote>
<p>参考：面试问题：c++: 多态指针转型</p>
</blockquote>
<ul>
<li><strong>reinterpret_cast</strong>：用于类型之间进行强制转换</li>
<li><strong>const_cast</strong>： 修改类型的const或volatile属性</li>
<li><strong>static_cast</strong><ul>
<li>父子类之间转换<ul>
<li>向上转型，安全</li>
<li>向下转型，不安全，转型成功，但使用子类独有数据时可能因为未初始化而报错</li>
</ul>
</li>
<li>用于基本数据类型之间的转换</li>
<li>把空指针转换成目标类型的空指针</li>
<li>把任何类型的表达式转换成void类型</li>
</ul>
</li>
<li><strong>dynamic_cast</strong><ul>
<li>父子类之间转换<ul>
<li>向上转型，安全</li>
<li>向下转型，安全，转型成功返回相应的指针(基类指针确实指向一个派生类)，转成不成功则返回nullptr，便于判断进行后续操作</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="71、静态类型和动态类型，静态绑定和动态绑定的介绍"><a href="#71、静态类型和动态类型，静态绑定和动态绑定的介绍" class="headerlink" title="71、静态类型和动态类型，静态绑定和动态绑定的介绍"></a>71、静态类型和动态类型，静态绑定和动态绑定的介绍</h5><blockquote>
<p> 看原文，花点时间</p>
</blockquote>
<ul>
<li>动态绑定主要指有虚函数的情况，运行的时候确定</li>
<li>静态绑定，编译的时候确定<ul>
<li><code>A* a  = null</code>: 这种情况是可以正常调用方法的（<code>a.fun()</code>），因为是静态绑定，但是如果方法中有使用成员变量，则会报错，因为成员变量没有初始化</li>
</ul>
</li>
<li>当缺省参数和virtual函数一起使用的时候一定要谨慎，，，，看原文</li>
</ul>
<h5 id="72、引用是否能实现动态绑定，为什么可以实现？"><a href="#72、引用是否能实现动态绑定，为什么可以实现？" class="headerlink" title="72、引用是否能实现动态绑定，为什么可以实现？"></a>72、引用是否能实现动态绑定，为什么可以实现？</h5><ul>
<li>可以，和指针一样，只不过引用初始化必须赋值，不能用nullptr初始化（需要用左值初始化引用）</li>
<li><strong>需要说明的是虚函数才具有动态绑定</strong>，子类的非虚函数是不能通过父类指针访问的</li>
</ul>
<h5 id="78、类如何实现只能静态分配和只能动态分配"><a href="#78、类如何实现只能静态分配和只能动态分配" class="headerlink" title="78、类如何实现只能静态分配和只能动态分配"></a>78、类如何实现只能静态分配和只能动态分配</h5><ul>
<li>只能静态分配<ul>
<li>把new、delete运算符重载为private属性</li>
</ul>
</li>
<li>只能动态分配<ul>
<li>把构造、析构函数设为protected属性，再用子类来动态创建<ul>
<li>设为protected属性，保证了不能直接静态分配</li>
<li>每次获取只能通过子类获取</li>
<li>在子类中写死，每次分配只通过动态分配</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="79、如果想将某个类用作基类，为什么该类必须定义而非声明"><a href="#79、如果想将某个类用作基类，为什么该类必须定义而非声明" class="headerlink" title="79、如果想将某个类用作基类，为什么该类必须定义而非声明"></a>79、如果想将某个类用作基类，为什么该类必须定义而非声明</h5><blockquote>
<p><a href="https://blog.csdn.net/guomutian911/article/details/49200949?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168890861816800192265966%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168890861816800192265966&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-2-49200949-null-null.142^v88^insert_down28v1,239^v2^insert_chatgpt&utm_term=c%2B%2B%E7%B1%BB%E7%9A%84%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%AE%9A%E4%B9%89&spm=1018.2226.3001.4187" target="_blank" rel="noopener">c++中类的申明和定义</a></p>
</blockquote>
<ul>
<li>派生类中包含并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类必须知道他们是什么。所以必须定义而非声明<ul>
<li>子类需要使用父类的方法，要知道方法具体是什么，就必须定义</li>
</ul>
</li>
</ul>
<h5 id="93、定义和声明的区别"><a href="#93、定义和声明的区别" class="headerlink" title="93、定义和声明的区别"></a>93、定义和声明的区别</h5><ul>
<li><p><strong>如果是指变量的声明和定义：</strong> 从编译原理上来说，声明是仅仅告诉编译器，有个某类型的变量会被使用，但是编译器并不会为它分配任何内存。而定义就是分配了内存。</p>
</li>
<li><p><strong>如果是指函数的声明和定义：</strong> 声明：一般在头文件里，对编译器说：这里我有一个函数叫function() 让编译器知道这个函数的存在。 定义：一般在源文件里，具体就是函数的实现过程 写明函数体。</p>
</li>
</ul>
<h5 id="15、变量声明和定义区别？"><a href="#15、变量声明和定义区别？" class="headerlink" title="15、变量声明和定义区别？"></a>15、变量声明和定义区别？</h5><ul>
<li>声明，告诉编译器类型，不分配内存，可多次声明</li>
<li>定义，分配内存，多次声明只能定义一次</li>
</ul>
<h5 id><a href="#" class="headerlink" title></a></h5><h5 id="81、知道C-中的组合吗？它与继承相比有什么优缺点吗？"><a href="#81、知道C-中的组合吗？它与继承相比有什么优缺点吗？" class="headerlink" title="81、知道C++中的组合吗？它与继承相比有什么优缺点吗？"></a>81、知道C++中的组合吗？它与继承相比有什么优缺点吗？</h5><ul>
<li>组合<ul>
<li>高内聚，低耦合</li>
</ul>
</li>
<li>继承<ul>
<li>高耦合<ul>
<li>父类修改，子类也可能需要修改</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="122、成员函数里memset-this-0-sizeof-this-会发生什么"><a href="#122、成员函数里memset-this-0-sizeof-this-会发生什么" class="headerlink" title="122、成员函数里memset(this,0,sizeof(*this))会发生什么"></a>122、成员函数里memset(this,0,sizeof(*this))会发生什么</h5><ul>
<li>有虚函数，会把虚函数指针置空</li>
<li>有成员对象，会破坏成员对象的内存</li>
</ul>
<h3 id="非常规"><a href="#非常规" class="headerlink" title="非常规"></a>非常规</h3><h5 id="30、extern”C”的用法"><a href="#30、extern”C”的用法" class="headerlink" title="30、extern”C”的用法"></a>30、extern”C”的用法</h5><h5 id="32、C和C-的类型安全"><a href="#32、C和C-的类型安全" class="headerlink" title="32、C和C++的类型安全"></a>32、C和C++的类型安全</h5><ul>
<li>c<ul>
<li>malloc返回值问题易出错</li>
</ul>
</li>
<li>c++<ul>
<li>new 替代 malloc</li>
<li>nullptr 替代 NULL</li>
<li>const 替代 define</li>
<li><strong>dynamic_cast</strong>, 向下转型更安全相比static_cast</li>
</ul>
</li>
</ul>
<h5 id="19、各语言区别"><a href="#19、各语言区别" class="headerlink" title="19、各语言区别"></a>19、各语言区别</h5><p><strong>字节码、程序编译与程序解释</strong></p>
<ul>
<li>编译是将高级语言整体翻译为底层语言在机器上执行，编译是将高级语言翻译成和高级语言逻辑完全一致的低级语言</li>
<li>解释是将高级语言作为输入，一句一转换的转换为底层指令在机器上执行</li>
</ul>
<p><img src="/2022/01/26/C++/c++bagu/image-20230106145803859.png" alt="image-20230106145803859"></p>
<ul>
<li><p>编译型语言: C/C+＋、Object-C、Golang</p>
</li>
<li><p>解释型语言：Python、Php、Javascript</p>
</li>
<li><p>java虚拟机</p>
<ul>
<li>Java是一种编译+解释的语言<ul>
<li>java程序  编译成  JVM字节码 </li>
<li>JVM字节码 解释成  机器码</li>
<li>字节码(英语:Bytecode)通常指的是已经经过编译，但与特定机器代码无关，需要解释器转译后才能成为机器代码的中间代码。字节码通常不像源码一样可以让人阅读，而是编码后的数值常量、引用、指令等构成的序列。</li>
</ul>
</li>
<li>Java程序 –&gt; Java字节码 –&gt; Java虚拟机 –&gt; 操作系统</li>
<li>没有虚拟机的问题<ul>
<li>不同平台不同的编译器</li>
<li>不同平台部署需要重新编译</li>
<li>编译结果不复用</li>
</ul>
</li>
<li>有了Java虚拟机，一次编译，随处运行</li>
</ul>
</li>
</ul>
<p><img src="/2022/01/26/C++/c++bagu/image-20230106150451923.png" alt="image-20230106150451923"></p>
<h5 id="38、如何用代码判断大小端存储？"><a href="#38、如何用代码判断大小端存储？" class="headerlink" title="38、如何用代码判断大小端存储？"></a>38、如何用代码判断大小端存储？</h5><ul>
<li>联合体</li>
<li>强制类型转换</li>
</ul>
<h5 id="39、volatile、mutable和explicit关键字的用法"><a href="#39、volatile、mutable和explicit关键字的用法" class="headerlink" title="39、volatile、mutable和explicit关键字的用法"></a>39、volatile、mutable和explicit关键字的用法</h5><blockquote>
<p><a href="https://blog.csdn.net/k6604125/article/details/126524992" target="_blank" rel="noopener">C++中的explicit详解</a></p>
</blockquote>
<ul>
<li>volatile：每次都去内存中取值</li>
<li>mutable：const可修改</li>
<li>explicit：禁止构造函数隐式类型转换<ul>
<li>28、拷贝初始化和直接初始化</li>
<li>“=”隐式调用拷贝构造函数，而不是赋值运算符</li>
</ul>
</li>
</ul>
<h5 id="42、C-的异常处理的方法"><a href="#42、C-的异常处理的方法" class="headerlink" title="42、C++的异常处理的方法"></a>42、C++的异常处理的方法</h5><blockquote>
<p><a href="https://blog.csdn.net/m0_37345402/article/details/105041937" target="_blank" rel="noopener">typeid: 数据类型</a></p>
</blockquote>
<ul>
<li><strong>try、throw和catch关键字</strong></li>
<li><strong>C++标准异常类 exception</strong><ul>
<li>bad_typeid</li>
<li>bad_cast</li>
<li>bad_alloc</li>
<li>out_of_range</li>
</ul>
</li>
</ul>
<h5 id="67、写C-代码时有一类错误是-coredump-，很常见，你遇到过吗？怎么调试这个错误？"><a href="#67、写C-代码时有一类错误是-coredump-，很常见，你遇到过吗？怎么调试这个错误？" class="headerlink" title="67、写C++代码时有一类错误是 coredump ，很常见，你遇到过吗？怎么调试这个错误？"></a>67、写C++代码时有一类错误是 coredump ，很常见，你遇到过吗？怎么调试这个错误？</h5><h5 id="75、-怎样判断两个浮点数是否相等"><a href="#75、-怎样判断两个浮点数是否相等" class="headerlink" title="75、 怎样判断两个浮点数是否相等"></a>75、 怎样判断两个浮点数是否相等</h5><blockquote>
<p><a href="https://blog.csdn.net/rick_geek/article/details/102728105" target="_blank" rel="noopener">为什么不能用==</a></p>
<ul>
<li>0.1， 0.2，0.4，0.6，0.8，0.3，0.7，0.9都是无法精确表示</li>
<li>小数部分乘2取整，直到小数部分为0</li>
</ul>
<p><a href="https://blog.csdn.net/WHY995987477/article/details/100175872" target="_blank" rel="noopener">判断方法</a></p>
<ul>
<li>abs(a-b) 和 eps比较</li>
<li>if (!(a &gt; b || a &lt; b))</li>
</ul>
</blockquote>
<h5 id="88、为什么模板类一般都是放在一个h文件中"><a href="#88、为什么模板类一般都是放在一个h文件中" class="headerlink" title="88、为什么模板类一般都是放在一个h文件中"></a>88、为什么模板类一般都是放在一个h文件中</h5><ul>
<li>模板还没有实例化</li>
</ul>
<h5 id="99、如何在不使用额外空间的情况下，交换两个数？你有几种方法"><a href="#99、如何在不使用额外空间的情况下，交换两个数？你有几种方法" class="headerlink" title="99、如何在不使用额外空间的情况下，交换两个数？你有几种方法"></a>99、如何在不使用额外空间的情况下，交换两个数？你有几种方法</h5><h5 id="117、你知道Debug和Release的区别是什么吗"><a href="#117、你知道Debug和Release的区别是什么吗" class="headerlink" title="117、你知道Debug和Release的区别是什么吗"></a>117、你知道Debug和Release的区别是什么吗</h5><h5 id="125、C-从代码到可执行程序经历了什么？"><a href="#125、C-从代码到可执行程序经历了什么？" class="headerlink" title="125、C++从代码到可执行程序经历了什么？"></a>125、C++从代码到可执行程序经历了什么？</h5><ul>
<li>预编译</li>
<li>编译</li>
<li>汇编</li>
<li>链接</li>
</ul>
<h5 id="127、友元函数和友元类的基本情况"><a href="#127、友元函数和友元类的基本情况" class="headerlink" title="127、友元函数和友元类的基本情况"></a>127、友元函数和友元类的基本情况</h5><ul>
<li><p>友元关系不能被继承。</p>
</li>
<li><p>友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。</p>
</li>
<li><p>友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明</p>
</li>
</ul>
<h3 id="strcpy、sprintf、memcpy"><a href="#strcpy、sprintf、memcpy" class="headerlink" title="strcpy、sprintf、memcpy"></a>strcpy、sprintf、memcpy</h3><h5 id="87、你知道printf函数的实现原理是什么吗"><a href="#87、你知道printf函数的实现原理是什么吗" class="headerlink" title="87、你知道printf函数的实现原理是什么吗"></a>87、你知道printf函数的实现原理是什么吗</h5><ul>
<li>函数压栈，参数从右往左压入栈</li>
<li>对于printf，栈顶，也就最先拿到的就是字符指针</li>
</ul>
<h5 id="90、cout和printf有什么区别？"><a href="#90、cout和printf有什么区别？" class="headerlink" title="90、cout和printf有什么区别？"></a>90、cout和printf有什么区别？</h5><ul>
<li>cout是ostrem的全局对象</li>
<li>printf是库函数</li>
</ul>
<h5 id="100、你知道strcpy和memcpy的区别是什么吗"><a href="#100、你知道strcpy和memcpy的区别是什么吗" class="headerlink" title="100、你知道strcpy和memcpy的区别是什么吗"></a>100、你知道strcpy和memcpy的区别是什么吗</h5><blockquote>
<p><a href="https://blog.csdn.net/qq_42330920/article/details/123660241" target="_blank" rel="noopener">C/C++ memcpy的实现</a></p>
</blockquote>
<ul>
<li>strcpy只能复制字符串，而memcpy可以复制任意内容</li>
<li>strcpy不需要指定长度，它遇到被复制字符的串结束符”\0”才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度</li>
</ul>
<h5 id="112、说一说strcpy、sprintf与memcpy这三个函数的不同之处"><a href="#112、说一说strcpy、sprintf与memcpy这三个函数的不同之处" class="headerlink" title="112、说一说strcpy、sprintf与memcpy这三个函数的不同之处"></a>112、说一说strcpy、sprintf与memcpy这三个函数的不同之处</h5><h5 id="120、strcpy函数和strncpy函数的区别？哪个函数更安全"><a href="#120、strcpy函数和strncpy函数的区别？哪个函数更安全" class="headerlink" title="120、strcpy函数和strncpy函数的区别？哪个函数更安全"></a>120、strcpy函数和strncpy函数的区别？哪个函数更安全</h5><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h5 id="1、类的对象存储空间？"><a href="#1、类的对象存储空间？" class="headerlink" title="1、类的对象存储空间？"></a>1、类的对象存储空间？</h5><ul>
<li>对象和结构体一样</li>
<li>多了虚函数指针</li>
<li>空类size为1</li>
</ul>
<h5 id="3、什么是内存池，如何实现"><a href="#3、什么是内存池，如何实现" class="headerlink" title="3、什么是内存池，如何实现"></a>3、什么是内存池，如何实现</h5><ul>
<li>0-15 共16个链表：4，8，12，，，128</li>
</ul>
<h5 id="4、可以说一下你了解的C-得内存管理吗？"><a href="#4、可以说一下你了解的C-得内存管理吗？" class="headerlink" title="4、可以说一下你了解的C++得内存管理吗？"></a>4、可以说一下你了解的C++得内存管理吗？</h5><ul>
<li>就是问内存分区<ul>
<li>堆</li>
<li>栈</li>
<li>自由存储区  // 这个可能算在堆区</li>
<li>全局／静态存储区： c中分为初始化的.data 和未初始化的.bss  但c++中没有区分</li>
<li>常量存储区</li>
<li>代码区</li>
</ul>
</li>
</ul>
<h5 id="5、C-中类的数据成员和成员函数内存分布情况"><a href="#5、C-中类的数据成员和成员函数内存分布情况" class="headerlink" title="5、C++中类的数据成员和成员函数内存分布情况"></a>5、C++中类的数据成员和成员函数内存分布情况</h5><ul>
<li>成员变量存储和结构体一样</li>
<li>成员函数存储在代码区，包括静态成员函数，只是静态成员函数没有this指针</li>
</ul>
<h5 id="6、关于this指针你知道什么？全说出来"><a href="#6、关于this指针你知道什么？全说出来" class="headerlink" title="6、关于this指针你知道什么？全说出来"></a>6、关于this指针你知道什么？全说出来</h5><ul>
<li>this指针是类的指针，指向对象的首地址</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A a;a.func(<span class="number">10</span>);<span class="comment">//此处，编译器将会编译成：A::func(&amp;a,10);</span></span><br></pre></td></tr></table></figure>

<ul>
<li>this指针只能在成员函数中使用，在全局函数、静态成员函数中都不能用this。</li>
<li>this指针只有在成员函数中才有定义，且存储位置会因编译器不同有不同存储位置,一般成员函数的第一个参数就是this指针。</li>
</ul>
<p>this指针使用场景：</p>
<ul>
<li>一种情况就是，在类的非静态成员函数中返回类对象本身的时候，直接使用 return *this；</li>
<li>另外一种情况是当形参数与成员变量名相同时用于区分，如this-&gt;n = n （不能写成n = n）</li>
</ul>
<h5 id="7、几个this指针的易混问题"><a href="#7、几个this指针的易混问题" class="headerlink" title="7、几个this指针的易混问题"></a>7、几个this指针的易混问题</h5><blockquote>
<p>此题最好看原文</p>
</blockquote>
<p>A. this指针是什么时候创建的？</p>
<ul>
<li>this在成员函数的开始执行前构造，在成员的执行结束后清除<ul>
<li>参考6、关于this指针你知道什么？全说出来  原文</li>
</ul>
</li>
</ul>
<p>B. this指针存放在何处？堆、栈、全局变量，还是其他</p>
<ul>
<li>寄存器，栈，全局变量都有可能</li>
</ul>
<p>C. this指针是如何传递类中的函数的？绑定？还是在函数参数的首参数就是this指针？那么，this指针又是如何找到“类实例后函数的”</p>
<ul>
<li>函数调用前放到寄存器</li>
<li>作为函数第一个参数传给函数</li>
</ul>
<p>D. this指针是如何访问类中的变量的</p>
<ul>
<li>this指针是类的指针</li>
</ul>
<p>E.我们只有获得一个对象后，才能通过对象使用this指针。如果我们知道一个对象this指针的位置，可以直接使用吗</p>
<ul>
<li>获得对象是不能拿到this指针的，只有在对象函数中才能拿到this指针</li>
<li>在对象函数中是可以对this取地址的，也可以正常使用this</li>
</ul>
<p>F.每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数</p>
<ul>
<li>只有虚函数会在类中创建函数表</li>
</ul>
<h5 id="9、在成员函数中调用delete-this会出现什么问题？对象还可以使用吗"><a href="#9、在成员函数中调用delete-this会出现什么问题？对象还可以使用吗" class="headerlink" title="9、在成员函数中调用delete this会出现什么问题？对象还可以使用吗"></a>9、在成员函数中调用delete this会出现什么问题？对象还可以使用吗</h5><ul>
<li>在delete this之后进行的其他任何函数调用，只要不涉及到this指针的内容，都能够正常运行</li>
<li>一旦涉及到this指针，如操作数据成员，调用虚函数等，就会出现不可预期的问题</li>
</ul>
<h5 id="11、-如果在类的析构函数中调用delete-this，会发生什么"><a href="#11、-如果在类的析构函数中调用delete-this，会发生什么" class="headerlink" title="11、 如果在类的析构函数中调用delete this，会发生什么"></a>11、 如果在类的析构函数中调用delete this，会发生什么</h5><ul>
<li>堆栈移除，会递归析构</li>
</ul>
<h5 id="13、请说一下以下几种情况下，下面几个类的大小各是多少"><a href="#13、请说一下以下几种情况下，下面几个类的大小各是多少" class="headerlink" title="13、请说一下以下几种情况下，下面几个类的大小各是多少"></a>13、请说一下以下几种情况下，下面几个类的大小各是多少</h5><blockquote>
<p>看原文</p>
</blockquote>
<ul>
<li>空对象大小为1</li>
<li>static成员不占用对象大小</li>
</ul>
<h5 id="15、类对象的大小受哪些因素影响"><a href="#15、类对象的大小受哪些因素影响" class="headerlink" title="15、类对象的大小受哪些因素影响"></a>15、类对象的大小受哪些因素影响</h5><ul>
<li>成员变量</li>
<li>虚函数指针</li>
<li>内存对齐</li>
<li>基类</li>
</ul>
<h3 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h3><h5 id="3、使用智能指针管理内存资源，RAII是怎么回事？"><a href="#3、使用智能指针管理内存资源，RAII是怎么回事？" class="headerlink" title="3、使用智能指针管理内存资源，RAII是怎么回事？"></a>3、使用智能指针管理内存资源，RAII是怎么回事？</h5><ul>
<li>RAII全称是“Resource Acquisition is Initialization”，直译过来是“资源获取即初始化”</li>
<li>智能指针（std::shared_ptr和std::unique_ptr）即RAII最具代表的实现</li>
</ul>
<h5 id="4、迭代器：-it、it-哪个好，为什么"><a href="#4、迭代器：-it、it-哪个好，为什么" class="headerlink" title="4、迭代器：++it、it++哪个好，为什么"></a>4、迭代器：++it、it++哪个好，为什么</h5><ul>
<li>前置返回引用</li>
<li>后置返回对象，且在内部会产生临时对象</li>
</ul>
<h5 id="5、说一下C-左值引用和右值引用"><a href="#5、说一下C-左值引用和右值引用" class="headerlink" title="5、说一下C++左值引用和右值引用"></a>5、说一下C++左值引用和右值引用</h5><blockquote>
<p>看原文</p>
</blockquote>
<ul>
<li>C++11正是通过引入右值引用来优化性能，具体来说是通过移动语义来避免无谓拷贝的问题，</li>
<li>通过move语义来将临时生成的左值中的资源无代价的转移到另外一个对象中去，</li>
<li>通过完美转发来解决不能按照参数实际类型来转发的问题（同时，完美转发获得的一个好处是可以实现移动语义）</li>
<li>表达式b+c、<strong>函数int func()的返回值是右值</strong></li>
</ul>
<h5 id="7、简单说一下traits技法"><a href="#7、简单说一下traits技法" class="headerlink" title="7、简单说一下traits技法"></a>7、简单说一下traits技法</h5><blockquote>
<p>不会</p>
</blockquote>
<h5 id="8、STL的两级空间配置器"><a href="#8、STL的两级空间配置器" class="headerlink" title="8、STL的两级空间配置器"></a>8、STL的两级空间配置器</h5><blockquote>
<p>不熟，看侯杰视频</p>
</blockquote>
<h5 id="21、STL中的allocator、deallocator"><a href="#21、STL中的allocator、deallocator" class="headerlink" title="21、STL中的allocator、deallocator"></a>21、STL中的allocator、deallocator</h5><h5 id="12、容器内部删除一个元素"><a href="#12、容器内部删除一个元素" class="headerlink" title="12、容器内部删除一个元素"></a>12、容器内部删除一个元素</h5><ul>
<li>顺序容器，删除当前元素，当前元素迭代器失效，后面的迭代器也失效</li>
<li>关联容器，删除当前元素，只当前元素迭代器失效</li>
</ul>
<h5 id="15、如何在共享内存上使用STL标准库？"><a href="#15、如何在共享内存上使用STL标准库？" class="headerlink" title="15、如何在共享内存上使用STL标准库？"></a>15、如何在共享内存上使用STL标准库？</h5><blockquote>
<p>不会</p>
</blockquote>
<h5 id="22、STL中hash-table扩容发生什么？"><a href="#22、STL中hash-table扩容发生什么？" class="headerlink" title="22、STL中hash table扩容发生什么？"></a>22、STL中hash table扩容发生什么？</h5><ul>
<li>hash底层是vector，所以扩容同vector</li>
</ul>
<h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><h5 id="3、构造函数能否声明为虚函数或者纯虚函数，析构函数呢？"><a href="#3、构造函数能否声明为虚函数或者纯虚函数，析构函数呢？" class="headerlink" title="3、构造函数能否声明为虚函数或者纯虚函数，析构函数呢？"></a>3、构造函数能否声明为虚函数或者纯虚函数，析构函数呢？</h5><ul>
<li>析构函数<ul>
<li>一般为虚函数</li>
<li>可以为纯虚函数，该类变为抽象类，不可实例化，子类需要重写析构函数</li>
</ul>
</li>
<li>构造函数<ul>
<li>不能为虚函数<ul>
<li>调用虚函数需要vptr</li>
<li>但是需要调用构造函数才能生成vptr</li>
<li>互相矛盾</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="6、构造函数、析构函数、虚函数可否声明为内联函数"><a href="#6、构造函数、析构函数、虚函数可否声明为内联函数" class="headerlink" title="6、构造函数、析构函数、虚函数可否声明为内联函数"></a>6、构造函数、析构函数、虚函数可否声明为内联函数</h5><ul>
<li>都可以声明为内联函数，不会报错</li>
<li>构造函数和析构函数声明为内联函数也没有意义<ul>
<li>编译器不会将构造函数和析构函数按内联函数去操作</li>
</ul>
</li>
<li>虚函数<ul>
<li>当是指向派生类的指针（多态性）调用声明为inline的虚函数时，不会内联展开；</li>
<li>当是对象本身调用虚函数时，会内联展开，当然前提依然是函数并不复杂的情况下</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  A():a(<span class="number">10</span>)&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// void func()&#123;</span></span><br><span class="line">  <span class="comment">//   cout&lt;&lt;"func"&lt;&lt;endl;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"func...."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">funcc</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"funcc...."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  A a;</span><br><span class="line">  a.func();</span><br><span class="line">  a.funcc();</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(a)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 16   很奇怪</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="10、构造函数和析构函数可以调用虚函数吗，为什么"><a href="#10、构造函数和析构函数可以调用虚函数吗，为什么" class="headerlink" title="10、构造函数和析构函数可以调用虚函数吗，为什么"></a>10、构造函数和析构函数可以调用虚函数吗，为什么</h5><blockquote>
<p>看原文</p>
</blockquote>
<ul>
<li>可以但是不提倡</li>
</ul>
<h5 id="16、构造函数或者析构函数中可以调用虚函数吗"><a href="#16、构造函数或者析构函数中可以调用虚函数吗" class="headerlink" title="16、构造函数或者析构函数中可以调用虚函数吗"></a>16、构造函数或者析构函数中可以调用虚函数吗</h5><blockquote>
<p>看原文，有代码案例</p>
</blockquote>
<ul>
<li>可以但不提倡</li>
</ul>
<h5 id="1、C-的多态如何实现"><a href="#1、C-的多态如何实现" class="headerlink" title="1、C++的多态如何实现"></a>1、C++的多态如何实现</h5><ul>
<li>虚函数</li>
<li>对象的虚函数指针，对象初始化创建</li>
<li>类的虚函数表，编译阶段创建，在常量存储区</li>
<li>动态绑定，父类指针指向子类</li>
</ul>
<h5 id="2、为什么析构函数一般写成虚函数"><a href="#2、为什么析构函数一般写成虚函数" class="headerlink" title="2、为什么析构函数一般写成虚函数"></a>2、为什么析构函数一般写成虚函数</h5><ul>
<li>避免内存泄漏</li>
</ul>
<h5 id="4、基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间"><a href="#4、基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间" class="headerlink" title="4、基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间"></a>4、基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间</h5><ul>
<li>虚函数表<ul>
<li>常量区</li>
<li>编译阶段初始化</li>
</ul>
</li>
<li>虚函数指针<ul>
<li>对象最前面4个字节</li>
<li>对象初始化阶段初始化</li>
</ul>
</li>
</ul>
<h5 id="11、构造函数、析构函数的执行顺序？构造函数和拷贝构造的内部都干了啥？"><a href="#11、构造函数、析构函数的执行顺序？构造函数和拷贝构造的内部都干了啥？" class="headerlink" title="11、构造函数、析构函数的执行顺序？构造函数和拷贝构造的内部都干了啥？"></a>11、构造函数、析构函数的执行顺序？构造函数和拷贝构造的内部都干了啥？</h5><ul>
<li>构造函数<ul>
<li>基类构造函数</li>
<li>成员类构造函数</li>
<li>派生类构造函数</li>
</ul>
</li>
<li>析构函数<ul>
<li>派生类析构函数</li>
<li>成员类析构函数</li>
<li>基类析构函数</li>
</ul>
</li>
</ul>
<h5 id="13、构造函数析构函数可否抛出异常"><a href="#13、构造函数析构函数可否抛出异常" class="headerlink" title="13、构造函数析构函数可否抛出异常"></a>13、构造函数析构函数可否抛出异常</h5><h5 id="17、构造函数的几种关键字"><a href="#17、构造函数的几种关键字" class="headerlink" title="17、构造函数的几种关键字"></a>17、构造函数的几种关键字</h5><ul>
<li>default： 使用默认构造函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CString() = <span class="keyword">default</span>; <span class="comment">//语句1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>delete: 删除</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">()</span> </span>= <span class="keyword">delete</span>;<span class="comment">//这样不允许使用new关键字</span></span><br></pre></td></tr></table></figure>

<h5 id="18、构造函数、拷贝构造函数和赋值操作符的区别"><a href="#18、构造函数、拷贝构造函数和赋值操作符的区别" class="headerlink" title="18、构造函数、拷贝构造函数和赋值操作符的区别"></a>18、构造函数、拷贝构造函数和赋值操作符的区别</h5><ul>
<li><p><strong>构造函数</strong></p>
<ul>
<li>对象不存在，没用别的对象初始化，在创建一个新的对象时调用构造函数</li>
</ul>
</li>
<li><p><strong>拷贝构造函数</strong></p>
<ul>
<li>对象不存在，但是使用别的已经存在的对象来进行初始化</li>
</ul>
</li>
<li><p><strong>赋值运算符</strong></p>
<ul>
<li>对象存在，用别的对象给它赋值，这属于重载“=”号运算符的范畴，“=”号两侧的对象都是已存在的</li>
</ul>
</li>
</ul>
<h5 id="20、什么是虚拟继承"><a href="#20、什么是虚拟继承" class="headerlink" title="20、什么是虚拟继承"></a>20、什么是虚拟继承</h5><blockquote>
<p>看原文</p>
</blockquote>
<ul>
<li>解决菱形继承的问题</li>
<li>避免基类被多次初始化产生歧义</li>
</ul>
<h5 id="21、什么情况会自动生成默认构造函数"><a href="#21、什么情况会自动生成默认构造函数" class="headerlink" title="21、什么情况会自动生成默认构造函数"></a>21、什么情况会自动生成默认构造函数</h5><blockquote>
<p><a href="https://blog.csdn.net/weixin_41066529/article/details/89846314" target="_blank" rel="noopener">何时编译器会自动生成默认构造函数</a></p>
</blockquote>
<ul>
<li>带有默认构造函数的类成员对象</li>
<li>带有默认构造函数的基类</li>
<li>带有一个虚函数的类（需要初始化虚函数指针）</li>
<li>带有一个虚基类的类（需要初始化指向虚基类的指针）</li>
</ul>
<h5 id="32、那什么时候需要合成拷贝构造函数呢"><a href="#32、那什么时候需要合成拷贝构造函数呢" class="headerlink" title="32、那什么时候需要合成拷贝构造函数呢"></a>32、那什么时候需要合成拷贝构造函数呢</h5><ul>
<li>如果一个类没有拷贝构造函数，但是含有一个类类型的成员变量，该类型含有拷贝构造函数，此时编译器会为该类合成一个拷贝构造函数；</li>
<li>如果一个类没有拷贝构造函数，但是该类继承自含有拷贝构造函数的基类，此时编译器会为该类合成一个拷贝构造函数；</li>
<li>如果一个类没有拷贝构造函数，但是该类声明或继承了虚函数，此时编译器会为该类合成一个拷贝构造函数；<ul>
<li>（需要拷贝虚函数指针）</li>
</ul>
</li>
<li>如果一个类没有拷贝构造函数，但是该类含有虚基类，此时编译器会为该类合成一个拷贝构造函数<ul>
<li>（需要拷贝指向虚基类的指针）</li>
</ul>
</li>
</ul>
<h5 id="22、抽象基类为什么不能创建对象"><a href="#22、抽象基类为什么不能创建对象" class="headerlink" title="22、抽象基类为什么不能创建对象"></a>22、抽象基类为什么不能创建对象</h5><ul>
<li>虚函数指针为空，会报错</li>
</ul>
<h5 id="24、多继承的优缺点，作为一个开发者怎么看待多继承"><a href="#24、多继承的优缺点，作为一个开发者怎么看待多继承" class="headerlink" title="24、多继承的优缺点，作为一个开发者怎么看待多继承"></a>24、多继承的优缺点，作为一个开发者怎么看待多继承</h5><ul>
<li>优点：可以调用多个基类的接口</li>
<li>缺点：菱形继承，产生二义性，需要虚继承</li>
</ul>
<h5 id="27、为什么拷贝构造函数必须传引用不能传值"><a href="#27、为什么拷贝构造函数必须传引用不能传值" class="headerlink" title="27、为什么拷贝构造函数必须传引用不能传值"></a>27、为什么拷贝构造函数必须传引用不能传值</h5><ul>
<li>传值会调用拷贝构造函数，就会产生递归调用堆栈溢出</li>
</ul>
<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><h5 id="5、模板函数和模板类的特例化"><a href="#5、模板函数和模板类的特例化" class="headerlink" title="5、模板函数和模板类的特例化"></a>5、模板函数和模板类的特例化</h5><ul>
<li>引入原因<ul>
<li>编写单一的模板，它能适应多种类型的需求，使每种类型都具有相同的功能，但对于某种特定类型，如果要实现其特有的功能，单一模板就无法做到，这时就需要模板特例化</li>
</ul>
</li>
<li>主意：<ul>
<li>模板及其特例化版本应该声明在同一个头文件中，且所有同名模板的声明应该放在前面，后面放特例化版本</li>
</ul>
</li>
<li>函数<ul>
<li>普通函数可以将声明和定义分文件写</li>
<li>函数模板只能都放在头文件中</li>
<li>特例化函数可以将声明和定义分文件写</li>
</ul>
</li>
</ul>
<h5 id="7、C-模板是什么，你知道底层怎么实现的？"><a href="#7、C-模板是什么，你知道底层怎么实现的？" class="headerlink" title="7、C++模板是什么，你知道底层怎么实现的？"></a>7、C++模板是什么，你知道底层怎么实现的？</h5><ul>
<li>编译器从函数模板通过具体类型产生不同的函数；</li>
<li>编译器会对函数模板进行两次编译：<ul>
<li>在声明的地方对模板代码本身进行编译</li>
<li>在调用的地方对参数替换后的代码进行编译。</li>
</ul>
</li>
<li>模板函数声明和定义需要都放在同一个头文件中<ul>
<li>因为函数模板要被实例化后才能成为真正的函数，在使用函数模板的源文件中包含函数模板的头文件，如果该头文件中只有声明，没有定义，那编译器无法实例化该模板，最终导致链接错误</li>
</ul>
</li>
</ul>
<h5 id="23、模板类和模板函数的区别是什么"><a href="#23、模板类和模板函数的区别是什么" class="headerlink" title="23、模板类和模板函数的区别是什么"></a>23、模板类和模板函数的区别是什么</h5><ul>
<li>函数模板允许隐式调用和显式调用</li>
<li>类模板只能显示调用</li>
</ul>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><p>43、Cookie和session的区别</p>
<blockquote>
<p><a href="https://blog.csdn.net/m0_65421722/article/details/127813102" target="_blank" rel="noopener">Cookie和session的区别</a></p>
</blockquote>
<ul>
<li><p>Cookie： 用户信息直接存储在Cookie中</p>
</li>
<li><p>Session：用户信息存储在服务器中，通过cookie传给前端一个sessionid，前端每次请求挈带sessionid，再通过这个sessionid在服务器查询用户信息</p>
</li>
</ul>
<p>44、DDos 攻击了解吗？</p>
<blockquote>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzIwOTcyNjA3Mw==&mid=2247508943&idx=1&sn=d21d59a31de70bd5592204f8650e1d2b&chksm=976d9cd9a01a15cfc0d63b6001b047cf1e0aa9fe4252cac182cfff5735590a1eb28462757074&scene=27" target="_blank" rel="noopener">什么是DDos</a></p>
<p><a href="https://blog.csdn.net/xyyaq/article/details/123727315" target="_blank" rel="noopener">如何防御ddos攻击？</a></p>
</blockquote>
<h2 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h2><h3 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h3><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><blockquote>
<p>应用层是工作在操作系统中的用户态，传输层及以下则工作在内核态</p>
</blockquote>
<h5 id="常见应用层协议"><a href="#常见应用层协议" class="headerlink" title="常见应用层协议"></a>常见应用层协议</h5><table>
<thead>
<tr>
<th>协议</th>
<th>名称</th>
<th>默认端口</th>
<th>底层协议</th>
</tr>
</thead>
<tbody><tr>
<td>HTTP</td>
<td>超文本传输协议</td>
<td>80</td>
<td>TCP</td>
</tr>
<tr>
<td>HTTPS</td>
<td>超文本传输安全协议</td>
<td>443</td>
<td>TCP</td>
</tr>
<tr>
<td>Telnet</td>
<td>远程登录服务的标准协议</td>
<td>23</td>
<td>TCP</td>
</tr>
<tr>
<td>FTP</td>
<td>文件传输协议</td>
<td>20传输和21连接</td>
<td>TCP</td>
</tr>
<tr>
<td>TFTP</td>
<td>简单文件传输协议</td>
<td>69</td>
<td>UDP</td>
</tr>
<tr>
<td>SMTP</td>
<td>简单邮件传输协议（发送用）</td>
<td>25</td>
<td>TCP</td>
</tr>
<tr>
<td>POP</td>
<td>邮局协议（接收用）</td>
<td>110</td>
<td>TCP</td>
</tr>
<tr>
<td>DNS</td>
<td>域名解析服务</td>
<td>53</td>
<td>服务器间进行域传输的时候用TCP 客户端查询DNS服务器时用 UDP</td>
</tr>
</tbody></table>
<h3 id="键入网址到网页显示，期间发生了什么"><a href="#键入网址到网页显示，期间发生了什么" class="headerlink" title="键入网址到网页显示，期间发生了什么"></a>键入网址到网页显示，期间发生了什么</h3><ul>
<li>解析URL并生成http消息<ul>
<li>http消息<ul>
<li>请求行    状态行</li>
<li>请求头    消息头</li>
<li>消息体    消息体</li>
</ul>
</li>
</ul>
</li>
<li>DNS域名解析<ul>
<li>查询浏览缓存</li>
<li>查询操作系统缓存</li>
<li>查询hosts文件</li>
<li>查询本地DNS服务器<ul>
<li>本地服务器有缓存则直接返回   非权威</li>
<li>若本地服务器就是负责这个域名解析的，则返回  是权威的</li>
<li>若都不是则询问根服务器</li>
</ul>
</li>
<li>递归查询<ul>
<li>根服务器问域服务器，域服务器问权威服务器，权威服务器返回域服务器，域服务器返回根服务器，根服务器返回本地服务器</li>
</ul>
</li>
<li>迭代查询<ul>
<li>根服务器返回本地服务器域服务器 ip</li>
<li>本地服务器问域服务器，域服务器返回本地服务器权威服务器ip</li>
<li>本地服务器问权威服务器，权威服务器返回ip</li>
<li>本地服务器返回ip</li>
</ul>
</li>
</ul>
</li>
<li>拿到ip后可以 把HTTP 的传输工作交给操作系统中的<strong>协议栈</strong></li>
<li>tcp传输<ul>
<li>字段<ul>
<li>源端口    16位</li>
<li>目标端口 16位</li>
<li>序号          32位</li>
<li>确认序号  32位</li>
<li>状态位      6位</li>
<li>窗口大小  16位</li>
</ul>
</li>
<li>三次握手</li>
<li><code>MTU</code>：一个网络包的最大长度，以太网中一般为 <code>1500</code> 字节。</li>
<li><code>MSS</code>：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度</li>
</ul>
</li>
<li>ip传输<ul>
<li><code>ICMP</code> 用于告知网络包传送过程中产生的错误以及各种控制信息。</li>
<li><code>ARP</code> 用于根据 IP 地址查询相应的以太网 MAC 地址。</li>
<li>选择源ip(看原文)<ul>
<li>预先选择和目标ip在一个局域网的ip作为源ip</li>
</ul>
</li>
</ul>
</li>
<li>MAC<ul>
<li>获取目标mac地址<ul>
<li>查询ARP缓存</li>
<li>缓存无，则ARP广播</li>
</ul>
</li>
</ul>
</li>
<li></li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/01/26/C++/C++interview/" rel="prev" title="C++interview">
      <i class="fa fa-chevron-left"></i> C++interview
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/01/26/C++/hot100/" rel="next" title="算法总结c++版本">
      算法总结c++版本 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#阿秀"><span class="nav-text">阿秀</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-C"><span class="nav-text">C&#x2F;C++</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基础语法"><span class="nav-text">基础语法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#main函数"><span class="nav-text">main函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、-在main执行之前和之后执行的代码可能是什么？"><span class="nav-text">1、 在main执行之前和之后执行的代码可能是什么？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结构体"><span class="nav-text">结构体</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2、结构体内存对齐问题？"><span class="nav-text">2、结构体内存对齐问题？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#70、如何获得结构成员相对于结构开头的字节偏移量"><span class="nav-text">70、如何获得结构成员相对于结构开头的字节偏移量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#26、数组名和指针（这里为指向数组首元素的指针）区别"><span class="nav-text">26、数组名和指针（这里为指向数组首元素的指针）区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#74、指针加减计算要注意什么？"><span class="nav-text">74、指针加减计算要注意什么？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#31、野指针和悬空指针"><span class="nav-text">31、野指针和悬空指针</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象"><span class="nav-text">对象</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#22、C-中struct和class的区别"><span class="nav-text">22、C++中struct和class的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#28、拷贝初始化和直接初始化"><span class="nav-text">28、拷贝初始化和直接初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#29、初始化和赋值的区别"><span class="nav-text">29、初始化和赋值的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#40、什么情况下会调用拷贝构造函数"><span class="nav-text">40、什么情况下会调用拷贝构造函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#69、C-中将临时变量作为返回值时的处理过程"><span class="nav-text">69、C++中将临时变量作为返回值时的处理过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#34、C-有哪几种的构造函数"><span class="nav-text">34、C++有哪几种的构造函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#103、如果有一个空类，它会默认添加哪些函数？"><span class="nav-text">103、如果有一个空类，它会默认添加哪些函数？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#116、-如何禁止程序自动生成拷贝构造函数"><span class="nav-text">116、 如何禁止程序自动生成拷贝构造函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#没有默认构造函数的情况"><span class="nav-text">没有默认构造函数的情况</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#58、类成员初始化方式？构造函数的执行顺序-？为什么用成员初始化列表会快一些？"><span class="nav-text">58、类成员初始化方式？构造函数的执行顺序 ？为什么用成员初始化列表会快一些？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#59、有哪些情况必须用到成员列表初始化？作用是什么？"><span class="nav-text">59、有哪些情况必须用到成员列表初始化？作用是什么？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#115、如何阻止一个类被实例化？有哪些方法？"><span class="nav-text">115、如何阻止一个类被实例化？有哪些方法？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#string、char-、const-char"><span class="nav-text">string、char *、const char*</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#16、strlen和sizeof区别？"><span class="nav-text">16、strlen和sizeof区别？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#60、C-中新增了string，它与C语言中的-char-有什么区别吗？它是如何实现的"><span class="nav-text">60、C++中新增了string，它与C语言中的 char *有什么区别吗？它是如何实现的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#105、你知道const-char-与string之间的关系是什么吗？"><span class="nav-text">105、你知道const char* 与string之间的关系是什么吗？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多态，虚函数"><span class="nav-text">多态，虚函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#27、final和override关键字"><span class="nav-text">27、final和override关键字</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#33、C-中的重载、重写（覆盖）和隐藏的区别"><span class="nav-text">33、C++中的重载、重写（覆盖）和隐藏的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#65、C-的四种强制转换reinterpret-cast-const-cast-static-cast-dynamic-cast"><span class="nav-text">65、C++的四种强制转换reinterpret_cast&#x2F;const_cast&#x2F;static_cast &#x2F;dynamic_cast</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#71、静态类型和动态类型，静态绑定和动态绑定的介绍"><span class="nav-text">71、静态类型和动态类型，静态绑定和动态绑定的介绍</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#72、引用是否能实现动态绑定，为什么可以实现？"><span class="nav-text">72、引用是否能实现动态绑定，为什么可以实现？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#78、类如何实现只能静态分配和只能动态分配"><span class="nav-text">78、类如何实现只能静态分配和只能动态分配</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#79、如果想将某个类用作基类，为什么该类必须定义而非声明"><span class="nav-text">79、如果想将某个类用作基类，为什么该类必须定义而非声明</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#93、定义和声明的区别"><span class="nav-text">93、定义和声明的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#15、变量声明和定义区别？"><span class="nav-text">15、变量声明和定义区别？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#"><span class="nav-text"></span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#81、知道C-中的组合吗？它与继承相比有什么优缺点吗？"><span class="nav-text">81、知道C++中的组合吗？它与继承相比有什么优缺点吗？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#122、成员函数里memset-this-0-sizeof-this-会发生什么"><span class="nav-text">122、成员函数里memset(this,0,sizeof(*this))会发生什么</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#非常规"><span class="nav-text">非常规</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#30、extern”C”的用法"><span class="nav-text">30、extern”C”的用法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#32、C和C-的类型安全"><span class="nav-text">32、C和C++的类型安全</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#19、各语言区别"><span class="nav-text">19、各语言区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#38、如何用代码判断大小端存储？"><span class="nav-text">38、如何用代码判断大小端存储？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#39、volatile、mutable和explicit关键字的用法"><span class="nav-text">39、volatile、mutable和explicit关键字的用法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#42、C-的异常处理的方法"><span class="nav-text">42、C++的异常处理的方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#67、写C-代码时有一类错误是-coredump-，很常见，你遇到过吗？怎么调试这个错误？"><span class="nav-text">67、写C++代码时有一类错误是 coredump ，很常见，你遇到过吗？怎么调试这个错误？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#75、-怎样判断两个浮点数是否相等"><span class="nav-text">75、 怎样判断两个浮点数是否相等</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#88、为什么模板类一般都是放在一个h文件中"><span class="nav-text">88、为什么模板类一般都是放在一个h文件中</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#99、如何在不使用额外空间的情况下，交换两个数？你有几种方法"><span class="nav-text">99、如何在不使用额外空间的情况下，交换两个数？你有几种方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#117、你知道Debug和Release的区别是什么吗"><span class="nav-text">117、你知道Debug和Release的区别是什么吗</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#125、C-从代码到可执行程序经历了什么？"><span class="nav-text">125、C++从代码到可执行程序经历了什么？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#127、友元函数和友元类的基本情况"><span class="nav-text">127、友元函数和友元类的基本情况</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#strcpy、sprintf、memcpy"><span class="nav-text">strcpy、sprintf、memcpy</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#87、你知道printf函数的实现原理是什么吗"><span class="nav-text">87、你知道printf函数的实现原理是什么吗</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#90、cout和printf有什么区别？"><span class="nav-text">90、cout和printf有什么区别？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#100、你知道strcpy和memcpy的区别是什么吗"><span class="nav-text">100、你知道strcpy和memcpy的区别是什么吗</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#112、说一说strcpy、sprintf与memcpy这三个函数的不同之处"><span class="nav-text">112、说一说strcpy、sprintf与memcpy这三个函数的不同之处</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#120、strcpy函数和strncpy函数的区别？哪个函数更安全"><span class="nav-text">120、strcpy函数和strncpy函数的区别？哪个函数更安全</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存管理"><span class="nav-text">内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、类的对象存储空间？"><span class="nav-text">1、类的对象存储空间？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、什么是内存池，如何实现"><span class="nav-text">3、什么是内存池，如何实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4、可以说一下你了解的C-得内存管理吗？"><span class="nav-text">4、可以说一下你了解的C++得内存管理吗？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5、C-中类的数据成员和成员函数内存分布情况"><span class="nav-text">5、C++中类的数据成员和成员函数内存分布情况</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6、关于this指针你知道什么？全说出来"><span class="nav-text">6、关于this指针你知道什么？全说出来</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7、几个this指针的易混问题"><span class="nav-text">7、几个this指针的易混问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9、在成员函数中调用delete-this会出现什么问题？对象还可以使用吗"><span class="nav-text">9、在成员函数中调用delete this会出现什么问题？对象还可以使用吗</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11、-如果在类的析构函数中调用delete-this，会发生什么"><span class="nav-text">11、 如果在类的析构函数中调用delete this，会发生什么</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#13、请说一下以下几种情况下，下面几个类的大小各是多少"><span class="nav-text">13、请说一下以下几种情况下，下面几个类的大小各是多少</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#15、类对象的大小受哪些因素影响"><span class="nav-text">15、类对象的大小受哪些因素影响</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#STL"><span class="nav-text">STL</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3、使用智能指针管理内存资源，RAII是怎么回事？"><span class="nav-text">3、使用智能指针管理内存资源，RAII是怎么回事？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4、迭代器：-it、it-哪个好，为什么"><span class="nav-text">4、迭代器：++it、it++哪个好，为什么</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5、说一下C-左值引用和右值引用"><span class="nav-text">5、说一下C++左值引用和右值引用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7、简单说一下traits技法"><span class="nav-text">7、简单说一下traits技法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8、STL的两级空间配置器"><span class="nav-text">8、STL的两级空间配置器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#21、STL中的allocator、deallocator"><span class="nav-text">21、STL中的allocator、deallocator</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#12、容器内部删除一个元素"><span class="nav-text">12、容器内部删除一个元素</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#15、如何在共享内存上使用STL标准库？"><span class="nav-text">15、如何在共享内存上使用STL标准库？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#22、STL中hash-table扩容发生什么？"><span class="nav-text">22、STL中hash table扩容发生什么？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚函数"><span class="nav-text">虚函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3、构造函数能否声明为虚函数或者纯虚函数，析构函数呢？"><span class="nav-text">3、构造函数能否声明为虚函数或者纯虚函数，析构函数呢？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6、构造函数、析构函数、虚函数可否声明为内联函数"><span class="nav-text">6、构造函数、析构函数、虚函数可否声明为内联函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#10、构造函数和析构函数可以调用虚函数吗，为什么"><span class="nav-text">10、构造函数和析构函数可以调用虚函数吗，为什么</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#16、构造函数或者析构函数中可以调用虚函数吗"><span class="nav-text">16、构造函数或者析构函数中可以调用虚函数吗</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1、C-的多态如何实现"><span class="nav-text">1、C++的多态如何实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、为什么析构函数一般写成虚函数"><span class="nav-text">2、为什么析构函数一般写成虚函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4、基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间"><span class="nav-text">4、基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11、构造函数、析构函数的执行顺序？构造函数和拷贝构造的内部都干了啥？"><span class="nav-text">11、构造函数、析构函数的执行顺序？构造函数和拷贝构造的内部都干了啥？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#13、构造函数析构函数可否抛出异常"><span class="nav-text">13、构造函数析构函数可否抛出异常</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#17、构造函数的几种关键字"><span class="nav-text">17、构造函数的几种关键字</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#18、构造函数、拷贝构造函数和赋值操作符的区别"><span class="nav-text">18、构造函数、拷贝构造函数和赋值操作符的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#20、什么是虚拟继承"><span class="nav-text">20、什么是虚拟继承</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#21、什么情况会自动生成默认构造函数"><span class="nav-text">21、什么情况会自动生成默认构造函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#32、那什么时候需要合成拷贝构造函数呢"><span class="nav-text">32、那什么时候需要合成拷贝构造函数呢</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#22、抽象基类为什么不能创建对象"><span class="nav-text">22、抽象基类为什么不能创建对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#24、多继承的优缺点，作为一个开发者怎么看待多继承"><span class="nav-text">24、多继承的优缺点，作为一个开发者怎么看待多继承</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#27、为什么拷贝构造函数必须传引用不能传值"><span class="nav-text">27、为什么拷贝构造函数必须传引用不能传值</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模板"><span class="nav-text">模板</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#5、模板函数和模板类的特例化"><span class="nav-text">5、模板函数和模板类的特例化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7、C-模板是什么，你知道底层怎么实现的？"><span class="nav-text">7、C++模板是什么，你知道底层怎么实现的？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#23、模板类和模板函数的区别是什么"><span class="nav-text">23、模板类和模板函数的区别是什么</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#计算机网络"><span class="nav-text">计算机网络</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基础篇"><span class="nav-text">基础篇</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-IP"><span class="nav-text">TCP&#x2F;IP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#应用层"><span class="nav-text">应用层</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#常见应用层协议"><span class="nav-text">常见应用层协议</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#键入网址到网页显示，期间发生了什么"><span class="nav-text">键入网址到网页显示，期间发生了什么</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Chuckie"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Chuckie</p>
  <div class="site-description" itemprop="description">Bright future</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">116</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">57</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">100</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/ChuckieWill" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ChuckieWill" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/codewyj.163.com" title="E-Mail → codewyj.163.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.jianshu.com/u/de627226656c" title="https:&#x2F;&#x2F;www.jianshu.com&#x2F;u&#x2F;de627226656c" rel="noopener" target="_blank">简书</a>
        </li>
    </ul>
  </div>

      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="/images/me.png"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chuckie</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">1.1m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">17:04</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
